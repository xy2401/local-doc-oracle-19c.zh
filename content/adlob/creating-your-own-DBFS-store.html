<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>创建自己的DBFS存储</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database SecureFiles and Large Objects Developer&#39;s Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database SecureFiles and Large Objects Developer&#39;s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="securefiles-and-large-objects-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-12T02:58:18-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96333-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="DBFS-content-API.html" title="Previous" type="text/html">
      <link rel="next" href="using-DBFS.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SecureFiles and Large Objects Developer&#39;s Guide">
    <meta name="dcterms.isVersionOf" content="ADLOB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="DBFS-content-API.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-DBFS.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database SecureFiles和Large Objects Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="database-file-system.html" property="item" typeof="WebPage"><span property="name">数据库文件系统（DBFS）</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">创建自己的DBFS存储</li>
            </ol>
            <a id="GUID-01819696-9FE0-41AB-9388-A0ECA1F72E52" name="GUID-01819696-9FE0-41AB-9388-A0ECA1F72E52"></a><a id="ADLOB0079"></a>
            
            <h2 id="ADLOB-GUID-01819696-9FE0-41AB-9388-A0ECA1F72E52" class="sect2"><span class="enumeration_chapter">24</span>创建自己的DBFS存储</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以使用DBFS内容SPI（ <code class="codeph">DBMS_DBFS_CONTENT_SPI)</code>创建自己的DBFS存储。
               </p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="creating-your-own-DBFS-store.html#GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554" title="要自定义DBFS存储，必须实现DBFS内容SPI（DBMS_DBFS_CONTENT_SPI）。它是现有存储（如DBFS SecureFiles存储和DFFS分层存储）以及您创建的任何用户定义的DBFS存储的基础。">DBFS存储库创建和使用概述</a></p>
                  </li>
                  <li>
                     <p> <a href="creating-your-own-DBFS-store.html#GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119" title="DBFS内容SPI（存储提供程序接口）仅是规范，没有包体。">DBFS内容存储提供程序接口（DBFS内容SPI）</a></p>
                  </li>
                  <li>
                     <p><a href="creating-your-own-DBFS-store.html#GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492" title="您可以将此示例存储提供程序用于DBFS，TaBleFileSystem存储提供程序（" tbf="),=" ="">创建自定义提供程序</a></p>
                  </li>
               </ul>
            </div><a id="ADLOB46227"></a><a id="ADLOB46210"></a><div class="props_rev_3"><a id="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554" name="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554"></a><h3 id="ADLOB-GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554" class="sect3">DBFS存储库创建和使用概述</h3>
               <div>
                  <p>要自定义DBFS存储，必须实现DBFS内容SPI（ <code class="codeph">DBMS_DBFS_CONTENT_SPI)</code> 。它是现有存储（如DBFS SecureFiles存储和DFFS分层存储）以及您创建的任何用户定义的DBFS存储的基础。
                  </p>
                  <p>客户端应用程序（如PL / SQL接口）调用DBFS Content API中的函数和过程。然后，DBFS Content API调用DBFS内容SPI中的相应子程序来创建存储并执行其他相关功能。</p>
                  <p>创建DBFS存储后，您将以与SecureFiles存储相同的方式运行它。</p>
                  <div class="infoboxnotealso" id="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554__DBFSCONTENTAPI.DBFSSECUREFILESSTORE-DFF8111B">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="DBFS-content-API.html#GUID-630BE6DB-0178-4EE4-8D7D-824BA886F68E" title="您可以使应用程序在多个不同的编程环境中使用数据库文件系统（DBFS）。">DBFS内容API</a></p>
                        </li>
                        <li>
                           <p><a href="DBFS-securefiles-store.html#GUID-F71C0B85-F08D-4CD0-9EB3-AB84C9B355AE" title="有一些设置和使用DBFS SecureFiles Store的过程。">DBFS SecureFiles商店</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="figure" id="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554__GUID-EAF65659-C9F9-4198-B8A1-D1AD3748F171">
                     <p class="titleinfigure">图24-1数据库文件系统（DBFS）</p><img src="img/adlob201.gif" width="496" alt="下面是图24-1的描述" title="下面是图24-1的描述" longdesc="img_text/adlob201.html"><br><a href="img_text/adlob201.html">“图24-1数据库文件系统（DBFS）”的说明</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="ADLOB46102"></a><div class="props_rev_3"><a id="GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119" name="GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119"></a><h3 id="ADLOB-GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119" class="sect3">DBFS内容存储提供程序接口（DBFS内容SPI）</h3>
               <div>
                  <p>DBFS内容SPI（存储提供程序接口）仅是规范，没有包体。</p>
                  <p>您必须实现包体才能响应来自DBFS Content API的调用。换句话说，DBFS内容SPI是必需程序规范的集合，您必须使用指示的方法签名和语义来实现这些规范。</p>
                  <p>您可以根据需要向DBFS Content SPI包体添加其他功能和过程。您的实现可能实现其他方法并公开其他接口，但DBFS Content API将不使用这些接口。</p>
                  <p>DBFS内容SPI引用DBFS内容API（包<code class="codeph">DBMS_DBFS_CONTENT</code> ）定义的各种元素，例如常量，类型和异常。
                  </p>
                  <p>请注意，所有路径名引用都必须是存储限定的，即，在调用任何Provider SPI方法之前，DBFS Content API已将规范化并将安装点和完整绝对路径名的概念规范化并转换为存储限定路径名。 。</p>
                  <p>由于DBFS Content API和Provider SPI是一对多可插拔体系结构，因此DBFS Content API使用动态SQL来调用Provider SPI中的方法;如果您的Provider SPI实现不遵循本文档中的Provider SPI规范，这可能会导致运行时错误。</p>
                  <p>没有明确的初始或最终方法来指示DBFS Content API何时插入并拔出特定的提供者SPI。提供者SPI必须能够在任何SPI入口点自动初始化自己。</p>
                  <div class="infoboxnotealso" id="GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119__GUID-A8FF224C-9DCD-4126-8B7D-2C448D560D61">
                     <p class="notep1">也可以看看：</p>
                     <p> </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../arpls/DBMS_DBFS_CONTENT_SPI.html#ARPLS72231" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> ，了解<code class="codeph">DBMS_DBFS_CONTENT_SPI</code>包的语法</p>
                        </li>
                        <li>
                           <p>有关更多信息，请参阅文件<code class="codeph">$ORACLE_HOME/rdbms/admin/dbmscapi.sql</code></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADLOB46211"></a><div class="sect2"><a id="GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492" name="GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492"></a><h3 id="ADLOB-GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492" class="sect3">创建自定义提供程序</h3>
               <div>
                  <p>您可以将此示例存储提供程序用于DBFS，TaBleFileSystem存储提供程序（“tbfs”），作为自定义提供程序的框架或作为学习工具，以熟悉DBFS及其SPI。</p>
                  <p>此DBFS示例存储提供程序将包含<code class="codeph">BLOB</code>列的关系表公开为平面非分层文件系统，即命名文件的集合。
                  </p>
                  <p>要使用此示例，假定您已安装Oracle Database 12 <span class="italic">c</span>并熟悉DBFS概念，并已安装并使用<code class="codeph">dbfs_client</code>和<code class="codeph">FUSE</code>来装入和访问由标准SFS存储提供程序支持的文件系统。
                  </p>
                  <p>TaBleFileSystem存储提供程序（“tbfs”）并非旨在功能丰富甚至完整，但它确实提供了足够的演示，说明DBFS用户可以编写自己的自定义提供程序，通过它们公开其表格。 <code class="codeph">dbfs_client</code>到传统的文件系统程序。
                  </p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C" title="这些是DBFS，TaBleFileSystem Store Provider的示例商店提供程序的机制（" tbf=")." ="">机械学</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45" title="TBFS.SQL脚本是顶级驱动程序脚本。">TBFS.SQL</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9" title="TBL.SQL脚本创建测试用户，表空间，支持文件系统的表等等。">TBL.SQL</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-6EBE7625-C688-4346-A4C6-891772A8D821" title="spec.sql脚本提供tbfs的SPI规范。">spec.sql</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8" title="body.sql脚本提供了tbfs的SPI实现。">body.sql</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-33C05C50-B474-47F8-AE49-242837A24D3F" title="capi.sql脚本注册并安装DBFS。">capi.sql</a></p>
                     </li>
                  </ul>
               </div><a id="ADLOB46228"></a><div class="props_rev_3"><a id="GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C" name="GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C"></a><h4 id="ADLOB-GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C" class="sect4">机械学</h4>
                  <div>
                     <p>这些是DBFS，TaBleFileSystem存储提供程序（“tbfs”）的示例存储提供程序的机制。</p>
                     <p>话题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="creating-your-own-DBFS-store.html#GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B" title="您将需要某些文件来安装和设置DBFS TaBleFileSystem Store Provider（" tbf=")." ="">安装和设置</a></p>
                        </li>
                        <li>
                           <p><a href="creating-your-own-DBFS-store.html#GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308" title="一旦DBFS的示例商店提供商，TaBleFileSystem商店提供商（" tbf=")=" ="">TBFS使用</a></p>
                        </li>
                        <li>
                           <p><a href="creating-your-own-DBFS-store.html#GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B" title="TBFS很简单，因为它的主要目的是作为教学和学习的例子。">TBFS内部</a></p>
                        </li>
                     </ul>
                  </div><a id="ADLOB46229"></a><div class="props_rev_3"><a id="GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B" name="GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B"></a><h5 id="ADLOB-GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B" class="sect5">安装和设置</h5>
                     <div>
                        <p>您将需要某些文件来安装和设置DBFS TaBleFileSystem Store Provider（“tbfs”）。</p>
                        <p>TBFS由以下SQL文件组成：</p>
                        <p><code class="codeph">tbfs.sql</code>顶级驱动程序脚本</p>
                        <p><code class="codeph">tbl.sql</code>脚本创建测试用户，表空间，支持文件系统的表，等等。
                        </p>
                        <p><code class="codeph">spec.sql</code>是<code class="codeph">spec.sql</code>的SPI规范</p>
                        <p><code class="codeph">body.sql</code>是<code class="codeph">body.sql</code>的SPI实现</p>
                        <p><code class="codeph">capi.sql</code> DBFS寄存器/挂载脚本</p>
                        <p>要安装TBFS，只需在包含所有上述文件的目录中以<code class="codeph">SYSDBA</code>身份运行<code class="codeph">tbfs.sql</code> 。 <code class="codeph">tbfs.sql</code>将以正确的顺序加载其他SQL文件。
                        </p>
                        <p>忽略任何名称冲突，应加载所有SQL文件而不会出现任何编译错误。所有SQL文件也应加载而不会出现任何运行时错误，具体取决于“plsql_warnings”init.ora参数的值，您可能会看到各种无害的警告。</p>
                        <p>如果存在任何名称冲突（表空间名称TBFS，数据文件名称“tbfs.f”，用户名TBFS，包名称TBFS），则必须一致地更改各种SQL文件中的相应引用。</p>
                     </div>
                  </div><a id="ADLOB46230"></a><div class="props_rev_3"><a id="GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308" name="GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308"></a><h5 id="ADLOB-GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308" class="sect5">TBFS使用</h5>
                     <div>
                        <p>一旦安装了DBFS的示例存储提供程序，即TaBleFileSystem存储提供程序（“tbfs”），就可以通过几种不同的方式添加或删除文件，并可以对TBFS进行其他更改。</p>
                        <p>作为用户<code class="codeph">dbfs_client</code>连接的dbfs_client将看到由RDBMS表（TBFS.TBFST）支持的简单，非分层的文件系统。
                        </p>
                        <p>可以通过SQL（即通过基础表上的DML），Unix实用程序（由<code class="codeph">dbfs_client</code> ）或通过PL / SQL（使用DBFS API）在此文件系统中添加或删除文件。
                        </p>
                        <p>通过任何访问方法对文件系统所做的更改将以事务一致的方式（即在提交/回滚边界）对所有其他访问方法可见。</p>
                     </div>
                  </div><a id="ADLOB46231"></a><div class="props_rev_3"><a id="GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B" name="GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B"></a><h5 id="ADLOB-GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B" class="sect5">TBFS内部</h5>
                     <div>
                        <p>TBFS很简单，因为它的主要目的是作为教学和学习的例子。</p>
                        <p>但是，该实现显示了一条强大的，生产质量的自定义SPI的路径，可以插入到DBFS中，并将现有的关系数据公开为Unix文件系统。</p>
                        <p>TBFS进行了各种简化以保持简洁（但是，这些不应被视为DBFS或SPI的不可侵犯的限制）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>TBFS SPI包仅处理具有硬编码名称的单个表（TBFS.TBFST）。可以使用动态SQL和其他配置信息使单个SPI包支持多个表，每个表作为单独的文件系统（甚至将多个表中的数据统一到单个文件系统中）。</p>
                           </li>
                           <li>
                              <p>TBFS不支持文件系统层次结构;它强加了一个平面命名空间：一个由虚拟“/”根目录下的简单项名称标识的文件集合。实现目录层次结构要复杂得多，因为它要求商店提供商以一致的方式管理父/子关系。</p>
                              <p>此外，现有的关系数据（TBFS试图作为文件系统公开的数据类型）通常不具有形成自然目录/文件层次结构的行间关系。</p>
                           </li>
                           <li>
                              <p>由于TBFS仅支持平面命名空间，因此SPI中的大多数方法<code class="codeph">dbms_dbfs_content.unsupported_operation</code>实现，并且方法体引发了<code class="codeph">dbms_dbfs_content.unsupported_operation</code>异常。此异常也是您编写自定义SPI的良好起点。您可以从<code class="codeph">DBMS_DBFS_CONTENT_SPI</code>包中克隆的简单SPI骨架开始，将所有方法体默认为引发此异常的体，然后逐步填充更实际的实现。
                              </p>
                           </li>
                           <li>
                              <p>TBFS底层的表接近于最简单的结构（键/名称列和LOB列）。这意味着必须动态生成DBFS和<code class="codeph">dbfs_client</code>使用或期望的各种属性（TBFS实现显示了如何对<code class="codeph">std:guid</code>属性执行此操作）。
                              </p>
                              <p>其他属性（例如Unix风格的时间戳）根本没有实现。这仍然允许实现令人惊讶的功能文件系统，但是当您编写自己的自定义SPI时，您可以通过扩展其基础表的结构以根据需要包含其他列，或者通过使用来轻松地合并对其他DBFS属性的支持。现有表中的现有列，以提供这些DBFS属性的值。</p>
                           </li>
                           <li>
                              <p>TBFS没有实现重命名/移动方法;添加对此的支持（ <code class="codeph">renamePath</code>方法中的合适的<code class="codeph">UPDATE</code>语句）留给用户练习。
                              </p>
                           </li>
                           <li>
                              <p>TBFS示例在多个位置使用字符串“tbfs”（表空间，数据文件，用户，包甚至文件系统名称）。“tbfs”的所有这些用法属于不同的名称空间 - 标识哪个名称空间对应于字符串的特定出现。这些示例中的“tbfs”也是一个很好的学习练习，可以确保DBFS概念在您的脑海中清晰可见。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADLOB46232"></a><div class="props_rev_3"><a id="GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45" name="GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45"></a><h4 id="ADLOB-GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45" class="sect4">TBFS.SQL</h4>
                  <div>
                     <p>TBFS.SQL脚本是顶级驱动程序脚本。</p>
                     <p>TBFS.SQL脚本：</p><pre class="oac_no_warn" dir="ltr">set echo on;
 
@tbl
@spec
@body
@capi
 
quit;</pre></div>
               </div><a id="ADLOB46233"></a><div class="props_rev_3"><a id="GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9" name="GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9"></a><h4 id="ADLOB-GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9" class="sect4">TBL.SQL</h4>
                  <div>
                     <p>TBL.SQL脚本创建测试用户，表空间，支持文件系统的表等等。</p>
                     <p>TBL.SQL脚本：</p><pre class="oac_no_warn" dir="ltr">connect / as sysdba
 
create tablespace tbfs datafile 'tbfs.f' size 100m
    reuse autoextend on
    extent management local
    segment space management auto;
 
create user tbfs identified by tbfs;
alter user tbfs default tablespace tbfs;
grant connect, resource, dbfs_role to tbfs;
 
 
connect tbfs/tbfs;
 
drop table tbfst;
purge recyclebin;
 
create table tbfst(
    key     varchar2(256)
            primary key
            check           (instr(key, '/') = 0),
    data    blob)
        tablespace tbfs
    lob(data)
        store as securefile
            (tablespace tbfs);
 
grant select on tbfst to dbfs_role;
grant insert on tbfst to dbfs_role;
grant delete on tbfst to dbfs_role;
grant update on tbfst to dbfs_role;</pre></div>
               </div><a id="ADLOB46234"></a><div class="props_rev_3"><a id="GUID-6EBE7625-C688-4346-A4C6-891772A8D821" name="GUID-6EBE7625-C688-4346-A4C6-891772A8D821"></a><h4 id="ADLOB-GUID-6EBE7625-C688-4346-A4C6-891772A8D821" class="sect4">spec.sql</h4>
                  <div>
                     <p><code class="codeph">spec.sql</code>脚本提供<code class="codeph">spec.sql</code>的SPI规范。
                     </p>
                     <p><code class="codeph">spec.sql</code>脚本：</p><pre class="oac_no_warn" dir="ltr">connect / as sysdba;
 
create or replace package tbfs
    authid current_user
as
 
 
 
    /*
     * Lookup store features (see dbms_dbfs_content.feature_XXX). Lookup
     * store id.
     *
     * A store ID identifies a provider-specific store, across
     * registrations and mounts, but independent of changes to the store
     * contents.
     *
     * I.e. changes to the store table(s) should be reflected in the
     * store ID, but re-initialization of the same store table(s) should
     * preserve the store ID.
     *
     * Providers should also return a "version" (either specific to a
     * provider package, or to an individual store) based on a standard
     * &lt;a.b.c&gt; naming convention (for &lt;major&gt;, &lt;minor&gt;, and &lt;patch&gt;
     * components).
     *
     */
 
    function    getFeatures(
        store_name          in      varchar2)
            return  integer;
 
    function    getStoreId(
        store_name          in      varchar2)
            return  number;
 
    function    getVersion(
        store_name          in      varchar2)
            return  varchar2;
 
 
 
    /*
     * Lookup pathnames by (store_name, std_guid) or (store_mount,
     * std_guid) tuples.
     *
     * If the underlying "std_guid" is found in the underlying store,
     * this function returns the store-qualified pathname.
     *
     * If the "std_guid" is unknown, a "null" value is returned. Clients
     * are expected to handle this as appropriate.
     *
     */
 
    function    getPathByStoreId(
        store_name          in      varchar2,
        guid                in      integer)
            return  varchar2;
 
 
 
    /*
     * DBFS SPI: space usage.
     *
     * Clients can query filesystem space usage statistics via the
     * "spaceUsage()" method. Providers are expected to support this
     * method for their stores (and to make a best effort determination
     * of space usage---esp. if the store consists of multiple
     * tables/indexes/lobs, etc.).
     *
     * "blksize" is the natural tablespace blocksize that holds the
     * store---if multiple tablespaces with different blocksizes are
     * used, any valid blocksize is acceptable.
     *
     * "tbytes" is the total size of the store in bytes, and "fbytes" is
     * the free/unused size of the store in bytes. These values are
     * computed over all segments that comprise the store.
     *
     * "nfile", "ndir", "nlink", and "nref" count the number of
     * currently available files, directories, links, and references in
     * the store.
     *
     * Since database objects are dynamically growable, it is not easy
     * to estimate the division between "free" space and "used" space.
     *
     */
 
    procedure   spaceUsage(
        store_name  in              varchar2,
        blksize     out             integer,
        tbytes      out             integer,
        fbytes      out             integer,
        nfile       out             integer,
        ndir        out             integer,
        nlink       out             integer,
        nref        out             integer);
 
 
 
    /*
     * DBFS SPI: notes on pathnames.
     *
     * All pathnames used in the SPI are store-qualified, i.e. a 2-tuple
     * of the form (store_name, pathname) (where the pathname is rooted
     * within the store namespace).
     *
     *
     * Stores/providers that support contentID-based access (see
     * "feature_content_id") also support a form of addressing that is
     * not based on pathnames. Items are identified by an explicit store
     * name, a "null" pathname, and possibly a contentID specified as a
     * parameter or via the "opt_content_id" property.
     *
     * Not all operations are supported with contentID-based access, and
     * applications should depend only on the simplest create/delete
     * functionality being available.
     *
     */
 
 
 
    /*
     * DBFS SPI: creation operations
     *
     * The SPI must allow the DBFS API to create directory, file, link,
     * and reference elements (subject to store feature support).
     *
     *
     * All of the creation methods require a valid pathname (see the
     * special exemption for contentID-based access below), and can
     * optionally specify properties to be associated with the pathname
     * as it is created. It is also possible for clients to fetch-back
     * item properties after the creation completes (so that
     * automatically generated properties (e.g. "std_creation_time") are
     * immediately available to clients (the exact set of properties
     * fetched back is controlled by the various "prop_xxx" bitmasks in
     * "prop_flags").
     *
     *
     * Links and references require an additional pathname to associate
     * with the primary pathname.
     *
     * File pathnames can optionally specify a BLOB value to use to
     * initially populate the underlying file content (the provided BLOB
     * may be any valid lob: temporary or permanent). On creation, the
     * underlying lob is returned to the client (if "prop_data" is
     * specified in "prop_flags").
     *
     * Non-directory pathnames require that their parent directory be
     * created first. Directory pathnames themselves can be recursively
     * created (i.e. the pathname hierarchy leading up to a directory
     * can be created in one call).
     *
     *
     * Attempts to create paths that already exist is an error; the one
     * exception is pathnames that are "soft-deleted" (see below for
     * delete operations)---in these cases, the soft-deleted item is
     * implicitly purged, and the new item creation is attempted.
     *
     *
     * Stores/providers that support contentID-based access accept an
     * explicit store name and a "null" path to create a new element.
     * The contentID generated for this element is available via the
     * "opt_content_id" property (contentID-based creation automatically
     * implies "prop_opt" in "prop_flags").
     *
     * The newly created element may also have an internally generated
     * pathname (if "feature_lazy_path" is not supported) and this path
     * is available via the "std_canonical_path" property.
     *
     * Only file elements are candidates for contentID-based access.
     *
     */
 
    procedure   createFile(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     in out nocopy   blob,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   createLink(
        store_name  in              varchar2,
        srcPath     in              varchar2,
        dstPath     in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   createReference(
        store_name  in              varchar2,
        srcPath     in              varchar2,
        dstPath     in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   createDirectory(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        prop_flags  in              integer,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
 
 
    /*
     * DBFS SPI: deletion operations
     *
     * The SPI must allow the DBFS API to delete directory, file, link,
     * and reference elements (subject to store feature support).
     *
     *
     * By default, the deletions are "permanent" (get rid of the
     * successfully deleted items on transaction commit), but stores may
     * also support "soft-delete" features. If requested by the client,
     * soft-deleted items are retained by the store (but not typically
     * visible in normal listings or searches).
     *
     * Soft-deleted items can be "restore"d, or explicitly purged.
     *
     *
     * Directory pathnames can be recursively deleted (i.e. the pathname
     * hierarchy below a directory can be deleted in one call).
     * Non-recursive deletions can be performed only on empty
     * directories. Recursive soft-deletions apply the soft-delete to
     * all of the items being deleted.
     *
     *
     * Individual pathnames (or all soft-deleted pathnames under a
     * directory) can be restored or purged via the restore and purge
     * methods.
     *
     *
     * Providers that support filtering can use the provider "filter" to
     * identify subsets of items to delete---this makes most sense for
     * bulk operations (deleteDirectory, restoreAll, purgeAll), but all
     * of the deletion-related operations accept a "filter" argument.
     *
     *
     * Stores/providers that support contentID-based access can also
     * allow file items to be deleted by specifying their contentID.
     *
     */
 
    procedure   deleteFile(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        soft_delete in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   deleteContent(
        store_name  in              varchar2,
        contentID   in              raw,
        filter      in              varchar2,
        soft_delete in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   deleteDirectory(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        soft_delete in              integer,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   restorePath(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   purgePath(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   restoreAll(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   purgeAll(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t);
 
 
 
    /*
     * DBFS SPI: path get/put operations.
     *
     * Existing path items can be accessed (for query or for update) and
     * modified via simple get/put methods.
     *
     * All pathnames allow their metadata (i.e. properties) to be
     * read/modified. On completion of the call, the client can request
     * (via "prop_flags") specific properties to be fetched as well.
     *
     * File pathnames allow their data (i.e. content) to be
     * read/modified. On completion of the call, the client can request
     * (via the "prop_data" bitmaks in "prop_flags") a new BLOB locator
     * that can be used to continue data access.
     *
     * Files can also be read/written without using BLOB locators, by
     * explicitly specifying logical offsets/buffer-amounts and a
     * suitably sized buffer.
     *
     *
     * Update accesses must specify the "forUpdate" flag. Access to link
     * pathnames can be implicitly and internally deferenced by stores
     * (subject to feature support) if the "deref" flag is
     * specified---however, this is dangerous since symbolic links are
     * not always resolvable.
     *
     *
     * The read methods (i.e. "getPath" where "forUpdate" is "false"
     * also accepts a valid "asof" timestamp parameter that can be used
     * by stores to implement "as of" style flashback queries. Mutating
     * versions of the "getPath" and the "putPath" methods do not
     * support as-of modes of operation.
     *
     *
     * "getPathNowait" implies a "forUpdate", and, if implemented (see
     * "feature_nowait"), allows providers to return an exception
     * (ORA-54) rather than wait for row locks.
     *
     */
 
    procedure   getPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     out    nocopy   blob,
        item_type   out             integer,
        prop_flags  in              integer,
        forUpdate   in              integer,
        deref       in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   getPathNowait(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     out    nocopy   blob,
        item_type   out             integer,
        prop_flags  in              integer,
        deref       in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   getPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        amount      in out          number,
        offset      in              number,
        buffer      out    nocopy   raw,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   getPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        amount      in out          number,
        offset      in              number,
        buffers     out    nocopy   dbms_dbfs_content_raw_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   putPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     in out nocopy   blob,
        item_type   out             integer,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   putPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        amount      in              number,
        offset      in              number,
        buffer      in              raw,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   putPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        written     out             number,
        offset      in              number,
        buffers     in              dbms_dbfs_content_raw_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t);
 
 
 
    /*
     * DBFS SPI: rename/move operations.
     *
     * Pathnames can be renamed or moved, possibly across directory
     * hierarchies and mount-points, but within the same store.
     *
     *
     * Non-directory pathnames previously accessible via "oldPath" are
     * renamed as a single item subsequently accessible via "newPath";
     * assuming that "newPath" does not already exist.
     *
     * If "newPath" exists and is not a directory, the rename implicitly
     * deletes the existing item before renaming "oldPath". If "newPath"
     * exists and is a directory, "oldPath" is moved into the target
     * directory.
     *
     *
     * Directory pathnames previously accessible via "oldPath" are
     * renamed by moving the directory and all of its children to
     * "newPath" (if it does not already exist) or as children of
     * "newPath" (if it exists and is a directory).
     *
     *
     * Stores/providers that support contentID-based access and lazy
     * pathname binding also support the "setPath" method that
     * associates an existing "contentID" with a new "path".
     *
     */
 
    procedure   renamePath(
        store_name  in              varchar2,
        oldPath     in              varchar2,
        newPath     in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   setPath(
        store_name  in              varchar2,
        contentID   in              raw,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        ctx         in              dbms_dbfs_content_context_t);
 
 
 
    /*
     * DBFS SPI: directory navigation and search.
     *
     * The DBFS API can list or search the contents of directory
     * pathnames, optionally recursing into sub-directories, optionally
     * seeing soft-deleted items, optionally using flashback "as of" a
     * provided timestamp, and optionally filtering items in/out within
     * the store based on list/search predicates.
     *
     */
 
    function    list(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t)
            return  dbms_dbfs_content_list_items_t
                pipelined;
 
    function    search(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t)
            return  dbms_dbfs_content_list_items_t
                pipelined;
 
 
 
    /*
     * DBFS SPI: locking operations.
     *
     * Clients of the DBFS API can apply user-level locks to any valid
     * pathname (subject to store feature support), associate the lock
     * with user-data, and subsequently unlock these pathnames.
     *
     * The status of locked items is available via various optional
     * properties (see "opt_lock*" above).
     *
     *
     * It is the responsibility of the store (assuming it supports
     * user-defined lock checking) to ensure that lock/unlock operations
     * are performed in a consistent manner.
     *
     */
 
    procedure   lockPath(
        store_name  in              varchar2,
        path        in              varchar2,
        lock_type   in              integer,
        lock_data   in              varchar2,
        ctx         in              dbms_dbfs_content_context_t);
 
    procedure   unlockPath(
        store_name  in              varchar2,
        path        in              varchar2,
        ctx         in              dbms_dbfs_content_context_t);
 
 
 
    /*
     * DBFS SPI: access checks.
     *
     * Check if a given pathname (store_name, path, pathtype) can be
     * manipulated by "operation (see the various
     * "dbms_dbfs_content.op_xxx" opcodes) by "principal".
     *
     * This is a convenience function for the DBFS API; a store that
     * supports access control still internally performs these checks to
     * guarantee security.
     *
     */
 
    function    checkAccess(
        store_name  in              varchar2,
        path        in              varchar2,
        pathtype    in              integer,
        operation   in              varchar2,
        principal   in              varchar2)
            return  integer;
end;
/
show errors;
 
create or replace public synonym tbfs
    for sys.tbfs;
 
grant execute on tbfs
    to dbfs_role;</pre></div>
               </div><a id="ADLOB46235"></a><div class="props_rev_3"><a id="GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8" name="GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8"></a><h4 id="ADLOB-GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8" class="sect4">body.sql</h4>
                  <div>
                     <p><code class="codeph">body.sql</code>脚本提供了<code class="codeph">body.sql</code>的SPI实现。
                     </p>
                     <p><code class="codeph">body.sql</code>脚本：</p><pre class="oac_no_warn" dir="ltr">connect / as sysdba;
 
create or replace package body tbfs
as
 
 
 
    /*
     * Lookup store features (see dbms_dbfs_content.feature_XXX). Lookup
     * store id.
     *
     * A store ID identifies a provider-specific store, across
     * registrations and mounts, but independent of changes to the store
     * contents.
     *
     * I.e. changes to the store table(s) should be reflected in the
     * store ID, but re-initialization of the same store table(s) should
     * preserve the store ID.
     *
     * Providers should also return a "version" (either specific to a
     * provider package, or to an individual store) based on a standard
     * &lt;a.b.c&gt; naming convention (for &lt;major&gt;, &lt;minor&gt;, and &lt;patch&gt;
     * components).
     *
     */
 
    function    getFeatures(
        store_name          in      varchar2)
            return  integer
    is
    begin
        return dbms_dbfs_content.feature_locator;
    end;
 
    function    getStoreId(
        store_name          in      varchar2)
            return  number
    is
    begin
        return 1;
    end;
 
    function    getVersion(
        store_name          in      varchar2)
            return  varchar2
    is
    begin
        return '1.0.0';
    end;
 
 
 
    /*
     * Lookup pathnames by (store_name, std_guid) or (store_mount,
     * std_guid) tuples.
     *
     * If the underlying "std_guid" is found in the underlying store,
     * this function returns the store-qualified pathname.
     *
     * If the "std_guid" is unknown, a "null" value is returned. Clients
     * are expected to handle this as appropriate.
     *
     */
 
    function    getPathByStoreId(
        store_name          in      varchar2,
        guid                in      integer)
            return  varchar2
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
 
 
    /*
     * DBFS SPI: space usage.
     *
     * Clients can query filesystem space usage statistics via the
     * "spaceUsage()" method. Providers are expected to support this
     * method for their stores (and to make a best effort determination
     * of space usage---esp. if the store consists of multiple
     * tables/indexes/lobs, etc.).
     *
     * "blksize" is the natural tablespace blocksize that holds the
     * store---if multiple tablespaces with different blocksizes are
     * used, any valid blocksize is acceptable.
     *
     * "tbytes" is the total size of the store in bytes, and "fbytes" is
     * the free/unused size of the store in bytes. These values are
     * computed over all segments that comprise the store.
     *
     * "nfile", "ndir", "nlink", and "nref" count the number of
     * currently available files, directories, links, and references in
     * the store.
     *
     * Since database objects are dynamically growable, it is not easy
     * to estimate the division between "free" space and "used" space.
     *
     */
 
    procedure   spaceUsage(
        store_name  in              varchar2,
        blksize     out             integer,
        tbytes      out             integer,
        fbytes      out             integer,
        nfile       out             integer,
        ndir        out             integer,
        nlink       out             integer,
        nref        out             integer)
    is
        nblks       number;
    begin
        select count(*) into nfile
            from tbfs.tbfst;
        ndir  := 0;
        nlink := 0;
        nref  := 0;
 
        select sum(bytes) into tbytes
            from user_segments;
        select sum(blocks) into nblks
            from user_segments;
        blksize := tbytes/nblks;
        fbytes  := 0;                                    /* change as needed */
    end;
 
 
 
    /*
     * DBFS SPI: notes on pathnames.
     *
     * All pathnames used in the SPI are store-qualified, i.e. a 2-tuple
     * of the form (store_name, pathname) (where the pathname is rooted
     * within the store namespace).
     *
     *
     * Stores/providers that support contentID-based access (see
     * "feature_content_id") also support a form of addressing that is
     * not based on pathnames. Items are identified by an explicit store
     * name, a "null" pathname, and possibly a contentID specified as a
     * parameter or via the "opt_content_id" property.
     *
     * Not all operations are supported with contentID-based access, and
     * applications should depend only on the simplest create/delete
     * functionality being available.
     *
     */
 
 
 
    /*
     * DBFS SPI: creation operations
     *
     * The SPI must allow the DBFS API to create directory, file, link,
     * and reference elements (subject to store feature support).
     *
     *
     * All of the creation methods require a valid pathname (see the
     * special exemption for contentID-based access below), and can
     * optionally specify properties to be associated with the pathname
     * as it is created. It is also possible for clients to fetch-back
     * item properties after the creation completes (so that
     * automatically generated properties (e.g. "std_creation_time") are
     * immediately available to clients (the exact set of properties
     * fetched back is controlled by the various "prop_xxx" bitmasks in
     * "prop_flags").
     *
     *
     * Links and references require an additional pathname to associate
     * with the primary pathname.
     *
     * File pathnames can optionally specify a BLOB value to use to
     * initially populate the underlying file content (the provided BLOB
     * may be any valid lob: temporary or permanent). On creation, the
     * underlying lob is returned to the client (if "prop_data" is
     * specified in "prop_flags").
     *
     * Non-directory pathnames require that their parent directory be
     * created first. Directory pathnames themselves can be recursively
     * created (i.e. the pathname hierarchy leading up to a directory
     * can be created in one call).
     *
     *
     * Attempts to create paths that already exist is an error; the one
     * exception is pathnames that are "soft-deleted" (see below for
     * delete operations)---in these cases, the soft-deleted item is
     * implicitly purged, and the new item creation is attempted.
     *
     *
     * Stores/providers that support contentID-based access accept an
     * explicit store name and a "null" path to create a new element.
     * The contentID generated for this element is available via the
     * "opt_content_id" property (contentID-based creation automatically
     * implies "prop_opt" in "prop_flags").
     *
     * The newly created element may also have an internally generated
     * pathname (if "feature_lazy_path" is not supported) and this path
     * is available via the "std_canonical_path" property.
     *
     * Only file elements are candidates for contentID-based access.
     *
     */
 
    procedure   createFile(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     in out nocopy   blob,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
        guid        number;
    begin
        if (path = '/') then
            raise dbms_dbfs_content.invalid_path;
        end if;
 
        if content is null then
            content := empty_blob();
        end if;
 
        begin
            insert into tbfs.tbfst values (substr(path,2), content)
                returning data into content;
        exception
            when dup_val_on_index then
                raise dbms_dbfs_content.path_exists;
        end;
 
        select ora_hash(path) into guid from dual;
 
        properties := dbms_dbfs_content_properties_t(
            dbms_dbfs_content_property_t(
                'std:length',
                to_char(dbms_lob.getlength(content)),
                dbms_types.TYPECODE_NUMBER),
            dbms_dbfs_content_property_t(
                'std:guid',
                to_char(guid),
                dbms_types.TYPECODE_NUMBER));
    end;
 
    procedure   createLink(
        store_name  in              varchar2,
        srcPath     in              varchar2,
        dstPath     in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   createReference(
        store_name  in              varchar2,
        srcPath     in              varchar2,
        dstPath     in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   createDirectory(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        prop_flags  in              integer,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
 
 
    /*
     * DBFS SPI: deletion operations
     *
     * The SPI must allow the DBFS API to delete directory, file, link,
     * and reference elements (subject to store feature support).
     *
     *
     * By default, the deletions are "permanent" (get rid of the
     * successfully deleted items on transaction commit), but stores may
     * also support "soft-delete" features. If requested by the client,
     * soft-deleted items are retained by the store (but not typically
     * visible in normal listings or searches).
     *
     * Soft-deleted items can be "restore"d, or explicitly purged.
     *
     *
     * Directory pathnames can be recursively deleted (i.e. the pathname
     * hierarchy below a directory can be deleted in one call).
     * Non-recursive deletions can be performed only on empty
     * directories. Recursive soft-deletions apply the soft-delete to
     * all of the items being deleted.
     *
     *
     * Individual pathnames (or all soft-deleted pathnames under a
     * directory) can be restored or purged via the restore and purge
     * methods.
     *
     *
     * Providers that support filtering can use the provider "filter" to
     * identify subsets of items to delete---this makes most sense for
     * bulk operations (deleteDirectory, restoreAll, purgeAll), but all
     * of the deletion-related operations accept a "filter" argument.
     *
     *
     * Stores/providers that support contentID-based access can also
     * allow file items to be deleted by specifying their contentID.
     *
     */
 
    procedure   deleteFile(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        soft_delete in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        if (path = '/') then
            raise dbms_dbfs_content.invalid_path;
        end if;
 
        if ((soft_delete &lt;&gt; 0)      or
            (filter is not null))   then
            raise dbms_dbfs_content.unsupported_operation;
        end if;
 
        delete from tbfs.tbfst t
            where ('/' || t.key) = path;
 
        if sql%rowcount &lt;&gt; 1 then
            raise dbms_dbfs_content.invalid_path;
        end if;
    end;
 
    procedure   deleteContent(
        store_name  in              varchar2,
        contentID   in              raw,
        filter      in              varchar2,
        soft_delete in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   deleteDirectory(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        soft_delete in              integer,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   restorePath(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   purgePath(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   restoreAll(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   purgeAll(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
 
 
    /*
     * DBFS SPI: path get/put operations.
     *
     * Existing path items can be accessed (for query or for update) and
     * modified via simple get/put methods.
     *
     * All pathnames allow their metadata (i.e. properties) to be
     * read/modified. On completion of the call, the client can request
     * (via "prop_flags") specific properties to be fetched as well.
     *
     * File pathnames allow their data (i.e. content) to be
     * read/modified. On completion of the call, the client can request
     * (via the "prop_data" bitmaks in "prop_flags") a new BLOB locator
     * that can be used to continue data access.
     *
     * Files can also be read/written without using BLOB locators, by
     * explicitly specifying logical offsets/buffer-amounts and a
     * suitably sized buffer.
     *
     *
     * Update accesses must specify the "forUpdate" flag. Access to link
     * pathnames can be implicitly and internally deferenced by stores
     * (subject to feature support) if the "deref" flag is
     * specified---however, this is dangerous since symbolic links are
     * not always resolvable.
     *
     *
     * The read methods (i.e. "getPath" where "forUpdate" is "false"
     * also accepts a valid "asof" timestamp parameter that can be used
     * by stores to implement "as of" style flashback queries. Mutating
     * versions of the "getPath" and the "putPath" methods do not
     * support as-of modes of operation.
     *
     *
     * "getPathNowait" implies a "forUpdate", and, if implemented (see
     * "feature_nowait"), allows providers to return an exception
     * (ORA-54) rather than wait for row locks.
     *
     */
 
    procedure   getPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     out    nocopy   blob,
        item_type   out             integer,
        prop_flags  in              integer,
        forUpdate   in              integer,
        deref       in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
        guid        number;
    begin
        if (deref &lt;&gt; 0) then
            raise dbms_dbfs_content.unsupported_operation;
        end if;
 
        select ora_hash(path) into guid from dual;
 
        if (path = '/') then
            if (forUpdate &lt;&gt; 0) then
                raise dbms_dbfs_content.unsupported_operation;
            end if;
 
            content    := null;
            item_type  := dbms_dbfs_content.type_directory;
            properties := dbms_dbfs_content_properties_t(
            dbms_dbfs_content_property_t(
                'std:guid',
                to_char(guid),
                dbms_types.TYPECODE_NUMBER));
 
            return;
        end if;
 
        begin
            if (forUpdate &lt;&gt; 0) then
                select t.data into content from tbfs.tbfst t
                    where ('/' || t.key) = path
                    for update;
            else
                select t.data into content from tbfs.tbfst t
                    where ('/' || t.key) = path;
            end if;
        exception
            when no_data_found then
                raise dbms_dbfs_content.invalid_path;
        end;
 
        item_type  := dbms_dbfs_content.type_file;
        properties := dbms_dbfs_content_properties_t(
            dbms_dbfs_content_property_t(
                'std:length',
                to_char(dbms_lob.getlength(content)),
                dbms_types.TYPECODE_NUMBER),
            dbms_dbfs_content_property_t(
                'std:guid',
                to_char(guid),
                dbms_types.TYPECODE_NUMBER));
    end;
 
    procedure   getPathNowait(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     out    nocopy   blob,
        item_type   out             integer,
        prop_flags  in              integer,
        deref       in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   getPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        amount      in out          number,
        offset      in              number,
        buffer      out    nocopy   raw,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
        content     blob;
        guid        number;
    begin
        if (path = '/') then
            raise dbms_dbfs_content.unsupported_operation;
        end if;
 
        begin
            select t.data into content from tbfs.tbfst t
                where ('/' || t.key) = path;
        exception
            when no_data_found then
                raise dbms_dbfs_content.invalid_path;
        end;
 
        select ora_hash(path) into guid from dual;
        dbms_lob.read(content, amount, offset, buffer);
 
        properties := dbms_dbfs_content_properties_t(
            dbms_dbfs_content_property_t(
                'std:length',
                to_char(dbms_lob.getlength(content)),
                dbms_types.TYPECODE_NUMBER),
            dbms_dbfs_content_property_t(
                'std:guid',
                to_char(guid),
                dbms_types.TYPECODE_NUMBER));
    end;
 
    procedure   getPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        amount      in out          number,
        offset      in              number,
        buffers     out    nocopy   dbms_dbfs_content_raw_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   putPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        content     in out nocopy   blob,
        item_type   out             integer,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
        guid        number;
    begin
        if (path = '/') then
            raise dbms_dbfs_content.unsupported_operation;
        end if;
 
        if content is null then
            content := empty_blob();
        end if;
 
        update tbfs.tbfst t
            set t.data = content
            where ('/' || t.key) = path
            returning t.data into content;
 
        if sql%rowcount &lt;&gt; 1 then
            raise dbms_dbfs_content.invalid_path;
        end if;
 
        select ora_hash(path) into guid from dual;
 
        item_type  := dbms_dbfs_content.type_file;
        properties := dbms_dbfs_content_properties_t(
            dbms_dbfs_content_property_t(
                'std:length',
                to_char(dbms_lob.getlength(content)),
                dbms_types.TYPECODE_NUMBER),
            dbms_dbfs_content_property_t(
                'std:guid',
                to_char(guid),
                dbms_types.TYPECODE_NUMBER));
    end;
 
    procedure   putPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        amount      in              number,
        offset      in              number,
        buffer      in              raw,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
        content     blob;
        guid        number;
    begin
        if (path = '/') then
            raise dbms_dbfs_content.unsupported_operation;
        end if;
 
        begin
            select t.data into content from tbfs.tbfst t
                where ('/' || t.key) = path
                for update;
        exception
            when no_data_found then
                raise dbms_dbfs_content.invalid_path;
        end;
 
        select ora_hash(path) into guid from dual;
        dbms_lob.write(content, amount, offset, buffer);
 
        properties := dbms_dbfs_content_properties_t(
            dbms_dbfs_content_property_t(
                'std:length',
                to_char(dbms_lob.getlength(content)),
                dbms_types.TYPECODE_NUMBER),
            dbms_dbfs_content_property_t(
                'std:guid',
                to_char(guid),
                dbms_types.TYPECODE_NUMBER));
    end;
 
    procedure   putPath(
        store_name  in              varchar2,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        written     out             number,
        offset      in              number,
        buffers     in              dbms_dbfs_content_raw_t,
        prop_flags  in              integer,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
 
 
    /*
     * DBFS SPI: rename/move operations.
     *
     * Pathnames can be renamed or moved, possibly across directory
     * hierarchies and mount-points, but within the same store.
     *
     *
     * Non-directory pathnames previously accessible via "oldPath" are
     * renamed as a single item subsequently accessible via "newPath";
     * assuming that "newPath" does not already exist.
     *
     * If "newPath" exists and is not a directory, the rename implicitly
     * deletes the existing item before renaming "oldPath". If "newPath"
     * exists and is a directory, "oldPath" is moved into the target
     * directory.
     *
     *
     * Directory pathnames previously accessible via "oldPath" are
     * renamed by moving the directory and all of its children to
     * "newPath" (if it does not already exist) or as children of
     * "newPath" (if it exists and is a directory).
     *
     *
     * Stores/providers that support contentID-based access and lazy
     * pathname binding also support the "setPath" method that
     * associates an existing "contentID" with a new "path".
     *
     */
 
    procedure   renamePath(
        store_name  in              varchar2,
        oldPath     in              varchar2,
        newPath     in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   setPath(
        store_name  in              varchar2,
        contentID   in              raw,
        path        in              varchar2,
        properties  in out nocopy   dbms_dbfs_content_properties_t,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
 
 
    /*
     * DBFS SPI: directory navigation and search.
     *
     * The DBFS API can list or search the contents of directory
     * pathnames, optionally recursing into sub-directories, optionally
     * seeing soft-deleted items, optionally using flashback "as of" a
     * provided timestamp, and optionally filtering items in/out within
     * the store based on list/search predicates.
     *
     */
 
    function    list(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t)
            return  dbms_dbfs_content_list_items_t
                pipelined
    is
    begin
        for rws in (select * from tbfs.tbfst)
        loop
            pipe row(dbms_dbfs_content_list_item_t(
                '/' || rws.key, rws.key, dbms_dbfs_content.type_file));
        end loop;
    end;
 
    function    search(
        store_name  in              varchar2,
        path        in              varchar2,
        filter      in              varchar2,
        recurse     in              integer,
        ctx         in              dbms_dbfs_content_context_t)
            return  dbms_dbfs_content_list_items_t
                pipelined
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
 
 
    /*
     * DBFS SPI: locking operations.
     *
     * Clients of the DBFS API can apply user-level locks to any valid
     * pathname (subject to store feature support), associate the lock
     * with user-data, and subsequently unlock these pathnames.
     *
     * The status of locked items is available via various optional
     * properties (see "opt_lock*" above).
     *
     *
     * It is the responsibility of the store (assuming it supports
     * user-defined lock checking) to ensure that lock/unlock operations
     * are performed in a consistent manner.
     *
     */
 
    procedure   lockPath(
        store_name  in              varchar2,
        path        in              varchar2,
        lock_type   in              integer,
        lock_data   in              varchar2,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
    procedure   unlockPath(
        store_name  in              varchar2,
        path        in              varchar2,
        ctx         in              dbms_dbfs_content_context_t)
    is
    begin
        raise dbms_dbfs_content.unsupported_operation;
    end;
 
 
 
    /*
     * DBFS SPI: access checks.
     *
     * Check if a given pathname (store_name, path, pathtype) can be
     * manipulated by "operation (see the various
     * "dbms_dbfs_content.op_xxx" opcodes) by "principal".
     *
     * This is a convenience function for the DBFS API; a store that
     * supports access control still internally performs these checks to
     * guarantee security.
     *
     */
 
    function    checkAccess(
        store_name  in              varchar2,
        path        in              varchar2,
        pathtype    in              integer,
        operation   in              varchar2,
        principal   in              varchar2)
            return  integer
    is
    begin
        return 1;
    end;
end;
/
show errors;</pre></div>
               </div><a id="ADLOB46236"></a><div class="props_rev_3"><a id="GUID-33C05C50-B474-47F8-AE49-242837A24D3F" name="GUID-33C05C50-B474-47F8-AE49-242837A24D3F"></a><h4 id="ADLOB-GUID-33C05C50-B474-47F8-AE49-242837A24D3F" class="sect4">capi.sql</h4>
                  <div>
                     <p><code class="codeph">capi.sql</code>脚本注册并安装DBFS。</p>
                     <p><code class="codeph">capi.sql</code>脚本：</p><pre class="oac_no_warn" dir="ltr">connect tbfs/tbfs;
 
exec dbms_dbfs_content.registerStore('MY_TBFS', 'table', 'TBFS');
exec dbms_dbfs_content.mountStore('MY_TBFS', singleton =&gt; true);
commit;</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>