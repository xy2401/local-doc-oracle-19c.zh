<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">
      <meta name="description" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">
      <title>PL / SQL包</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database PL/SQL Language Reference ">
      <meta property="og:description" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database PL/SQL Language Reference">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96448-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="plsql-triggers.html" title="Previous" type="text/html">
      <link rel="next" href="plsql-error-handling.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference">
    <meta name="dcterms.isVersionOf" content="LNPLS">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-triggers.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="plsql-error-handling.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL包</li>
            </ol>
            <a id="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" name="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0"></a><a id="LNPLS692"></a><a id="LNPLS009"></a>
            
            <h2 id="LNPLS-GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" class="sect2"><span class="enumeration_chapter">10个</span> PL / SQL包</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0__GUID-CA5BA22A-6C2D-4D9F-B5EE-32E5D9F30883">话题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="plsql-packages.html#GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" title="包是一个模式对象，它对逻辑上相关的PL / SQL类型，变量，常量，子程序，游标和异常进行分组。包被编译并存储在数据库中，其中许多应用程序可以共享其内容。">什么是套餐？</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5">使用包的原因</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-85E86008-3460-4596-B43A-13D54D6E04C7">包装规格</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750">包装体</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">包实例化和初始化</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" title="包声明的变量，常量和游标的值（在其规范或正文中）构成其包状态。">包装状态</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-001EF960-7491-411B-A5F3-D1260A45794B" title="对于SERIALLY_REUSABLE包，工作单元是服务器调用。">SERIALLY_REUSABLE包</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2">包装书写指南</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-3A313D35-26B6-4A0D-A128-231692BCBC97">包装示例</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF">STANDARD包如何定义PL / SQL环境</a></p>
                  </li>
               </ul>
            </div><a id="LNPLS00901"></a><div class="props_rev_3"><a id="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" name="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5"></a><h3 id="LNPLS-GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" class="sect3"><span class="enumeration_section">10.1</span>什么是套餐？
               </h3>
               <div>
                  <p><span class="bold">包</span>是一个模式对象，它对逻辑上相关的PL / SQL类型，变量，常量，子程序，游标和异常进行分组。包被编译并存储在数据库中，其中许多应用程序可以共享其内容。
                  </p>
                  <p>包始终具有<span class="bold">规范</span> ，该<span class="bold">规范</span>声明可以从包外引用的<span class="bold">公共项</span> 。
                  </p>
                  <p>如果公共项目包括游标或子程序，则包裹也必须具有<span class="bold">正文</span> 。正文必须定义公共游标的查询和公共子程序的代码。正文还可以声明和定义无法从包外引用的<span class="bold">私有项</span> ，但对于包的内部工作是必需的。最后，正文可以有一个<span class="bold">初始化部分</span> ，其语句初始化变量并执行其他一次性设置步骤，以及异常处理部分。您可以在不更改规范或公共项目引用的情况下更改正文;因此，您可以将包装体视为黑盒子。
                  </p>
                  <p>在包规范或包体中，可以使用<span class="bold">调用规范</span>将包子程序映射到外部Java或C子程序，该<span class="bold">规范</span>将外部子程序名称，参数类型和返回类型映射到它们的SQL副本。
                  </p>
                  <p>包规范的<span class="bold"><code class="codeph">AUTHID</code></span> <span class="bold">子句</span>确定包中的子程序和游标是否以其定义者（默认）或调用者的权限运行，以及它们是否在定义者或调用者的模式中解析了对模式对象的非限定引用。
                  </p>
                  <p>程序包规范的<span class="bold"><code class="codeph">ACCESSIBLE</code></span> <span class="bold"><code class="codeph">BY</code></span> <span class="bold">子句</span>允许您指定可以访问程序包的PL / SQL单元的白名单。您可以在以下情况中使用此子句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您将PL / SQL应用程序实现为多个包 - 一个包提供应用程序编程接口（API）和帮助程序包来完成工作。您希望客户端可以访问API，但不能访问帮助程序包。因此，您省略了API包规范中的<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句，并将其包含在每个帮助程序包规范中，您指定只有API包才能访问帮助程序包。
                        </p>
                     </li>
                     <li>
                        <p>您可以创建一个实用程序包，以便为同一模式中的某些（但不是所有）PL / SQL单元提供服务。要将程序包的使用限制在目标单元中，请在程序包规范中的<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句中列出它们。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5__GUID-AAFC67D5-018E-485D-9CE9-D5B557AFF22C">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="plsql-packages.html#GUID-85E86008-3460-4596-B43A-13D54D6E04C7">包规范</a> ”</span> ，了解有关包规范的更多信息</p>
                        </li>
                        <li>
                           <p> <span class="q">“ <a href="plsql-packages.html#GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750">包体</a> ”</span>有关包体的更多信息</p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="function-declaration-and-definition.html#GUID-4E19FB09-46B5-4CE5-8A5B-CD815C29DA1C" title="在调用函数之前，必须声明并定义它。您可以先声明它（使用function_declaration），然后在同一个块，子程序或包中（使用function_definition）定义它，或者同时声明和定义它（使用function_definition）。">功能声明和定义</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="procedure-declaration-and-definition.html#GUID-9A48D7CE-3720-46A4-B5CA-C2250CA86AF2" title="在调用过程之前，必须声明并定义它。您可以先声明它（使用procedure_declaration），然后在同一个块，子程序或包中使用procedure_definition定义它，或者同时声明和定义它（使用procedure_definition）。">程序声明和定义</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">祈求者的权利和定义者的权利（AUTHID财产）</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS00902"></a><div class="props_rev_3"><a id="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5" name="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5"></a><h3 id="LNPLS-GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5" class="sect3"><span class="enumeration_section">10.2</span>使用包裹的原因</h3>
               <div>
                  <p>软件包支持开发和维护可靠，可重用的代码，具有以下功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">模块化</span></p>
                        <p>通过包，您可以在命名的PL / SQL模块中封装逻辑上相关的类型，变量，常量，子程序，游标和异常。您可以使每个包易于理解，并使包之间的接口简单，清晰且定义良好。这种做法有助于应用程序开发。</p>
                     </li>
                     <li>
                        <p><span class="bold">更轻松的应用设计</span></p>
                        <p>在设计应用程序时，您最初需要的只是包规范中的接口信息。您可以在没有身体的情况下编写和编译规范。接下来，您可以编译引用包的独立子程序。在准备好完成应用程序之前，无需完全定义包体。</p>
                     </li>
                     <li>
                        <p><span class="bold">隐藏的实施细节</span></p>
                        <p>使用包可以在包规范中共享您的接口信息，并在包体中隐藏实现细节。隐藏实体细节有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以在不影响应用程序界面的情况下更改实施细节。</p>
                           </li>
                           <li>
                              <p>应用程序用户无法开发依赖于您可能想要更改的实现细节的代码。</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p><span class="bold">增加了功能</span></p>
                        <p>包公共变量和游标可以在会话的整个生命周期中持续存在。它们可以由在环境中运行的所有子程序共享。它们允许您跨事务维护数据，而无需将其存储在数据库中。（对于包公共变量和游标在会话期间不会持续存在的情况，请参阅<span class="q">“ <a href="plsql-packages.html#GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" title="包声明的变量，常量和游标的值（在其规范或正文中）构成其包状态。">包状态</a> ”</span> 。）
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">更好的性能</span></p>
                        <p>第一次调用包子程序时，Oracle数据库会将整个包加载到内存中。在包中同时调用其他子程序不需要磁盘I / O.</p>
                        <p>包防止级联依赖和不必要的重新编译。例如，如果更改包函数的主体，Oracle数据库不会重新编译调用该函数的其他子程序，因为这些子程序仅依赖于规范中声明的参数和返回值。</p>
                     </li>
                     <li>
                        <p><span class="bold">更容易授予角色</span></p>
                        <p>您可以在包上授予角色，而不是在包中的每个对象上授予角色。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5__GUID-57E93D66-5C59-410F-96B1-4726B9A4A9A3">
                     <p class="notep1">注意：</p>
                     <p>您无法从包内引用主变量。</p>
                  </div>
               </div>
            </div><a id="LNPLS694"></a><a id="LNPLS00904"></a><div class="props_rev_3"><a id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7" name="GUID-85E86008-3460-4596-B43A-13D54D6E04C7"></a><h3 id="LNPLS-GUID-85E86008-3460-4596-B43A-13D54D6E04C7" class="sect3"><span class="enumeration_section">10.3</span>包装规格</h3>
               <div>
                  <p><span class="bold">包规范</span>声明<span class="bold">公共项</span> 。公共项的范围是包的模式。公共项目在架构中的任何位置都可见。要引用范围但不可见的公共项目，请使用包名称对其进行限定。（有关范围，可见性和限定条件的信息，请参阅<span class="q">“ <a href="plsql-language-fundamentals.html#GUID-2FC17012-FC99-4614-90DD-ADC99F2EDBE9" title="标识符的范围是PL / SQL单元的区域，您可以从中引用标识符。标识符的可见性是PL / SQL单元的区域，您可以从中引用标识符而不限定它。标识符是声明它的PL / SQL单元的本地标识符。如果该单元具有子单元，则标识符对它们是全局的。">标识符的范围和可见性</a> ”</span> 。）
                  </p>
                  <p>每个公共项目声明都包含使用该项目所需的所有信息。例如，假设包规范以这种方式声明函数<code class="codeph">factorial</code> ：</p><pre class="oac_no_warn" dir="ltr">FUNCTION factorial (n INTEGER) RETURN INTEGER; -- returns n!
</pre><p>该声明显示<code class="codeph">factorial</code>需要类型的一个参数， <code class="codeph">INTEGER</code>和返回类型的值<code class="codeph">INTEGER</code> ，这是调用者必须知道要调用<code class="codeph">factorial</code> 。Invokers不需要知道如何实现<code class="codeph">factorial</code>因（例如，它是迭代的还是递归的）。
                  </p>
                  <div class="infoboxnote" id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7__GUID-DEEAEC15-6D37-4052-91AD-095C01B1BCF2">
                     <p class="notep1">注意：</p>
                     <p>要将程序包的使用限制为指定的PL / SQL单元，请在程序包规范中包含<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句。
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7__GUID-994130FA-079D-4358-9351-A66991E375FD">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-packages.html#GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D">适当的公共项目</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80">创建包规范</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS00911"></a><div class="props_rev_3"><a id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D" name="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D"></a><h4 id="LNPLS-GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D" class="sect4"><span class="enumeration_section">10.3.1</span>适当的公共项目</h4>
                  <div>
                     <p>适当的公共项目是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>多个子程序使用的类型，变量，常量，子程序，游标和异常</p>
                           <p>包规范中定义的类型是PL / SQL用户定义的子类型（在<span class="q">“ <a href="plsql-data-types.html#GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670" title="PL / SQL允许您定义自己的子类型。">用户定义的PL / SQL子类型</a> ”中描述</span> ）或PL / SQL复合类型（在<a href="plsql-collections-and-records.html#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL / SQL允许您定义两种复合数据类型：集合和记录。">PL / SQL集合和记录中描述</a> ）。
                           </p>
                           <div class="infoboxnote" id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D__GUID-1C153CA6-0861-4FDA-8A8F-07EC4E60C4DA">
                              <p class="notep1">注意：</p>
                              <p>程序包规范中定义的PL / SQL复合类型与相同定义的本地或独立类型不兼容（请参阅<a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">示例5-33</a> ， <a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CIHBGBBH">示例5-34</a>和<a href="plsql-collections-and-records.html#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHFBIAF">示例5-39</a> ）。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>独立子程序参数的关联数组类型</p>
                           <p>您无法在架构级别声明关联数组类型。因此，要将关联数组变量作为参数传递给独立子程序，必须在包规范中声明该变量的类型。这样做使得类型既可用于调用的子程序（声明该类型的形式参数），也可用于调用子程序或匿名块（声明该类型的变量）。见<a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">例10-2</a> 。
                           </p>
                        </li>
                        <li>
                           <p>在同一会话中的子程序调用之间必须保持可用的变量</p>
                        </li>
                        <li>
                           <p>读写公共变量的子程序（“get”和“set”子程序）</p>
                           <p>提供这些子程序以阻止程序包用户直接读取和写入公共变量。</p>
                        </li>
                        <li>
                           <p>相互调用的子程序</p>
                           <p>您无需担心包子程序的编译顺序，因为您必须对彼此调用的独立子程序进行编译。</p>
                        </li>
                        <li>
                           <p>重载的子程序</p>
                           <p>重载的子程序是同一子程序的变体。也就是说，它们具有相同的名称但不同的形式参数。有关它们的更多信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">重载的子程序</a> ”</span> 。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D__GUID-DCCE5C66-1170-4A4B-BB1B-97023EB7C547">
                        <p class="notep1">注意：</p>
                        <p>您不能间接引用远程包公共变量。例如，如果子程序引用包公共变量，则无法通过数据库链接调用子程序。</p>
                     </div>
                  </div>
               </div><a id="LNPLS813"></a><a id="LNPLS720"></a><a id="LNPLS99922"></a><div class="props_rev_3"><a id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80" name="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80"></a><h4 id="LNPLS-GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80" class="sect4"><span class="enumeration_section">10.3.2</span>创建包规范</h4>
                  <div>
                     <div class="section">
                        <p>要创建包规范，请使用<span class="q">“ <a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="CREATE PACKAGE语句创建或替换存储包的规范，存储包是数据库中作为一个单元存储的相关过程，函数和其他程序对象的封装集合。">CREATE PACKAGE语句</a> ”</span> 。
                        </p>
                        <p>由于<a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__CIHEJJHJ">示例10-1</a>和<a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">示例10-2中</a>的包规范未声明游标或子程序，因此包<code class="codeph">trans_data</code>和<code class="codeph">aa_pkg</code>不需要<code class="codeph">aa_pkg</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__CIHEJJHJ">
                        <p class="titleinexample">例10-1简单包规范</p>
                        <p>在此示例中，包<code class="codeph">trans_data</code>的规范声明了两个公共类型和三个公共变量。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE trans_data AUTHID DEFINER AS
  TYPE TimeRec IS RECORD (
    minutes SMALLINT,
    hours   SMALLINT);
  TYPE TransRec IS RECORD (
    category VARCHAR2(10),
    account  INT,
    amount   REAL,
    time_of  TimeRec);
  minimum_balance     CONSTANT REAL := 10.00;
  number_processed    INT;
  insufficient_funds  EXCEPTION;
  PRAGMA EXCEPTION_INIT(insufficient_funds, -4097);
END trans_data;
/
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">
                        <p class="titleinexample">示例10-2将关联数组传递给独立子程序</p>
                        <p>在此示例中，包<code class="codeph">aa_pkg</code>的规范声明了一个关联数组类型<code class="codeph">aa_type</code> 。然后，独立过程<code class="codeph">print_aa</code>声明类型为<code class="codeph">aa_type</code>的形式参数。接下来，匿名块声明<code class="codeph">aa_type</code>类型的变量，填充它，并将其传递给打印它的过程<code class="codeph">print_aa</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE <span class="bold">aa_pkg</span> AUTHID DEFINER IS
  TYPE <span class="bold">aa_type</span> IS TABLE OF INTEGER INDEX BY VARCHAR2(15);
END;
/
CREATE OR REPLACE PROCEDURE print_aa (
  <span class="bold">aa aa_pkg.aa_type</span>
) AUTHID DEFINER IS
  i  VARCHAR2(15);
BEGIN
  i := aa.FIRST;
 
  WHILE i IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE (aa(i) || '  ' || i);
    i := aa.NEXT(i);
  END LOOP;
END;
/
DECLARE
  <span class="bold">aa_var  aa_pkg.aa_type</span>;
BEGIN
  aa_var('zero') := 0;
  aa_var('one') := 1;
  aa_var('two') := 2;
  <span class="bold">print_aa(aa_var)</span>;
END;
/
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">1  one
2  two
0  zero
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS721"></a><a id="LNPLS00905"></a><div class="props_rev_3"><a id="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750" name="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750"></a><h3 id="LNPLS-GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750" class="sect3"><span class="enumeration_section">10.4</span>包装体</h3>
               <div>
                  <p>如果包规范声明游标或子程序，则需要包体;否则，它是可选的。包体和包规范必须位于同一模式中。</p>
                  <p>包规范中的每个游标或子程序声明都必须在包体中具有相应的定义。相应的子程序声明和定义的标题必须逐字逐句匹配，白色空间除外。</p>
                  <p>要创建包体，请使用<span class="q">“ <a href="CREATE-PACKAGE-BODY-statement.html#GUID-68526FF2-96A1-4F14-A10B-4DD3E1CD80BE" title="CREATE PACKAGE BODY语句创建或替换存储包的主体，该包是相关过程，存储函数和作为单元存储在数据库中的其他程序对象的封装集合。">CREATE PACKAGE BODY Statement</a> ”</span> 。
                  </p>
                  <p>在包规范中声明并在包体中定义的游标和子程序是可以从包外引用的公共项。包体还可以声明和定义无法从包外引用的<span class="bold">私有项</span> ，但是包的内部工作是必需的。
                  </p>
                  <p>最后，正文可以有一个<span class="bold">初始化部分</span> ，其语句初始化公共变量并执行其他一次性设置步骤。初始化部分仅在第一次引用包时运行。初始化部分可以包括异常处理程序。
                  </p>
                  <p>您可以更改包体，而无需更改规范或对公共项的引用。</p>
                  <div class="example" id="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750__CJAGEFEB">
                     <p class="titleinexample">例10-3匹配包规范和主体</p>
                     <p>在此示例中，相应子程序声明和定义的标题不一致地逐字匹配;因此，即使<code class="codeph">employees.hire_date%TYPE</code>为<code class="codeph">DATE</code> ，PL / SQL也会引发异常。</p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE emp_bonus AS
  PROCEDURE calc_bonus (date_hired <span class="bold">employees.hire_date%TYPE</span>);
END emp_bonus;
/
CREATE PACKAGE BODY emp_bonus AS
  -- DATE does not match employees.hire_date%TYPE
  PROCEDURE calc_bonus (date_hired <span class="bold">DATE</span>) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE
      ('Employees hired on ' || date_hired || ' get bonus.');
  END;
END emp_bonus;
/
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Warning: Package Body created with compilation errors.
</pre><p>显示错误（在SQL * Plus中）：</p><pre class="oac_no_warn" dir="ltr">SHOW ERRORS
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Errors for PACKAGE BODY EMP_BONUS:
 
LINE/COL ERROR
-------- -----------------------------------------------------------------
2/13     PLS-00323: subprogram or cursor 'CALC_BONUS' is declared in a
         package specification and must be defined in the package body
</pre><p>纠正问题：</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE BODY emp_bonus AS
  PROCEDURE calc_bonus
    (<span class="bold">date_hired employees.hire_date%TYPE</span>) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE
      ('Employees hired on ' || date_hired || ' get bonus.');
  END;
END emp_bonus;
/
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Package body created.
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS99926"></a><div class="props_rev_3"><a id="GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A" name="GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A"></a><h3 id="LNPLS-GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A" class="sect3"><span class="enumeration_section">10.5</span>包实例化和初始化</h3>
               <div>
                  <p>当会话引用包项时，Oracle数据库会为该会话实例化包。引用包的每个会话都有自己的包的实例化。</p>
                  <p>当Oracle数据库实例化一个包时，它会初始化它。初始化包括以下适用的任何一项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>将初始值分配给公共常量</p>
                     </li>
                     <li>
                        <p>将初始值分配给声明指定它们的公共变量</p>
                     </li>
                     <li>
                        <p>执行包体的初始化部分</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS804"></a><div class="props_rev_3"><a id="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" name="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4"></a><h3 id="LNPLS-GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" class="sect3"><span class="enumeration_section">10.6</span>包装状态</h3>
               <div>
                  <p>包声明的变量，常量和游标的值（在其规范或正文中）构成其<strong class="term">包状态</strong> 。
                  </p>
                  <p>如果PL / SQL包声明至少一个变量，常量或游标，那么包是<span class="bold">有状态的</span> ;否则，它是<span class="bold">无国籍的</span> 。
                  </p>
                  <p>引用包项的每个会话都有自己的包的实例化。如果包是有状态的，则实例化包括其状态。</p>
                  <p>包状态在会话期间持续存在，除非在以下情况中：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>包是<code class="codeph">SERIALLY_REUSABLE</code> 。</p>
                     </li>
                     <li>
                        <p>包体重新编译。</p>
                        <p>如果重新编译实例化的有状态包的主体（显式地，使用<span class="q">“ <a href="ALTER-PACKAGE-statement.html#GUID-61273667-8D8F-4E79-9D81-072CFFE3A7F1" title="ALTER PACKAGE语句显式重新编译包规范，正文或两者。显式重新编译消除了对隐式运行时重新编译的需要，并防止了相关的运行时编译错误和性能开销。">ALTER PACKAGE语句</a> ”</span>或隐式），则下一次调用包中的子程序会导致Oracle数据库丢弃现有包状态并引发异常ORA -04068。
                        </p>
                        <p>在PL / SQL引发异常之后，对包的引用会导致Oracle数据库重新实例化该包，并重新初始化它。因此，先前对包状态的更改将丢失。</p>
                     </li>
                     <li>
                        <p>任何会话的实例化包都将失效并重新生效。</p>
                        <p>如果任何会话的实例化包被无效并重新生效，则会丢失所有会话的包实例化（包括包状态）。</p>
                     </li>
                  </ul>
                  <p>如果程序包的状态在会话期间（或更长时间）保持不变，则Oracle数据库会将程序包视为无状态。这是一个包的项，它的所有项都是编译时常量。</p>
                  <p><span class="bold">编译时常量</span>是一个常量，PL / SQL编译器可以在编译时确定该值。初始值为文字的常量始终为编译时常量。一个常量，其初始值不是文字，但优化器减少为文字，也是编译时常量。PL / SQL优化器是否可以将非文字表达式减少为文字取决于优化级别。因此，在一个优化级别编译时无状态的程序包在以不同的优化级别编译时可能是有状态的。
                  </p>
                  <div class="infoboxnotealso" id="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4__GUID-27A37E69-47C5-41AA-98F7-3D2045845476">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="plsql-packages.html#GUID-001EF960-7491-411B-A5F3-D1260A45794B" title="对于SERIALLY_REUSABLE包，工作单元是服务器调用。">SERIALLY_REUSABLE包</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">包实例化和初始化</a> ”</span>有关初始化的信息</p>
                        </li>
                        <li>
                           <p>有关架构对象失效和重新验证的信息，请参见<a href="../adfns/schema-object-dependency.html#ADFNS99967" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a></p>
                        </li>
                        <li>
                           <p>有关优化程序的信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" title="编译器可以执行的一个优化是子程序内联。">PL / SQL Optimizer</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS722"></a><a id="LNPLS99977"></a><div class="props_rev_3"><a id="GUID-001EF960-7491-411B-A5F3-D1260A45794B" name="GUID-001EF960-7491-411B-A5F3-D1260A45794B"></a><h3 id="LNPLS-GUID-001EF960-7491-411B-A5F3-D1260A45794B" class="sect3"><span class="enumeration_section">10.7</span> SERIALLY_REUSABLE包</h3>
               <div>
                  <p><code class="codeph">SERIALLY_REUSABLE</code>包使您可以设计更好地管理内存的应用程序以实现可伸缩性。
                  </p>
                  <p>如果包不是<code class="codeph">SERIALLY_REUSABLE</code> ，则其包状态存储在每个用户的用户全局区域（UGA）中。因此，所需的UGA存储量随着用户数量的增加而线性增加，从而限制了可扩展性。包状态可以持续一段时间，锁定UGA内存直到会话结束。在某些应用程序（如Oracle Office）中，典型会话持续数天。
                  </p>
                  <p>如果包是<code class="codeph">SERIALLY_REUSABLE</code> ，则其包状态存储在系统全局区域（SGA）中的小池中的工作区中。程序包状态仅在服务器调用的生命周期内持续存在。服务器调用后，工作区返回池。如果后续服务器调用引用该包，则Oracle数据库将重用池中的实例。重用实例化会重新初始化它;因此，在先前的服务器调用中对包状态所做的更改是不可见的。（有关初始化的信息，请参阅<span class="q">“ <a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">包实例化和初始化</a> ”</span> 。）
                  </p>
                  <div class="infoboxnote" id="GUID-001EF960-7491-411B-A5F3-D1260A45794B__GUID-8AA9A74C-FD0E-4762-92C0-56557D80C81A">
                     <p class="notep1">注意：</p>
                     <p>尝试从数据库触发器或SQL语句调用的PL / SQL子程序访问<code class="codeph">SERIALLY_REUSABLE</code>包会引发错误。
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-001EF960-7491-411B-A5F3-D1260A45794B__GUID-3F0B0AE1-BEE9-4931-95B6-42397FC196CA">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-packages.html#GUID-78DA1333-7938-472E-9A67-37C50370AB69">创建SERIALLY_REUSABLE包</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-0881061B-1F72-4F13-8BBA-B0959199851B" title="对于SERIALLY_REUSABLE包，工作单元是服务器调用。">SERIALLY_REUSABLE包装工作单位</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19">SERIALLY_REUSABLE包中的显式游标</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS810"></a><a id="LNPLS99925"></a><div class="props_rev_3"><a id="GUID-78DA1333-7938-472E-9A67-37C50370AB69" name="GUID-78DA1333-7938-472E-9A67-37C50370AB69"></a><h4 id="LNPLS-GUID-78DA1333-7938-472E-9A67-37C50370AB69" class="sect4"><span class="enumeration_section">10.7.1</span>创建SERIALLY_REUSABLE包</h4>
                  <div>
                     <div class="section">
                        <p>要创建<code class="codeph">SERIALLY_REUSABLE</code>包，请在包规范中包含<code class="codeph">SERIALLY_REUSABLE</code> pragma，如果存在，则包括包体。
                        </p>
                        <p><a href="plsql-packages.html#GUID-78DA1333-7938-472E-9A67-37C50370AB69__BABBIBDC">例10-4</a>创建了两个非常简单的<code class="codeph">SERIALLY_REUSABLE</code>包，一个只有一个规范，另一个包含规范和主体。
                        </p>
                        <div class="infoboxnotealso" id="GUID-78DA1333-7938-472E-9A67-37C50370AB69__GUID-E8D82F0C-DEFA-41DF-800D-524D392C7F3C">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="SERIALLY_REUSABLE-pragma.html#GUID-35B02603-B794-403C-9E0D-E40208CEAF35" title="SERIALLY_REUSABLE pragma指定仅对服务器的一次调用需要包状态（例如，对数据库的OCI调用或通过数据库链接的存储过程调用）。">SERIALLY_REUSABLE Pragma</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-78DA1333-7938-472E-9A67-37C50370AB69__BABBIBDC">
                        <p class="titleinexample">示例10-4创建SERIALLY_REUSABLE包</p><pre class="oac_no_warn" dir="ltr"><span class="bold">-- Create bodiless SERIALLY_REUSABLE package:</span>
 
CREATE OR REPLACE PACKAGE bodiless_pkg AUTHID DEFINER IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END;
/
 
<span class="bold">-- Create SERIALLY_REUSABLE package with specification and body:</span>
 
CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END;
/
 
CREATE OR REPLACE PACKAGE BODY pkg IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
BEGIN
  n := 5;
END;
/</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS809"></a><a id="LNPLS99924"></a><div class="props_rev_3"><a id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B" name="GUID-0881061B-1F72-4F13-8BBA-B0959199851B"></a><h4 id="LNPLS-GUID-0881061B-1F72-4F13-8BBA-B0959199851B" class="sect4"><span class="enumeration_section">10.7.2</span> SERIALLY_REUSABLE包装工作单位</h4>
                  <div>
                     <p>对于<code class="codeph">SERIALLY_REUSABLE</code>包，工作单元是服务器调用。
                     </p>
                     <p>您必须仅在工作单元中使用其公共变量。</p>
                     <div class="infoboxnote" id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B__GUID-57B4ECE9-9259-4880-A05C-C8E8E0E9532F">
                        <p class="notep1">注意：</p>
                        <p>如果您犯了错误并依赖于在先前工作单元中设置的公共变量的值，那么您的程序可能会失败。PL / SQL无法检查此类情况。</p>
                     </div>
                     <p>在<code class="codeph">SERIALLY_REUSABLE</code>包的工作单元（服务器调用）完成后，Oracle数据库执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>关闭所有打开的游标。</p>
                        </li>
                        <li>
                           <p>释放一些不可重用的内存（例如，内存用于收集和长<code class="codeph">VARCHAR2</code>变量）</p>
                        </li>
                        <li>
                           <p>将包实例化返回到为此包保留的可重用实例化池。</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B__BABFAFDC">
                        <p class="titleinexample">例10-5 SERIALLY_REUSABLE Pragma的影响</p>
                        <p>在这个例子中，脱胎包<code class="codeph">pkg</code>和<code class="codeph">sr_pkg</code>是相同的，除了<code class="codeph">sr_pkg</code>是<code class="codeph">SERIALLY_REUSABLE</code>而<code class="codeph">pkg</code>不是。每个包声明公共变量<code class="codeph">n</code> ，初始值为5。然后，匿名块将每个变量的值更改为10。接下来，另一个匿名块打印每个变量的值。<code class="codeph">pkg</code>的值。 <code class="codeph">n</code>仍然是10，因为<code class="codeph">pkg</code>的状态在会话期间持续存在。<code class="codeph">sr_pkg</code>的值。 <code class="codeph">n</code>为5，因为<code class="codeph">sr_pkg</code>的状态仅在服务器调用的生命<code class="codeph">sr_pkg</code>持续存在。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE <span class="bold">PACKAGE pkg</span> IS
  n NUMBER := 5;
END pkg;
/

CREATE OR REPLACE <span class="bold">PACKAGE sr_pkg</span> IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END sr_pkg;
/

BEGIN
  pkg.n := 10;
  sr_pkg.n := 10;
END;
/

BEGIN
  DBMS_OUTPUT.PUT_LINE('pkg.n: ' || pkg.n);
  DBMS_OUTPUT.PUT_LINE('sr_pkg.n: ' || sr_pkg.n);
END;
/
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">pkg.n: 10</span>
<span class="bold">sr_pkg.n: 5</span>
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS811"></a><a id="LNPLS99923"></a><div class="props_rev_3"><a id="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19" name="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19"></a><h4 id="LNPLS-GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19" class="sect4"><span class="enumeration_section">10.7.3</span> SERIALLY_REUSABLE包中的显式游标</h4>
                  <div>
                     <p><code class="codeph">SERIALLY_REUSABLE</code>程序包中的显式游标保持打开状态，直到您关闭它或其工作单元（服务器调用）结束。要重新打开游标，您必须进行新的服务器调用。服务器调用可以与子程序调用不同，如<a href="plsql-packages.html#GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19__BABHACDC">例10-6</a>所示。
                     </p>
                     <p>相反，在您关闭它或断开与会话的连接之前，包中的非<code class="codeph">SERIALLY_REUSABLE</code>的显式游标将保持打开状态。
                     </p>
                     <div class="example" id="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19__BABHACDC">
                        <p class="titleinexample">例10-6 SERIALLY_REUSABLE包中的游标在Call Boundary打开</p><pre class="oac_no_warn" dir="ltr">DROP TABLE people;
CREATE TABLE people (name VARCHAR2(20));
 
INSERT INTO people (name) VALUES ('John Smith');
INSERT INTO people (name) VALUES ('Mary Jones');
INSERT INTO people (name) VALUES ('Joe Brown');
INSERT INTO people (name) VALUES ('Jane White');

CREATE OR REPLACE <span class="bold">PACKAGE sr_pkg</span> IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  <span class="bold">CURSOR c</span> IS SELECT name FROM people;
END sr_pkg;
/
 
CREATE OR REPLACE PROCEDURE fetch_from_cursor IS
  v_name  people.name%TYPE;
BEGIN
  IF sr_pkg.c%ISOPEN THEN
    DBMS_OUTPUT.PUT_LINE('Cursor is open.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Cursor is closed; opening now.');
    OPEN sr_pkg.c;
  END IF;
 
  FETCH sr_pkg.c INTO v_name;
  DBMS_OUTPUT.PUT_LINE('Fetched: ' || v_name);
 
  FETCH sr_pkg.c INTO v_name;
    DBMS_OUTPUT.PUT_LINE('Fetched: ' || v_name);
  END fetch_from_cursor;
/
 </pre><p>首先调用服务器：</p><pre class="oac_no_warn" dir="ltr">BEGIN
  fetch_from_cursor;
  fetch_from_cursor;
END;
/
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Cursor is closed; opening now.</span>
Fetched: John Smith
Fetched: Mary Jones
<span class="bold">Cursor is open.</span>
Fetched: Joe Brown
Fetched: Jane White
 </pre><p>对服务器的新调用：</p><pre class="oac_no_warn" dir="ltr">BEGIN
  fetch_from_cursor;
  fetch_from_cursor;
END;
/
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Cursor is closed; opening now.</span>
Fetched: John Smith
Fetched: Mary Jones
<span class="bold">Cursor is open.</span>
Fetched: Joe Brown
Fetched: Jane White</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS826"></a><a id="LNPLS1996"></a><a id="LNPLS00909"></a><div class="props_rev_3"><a id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2" name="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2"></a><h3 id="LNPLS-GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2" class="sect3"><span class="enumeration_section">10.8</span>包装书写指南</h3>
               <div>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>熟悉Oracle数据库提供的软件包，避免编写复制其功能的软件包。</p>
                        <p>有关Oracle数据库提供的软件包的更多信息，请参阅<a href="../arpls/introduction-to-oracle-supplied-plsql-packages-and-types.html#ARPLS-GUID-4AA6AA30-CAEE-4DCD-B214-9AD51D0229B4" target="_blank"><span class="italic">Oracle Database PL / SQL软件包和类型参考</span></a> 。
                        </p>
                     </li>
                     <li>
                        <p>保持您的包一般，以便将来的应用程序可以重用它们。</p>
                     </li>
                     <li>
                        <p>在包体之前设计和定义包规范。</p>
                     </li>
                     <li>
                        <p>在包规范中，仅声明调用程序必须可见的项。</p>
                        <p>这种做法可以防止其他开发人员对您的实现细节构建不安全的依赖关系，并减少重新编译的需要。</p>
                        <p>如果更改包规范，则必须重新编译调用包的公共子程序的任何子程序。如果仅更改包体，则无需重新编译这些子程序。</p>
                     </li>
                     <li>
                        <p>在包规范中声明公共游标并在包体中定义它们，如<a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">例10-7所示</a> 。
                        </p>
                        <p>此练习允许您从包用户隐藏游标的查询，并在不更改游标声明的情况下更改它们。</p>
                     </li>
                     <li>
                        <p>在包体的初始化部分而不是在声明中分配初始值。</p>
                        <p>这种做法具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用于计算初始值的代码可以更复杂并且更好地记录。</p>
                           </li>
                           <li>
                              <p>如果计算初始值会引发异常，则初始化部分可以使用自己的异常处理程序来处理它。</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>如果将数据库应用程序实现为多个PL / SQL包 - 一个提供API和帮助程序包的包来完成工作，那么使帮助程序包仅可用于API包，如<a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">例10-8所示</a> 。
                        </p>
                     </li>
                  </ul>
                  <p>在<a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">例10-7中</a> ，光标<code class="codeph">c1</code>的声明和定义分别在包<code class="codeph">emp_stuff</code>的规范和正文中。游标声明仅指定返回值的数据类型，而不是查询，它出现在游标定义中（有关完整语法和语义，请参阅<span class="q">“ <a href="explicit-cursor-declaration-and-definition.html#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="显式游标是指向私有SQL区域的命名指针，该区域存储用于处理特定查询或DML语句的信息 - 通常是返回或影响多行的语句。">显式游标声明和定义</a> ”</span> ）。
                  </p>
                  <p><a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">例10-8</a>创建了一个API包和一个帮助包。由于帮助程序包规范中的<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句，只有API包可以访问帮助程序包。
                  </p>
                  <div class="example" id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">
                     <p class="titleinexample">例10-7在包中分离游标声明和定义</p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE emp_stuff AS
  <span class="bold">CURSOR c1 RETURN employees%ROWTYPE;  -- Declare cursor</span>
END emp_stuff;
/
CREATE PACKAGE BODY emp_stuff AS
  <span class="bold">CURSOR c1 RETURN employees%ROWTYPE IS</span>
    <span class="bold">SELECT * FROM employees WHERE salary &gt; 2500;  -- Define cursor</span>
END emp_stuff;
/
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">
                     <p class="titleinexample">例10-8可以通过条款访问</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE helper
  AUTHID DEFINER
  <span class="bold">ACCESSIBLE BY (api)</span>
IS
  PROCEDURE h1;
  PROCEDURE h2;
END;
/
 
CREATE OR REPLACE PACKAGE BODY helper
IS
  PROCEDURE h1 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Helper procedure h1');
  END;
 
  PROCEDURE h2 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Helper procedure h2');
  END;
END;
/
 
CREATE OR REPLACE PACKAGE api
  AUTHID DEFINER
IS
  PROCEDURE p1;
  PROCEDURE p2;
END;
/
 
CREATE OR REPLACE PACKAGE BODY api
IS
  PROCEDURE p1 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('API procedure p1');
    helper.h1;
  END;
 
  PROCEDURE p2 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('API procedure p2');
    helper.h2;
  END;
END;
/
 </pre><p>调用API包中的过程：</p><pre class="oac_no_warn" dir="ltr">BEGIN
  api.p1;
  api.p2;
END;
/
 </pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">API procedure p1
Helper procedure h1
API procedure p2
Helper procedure h2
</pre><p>在helper包中调用一个过程：</p><pre class="oac_no_warn" dir="ltr">BEGIN
  helper.h1;
END;
/
 </pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; BEGIN
  2    helper.h1;
  3  END;
  4  /
  helper.h1;
  *
ERROR at line 2:
ORA-06550: line 2, column 3:
<span class="bold">PLS-00904: insufficient privilege to access object HELPER</span>
ORA-06550: line 2, column 3:
PL/SQL: Statement ignored</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS816"></a><a id="LNPLS00906"></a><div class="props_rev_3"><a id="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97" name="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97"></a><h3 id="LNPLS-GUID-3A313D35-26B6-4A0D-A128-231692BCBC97" class="sect3"><span class="enumeration_section">10.9</span>包装示例</h3>
               <div>
                  <p><a href="plsql-packages.html#GUID-3A313D35-26B6-4A0D-A128-231692BCBC97__CJAIICFE">示例10-9</a>创建表， <code class="codeph">log</code>和包<code class="codeph">emp_admin</code> ，然后从匿名块调用包子程序。包装有规格和正文。
                  </p>
                  <p>规范声明了一个公共类型，游标和异常，以及三个公共子程序。一个公共子程序过载（有关重载子程序的信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">重载的子程序</a> ”</span> ）。
                  </p>
                  <p>正文声明了一个私有变量，定义了规范声明的公共游标和子程序，声明并定义了私有函数，并具有初始化部分。</p>
                  <p>初始化部分（仅在匿名块第一次引用包时运行）在表<code class="codeph">log</code>插入一行，并将私有变量<code class="codeph">number_hired</code>初始化为零。每次调用包过程<code class="codeph">hire_employee</code> ，它都会更新私有变量<code class="codeph">number_hired</code> 。
                  </p>
                  <div class="example" id="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97__CJAIICFE">
                     <p class="titleinexample">示例10-9创建emp_admin包</p><pre class="oac_no_warn" dir="ltr"><span class="bold">-- Log to track changes (not part of package):</span>

DROP TABLE log;
CREATE TABLE log (
  date_of_action  DATE,
  user_id         VARCHAR2(20),
  package_name    VARCHAR2(30)
);

<span class="bold">-- Package specification:</span>

CREATE OR REPLACE PACKAGE emp_admin AUTHID DEFINER AS
  <span class="bold">-- Declare public type, cursor, and exception:</span>
  TYPE EmpRecTyp IS RECORD (emp_id NUMBER, sal NUMBER);
  CURSOR desc_salary RETURN EmpRecTyp;
  invalid_salary EXCEPTION;

  <span class="bold">-- Declare public subprograms:</span>

  FUNCTION hire_employee (
    last_name       VARCHAR2,
    first_name      VARCHAR2,
    email           VARCHAR2,
    phone_number    VARCHAR2,
    job_id          VARCHAR2,
    salary          NUMBER,
    commission_pct  NUMBER,
    manager_id      NUMBER,
    department_id   NUMBER
  ) RETURN NUMBER;

  <span class="bold">-- Overload preceding public subprogram:</span>
  PROCEDURE fire_employee (emp_id NUMBER);
  PROCEDURE fire_employee (emp_email VARCHAR2);

  PROCEDURE raise_salary (emp_id NUMBER, amount NUMBER);
  FUNCTION nth_highest_salary (n NUMBER) RETURN EmpRecTyp;
END emp_admin;
/
<span class="bold">-- Package body:</span>

CREATE OR REPLACE PACKAGE BODY emp_admin AS
  number_hired  NUMBER;  <span class="bold">-- private variable, visible only in this package</span>

  <span class="bold">-- Define cursor declared in package specification:</span>

  CURSOR desc_salary RETURN EmpRecTyp IS
    SELECT employee_id, salary
    FROM employees
    ORDER BY salary DESC;

  <span class="bold">-- Define subprograms declared in package specification:</span>

  FUNCTION hire_employee (
    last_name       VARCHAR2,
    first_name      VARCHAR2,
    email           VARCHAR2,
    phone_number    VARCHAR2,
    job_id          VARCHAR2,
    salary          NUMBER,
    commission_pct  NUMBER,
    manager_id      NUMBER,
    department_id   NUMBER
  ) RETURN NUMBER
  IS
    new_emp_id NUMBER;
  BEGIN
    new_emp_id := employees_seq.NEXTVAL;
    INSERT INTO employees (
      employee_id,
      last_name,
      first_name,
      email,
      phone_number,
      hire_date,
      job_id,
      salary,
      commission_pct,
      manager_id,
      department_id
    )
    VALUES (
      new_emp_id,
      hire_employee.last_name,
      hire_employee.first_name,
      hire_employee.email,
      hire_employee.phone_number,
      SYSDATE,
      hire_employee.job_id,
      hire_employee.salary,
      hire_employee.commission_pct,
      hire_employee.manager_id,
      hire_employee.department_id
    );
    number_hired := number_hired + 1;
    DBMS_OUTPUT.PUT_LINE('The number of employees hired is ' 
                         || TO_CHAR(number_hired) );   
    RETURN new_emp_id;
  END hire_employee;

  PROCEDURE fire_employee (emp_id NUMBER) IS
  BEGIN
    DELETE FROM employees WHERE employee_id = emp_id;
  END fire_employee;

  PROCEDURE fire_employee (emp_email VARCHAR2) IS
  BEGIN
    DELETE FROM employees WHERE email = emp_email;
  END fire_employee;

  <span class="bold">-- Define private function, available only inside package:</span>

  FUNCTION sal_ok (
    jobid VARCHAR2,
    sal NUMBER
  ) RETURN BOOLEAN
  IS
    min_sal NUMBER;
    max_sal NUMBER;
  BEGIN
    SELECT MIN(salary), MAX(salary)
    INTO min_sal, max_sal
    FROM employees
    WHERE job_id = jobid;

    RETURN (sal &gt;= min_sal) AND (sal &lt;= max_sal);
  END sal_ok;

  PROCEDURE raise_salary (
    emp_id NUMBER,
    amount NUMBER
  )
  IS
    sal NUMBER(8,2);
    jobid VARCHAR2(10);
  BEGIN
    SELECT job_id, salary INTO jobid, sal
    FROM employees
    WHERE employee_id = emp_id;

    IF <span class="bold">sal_ok(jobid, sal + amount)</span> THEN  <span class="bold">-- Invoke private function</span>
      UPDATE employees
      SET salary = salary + amount
      WHERE employee_id = emp_id;
    ELSE
      RAISE invalid_salary;
    END IF;
  EXCEPTION
    WHEN invalid_salary THEN
      DBMS_OUTPUT.PUT_LINE ('The salary is out of the specified range.');
  END raise_salary;

  FUNCTION nth_highest_salary (
    n NUMBER
  ) RETURN EmpRecTyp
  IS
    emp_rec  EmpRecTyp;
  BEGIN
    OPEN desc_salary;
    FOR i IN 1..n LOOP
      FETCH desc_salary INTO emp_rec;
    END LOOP;
    CLOSE desc_salary;
    RETURN emp_rec;
  END nth_highest_salary;

BEGIN  <span class="bold">-- initialization part of package body</span>
   INSERT INTO log (date_of_action, user_id, package_name)
   VALUES (SYSDATE, USER, 'EMP_ADMIN');
   number_hired := 0;
END emp_admin;
/
<span class="bold">-- Invoke packages subprograms in anonymous block:</span>

DECLARE
  new_emp_id NUMBER(6);
BEGIN
  new_emp_id := <span class="bold">emp_admin.hire_employee</span> (
    'Belden',
    'Enrique',
    'EBELDEN',
    '555.111.2222',
    'ST_CLERK',
    2500,
    .1,
    101,
    110
  );
  DBMS_OUTPUT.PUT_LINE ('The employee id is ' || TO_CHAR(new_emp_id));
  <span class="bold">emp_admin.raise_salary</span> (new_emp_id, 100);

  DBMS_OUTPUT.PUT_LINE (
    'The 10th highest salary is '||
    TO_CHAR (<span class="bold">emp_admin.nth_highest_salary(10).sal</span>) ||
             ', belonging to employee: ' ||
             TO_CHAR (<span class="bold">emp_admin.nth_highest_salary(10).emp_id</span>)
  );

  <span class="bold">emp_admin.fire_employee(new_emp_id)</span>;
  -- You can also delete the newly added employee as follows:
  -- <span class="bold">emp_admin.fire_employee('EBELDEN')</span>;
END;
/
</pre><p>结果类似于：</p><pre class="oac_no_warn" dir="ltr">The number of employees hired is 1
The employee id is 210
The 10th highest salary is 11500, belonging to employee: 168</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS00907"></a><div class="props_rev_3"><a id="GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF" name="GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF"></a><h3 id="LNPLS-GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF" class="sect3"><span class="enumeration_section">10.10</span> STANDARD包如何定义PL / SQL环境</h3>
               <div>
                  <p>名为<code class="codeph">STANDARD</code>的包定义了PL / SQL环境。包规范声明公共类型，变量，异常，子程序，它们可自动提供给PL / SQL程序。例如，包<code class="codeph">STANDARD</code>声明函数<code class="codeph">ABS</code> ，它返回其参数的绝对值，如下所示：</p><pre class="oac_no_warn" dir="ltr">FUNCTION ABS (n NUMBER) RETURN NUMBER;
</pre><p>程序包<code class="codeph">STANDARD</code>的内容对应用程序直接可见。您不需要通过为包名称添加前缀来限定对其内容的引用。例如，您可以从数据库触发器，存储的子程序，Oracle工具或3GL应用程序中调用<code class="codeph">ABS</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">abs_diff := ABS(x - y);
</pre><p>如果您声明自己的<code class="codeph">ABS</code>版本，则您的本地声明会覆盖公共声明。您仍然可以通过指定其全名来调用SQL函数：</p><pre class="oac_no_warn" dir="ltr">abs_diff := STANDARD.ABS(x - y);
</pre><p>大多数SQL函数都是重载的。例如，包<code class="codeph">STANDARD</code>包含以下声明：</p><pre class="oac_no_warn" dir="ltr">FUNCTION TO_CHAR (right DATE) RETURN VARCHAR2;
FUNCTION TO_CHAR (left NUMBER) RETURN VARCHAR2;
FUNCTION TO_CHAR (left DATE, right VARCHAR2) RETURN VARCHAR2;
FUNCTION TO_CHAR (left NUMBER, right VARCHAR2) RETURN VARCHAR2;
</pre><p>PL / SQL通过匹配形式和实际参数的数量和数据类型来解析<code class="codeph">TO_CHAR</code>的调用。
                  </p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>