<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>C ++应用程序</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer&#39;s Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer&#39;s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96467-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="applications.html" title="Previous" type="text/html">
      <link rel="next" href="Oracle-dynamic-SQL.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide">
    <meta name="dcterms.isVersionOf" content="LNPCC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="applications.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Oracle-dynamic-SQL.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name">应用</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">C ++应用程序</li>
            </ol>
            <a id="GUID-320589F8-AE9F-4440-9551-1C52F449E486" name="GUID-320589F8-AE9F-4440-9551-1C52F449E486"></a><a id="LNPCC012"></a>
            
            <h2 id="LNPCC-GUID-320589F8-AE9F-4440-9551-1C52F449E486" class="sect2"><span class="enumeration_chapter">12</span> C ++应用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用Pro * C / C ++预编译器预编译C ++嵌入式SQL应用程序，以及Pro * C / C ++如何生成C ++兼容代码。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E">了解C ++支持</a></p>
                  </li>
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224">预编译C ++</a></p>
                  </li>
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392">示例程序</a> <a id="d72932e39" class="indexterm-anchor"></a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3979"></a><div class="props_rev_3"><a id="GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E" name="GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E"></a><h3 id="LNPCC-GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E" class="sect3"><span class="enumeration_section">12.1</span>了解C ++支持</h3>
               <div>
                  <p>要了解Pro * C / C ++如何支持C ++，您必须了解Pro * C / C ++的基本功能。特别是，您必须了解Pro * C / C ++与Pro * C版本1的不同之处。</p>
                  <p>Pro * C / C ++的基本功能是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>完整的C预处理器支持。您可以在Pro * C / C ++程序中使用<code class="codeph">#include</code> <code class="codeph">#define</code> ， <code class="codeph">#include</code> ， <code class="codeph">#ifdef</code>和其他预处理程序指令来处理预编译器本身必须处理的构造。
                        </p>
                     </li>
                     <li>
                        <p>使用本机C结构作为主变量，包括将结构（或指向结构的指针）作为主变量传递给函数的能力，以及写入返回主机结构或结构指针的函数。</p>
                     </li>
                  </ul>
                  <p>为了支持其C预处理器功能并使主变量能够在特殊的Declare Section之外声明，Pro * C / C ++包含了一个完整的C解析器。Pro * C / C ++解析器是一个C解析器;它无法解析C ++代码。</p>
                  <p>这意味着对于C ++支持，您必须能够禁用C解析器，或者至少部分禁用它。要禁用C解析器，Pro * C / C ++预编译器包含命令行选项，可让您控制Pro * C / C ++对源代码执行的C解析范围。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="datatypes-and-host-variables.html#GUID-D3262C5B-4A7F-44C7-A171-DC16441A31ED">Oracle数据类型</a></li>
                        <li><a href="C-Plus-Plus-Applications.html#GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224">预编译C ++</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3980"></a><div class="props_rev_3"><a id="GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF" name="GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF"></a><h4 id="LNPCC-GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF" class="sect4"><span class="enumeration_section">12.1.1</span>无特殊宏处理</h4>
                  <div>
                     <p>将C ++与Pro * C / C ++一起使用不需要任何特殊的预处理或Pro * C / C ++外部的特殊宏处理器。无需在预编译器的输出上运行宏处理器即可实现C ++兼容性。</p>
                     <p>如果您是此版本之前的Pro * C / C ++预编译器版本的用户，并且您确实在预编译器输出上使用了宏处理器，那么您应该能够使用Pro * C / C ++预编译C ++应用程序，而无需更改码。</p>
                  </div>
               </div>
            </div><a id="LNPCC3981"></a><div class="props_rev_3"><a id="GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224" name="GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224"></a><h3 id="LNPCC-GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224" class="sect3"><span class="enumeration_section">12.2</span> C ++的预编译</h3>
               <div>
                  <p>要控制预编译以使其适应C ++，有四个注意事项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>预编译器的代码发射</p>
                     </li>
                     <li>
                        <p>解析能力</p>
                     </li>
                     <li>
                        <p>输出文件扩展名</p>
                     </li>
                     <li>
                        <p>系统头文件的位置</p>
                     </li>
                  </ul>
               </div><a id="LNPCC3982"></a><div class="props_rev_3"><a id="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0" name="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0"></a><h4 id="LNPCC-GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0" class="sect4"><span class="enumeration_section">12.2.1</span>代码生成</h4>
                  <div>
                     <p>您必须能够指定预编译器生成的代码类型，C兼容代码或C ++兼容代码。Pro * C / C ++默认生成C代码。C ++不是C的完美超集。生成的代码需要进行一些更改，以便可以通过C ++编译器进行编译。</p>
                     <p>例如，除了发出应用程序代码之外，预编译器还会调用其运行时库SQLLIB。 SQLLIB中的函数是C函数。SQLLIB没有特殊的C ++版本。因此，如果要使用C ++编译器编译生成的代码，Pro * C / C ++必须将SQLLIB中调用的函数声明为C函数。</p>
                     <p>对于C输出，预编译器将生成诸如的原型</p><pre class="oac_no_warn" dir="ltr">void sqlora(unsigned long *, void *);
</pre><p>但对于C ++兼容代码，预编译器必须生成</p><pre class="oac_no_warn" dir="ltr">extern "C" {
void sqlora(unsigned long *, void *);
};
</pre><p>您可以使用预编译器选项CODE控制Pro * C / C ++生成的代码类型。此选项有三个值：CPP，KR_C和ANSI_C。可以通过考虑SQLLIB函数<span class="italic">sqlora</span>的声明如何在CODE选项的三个值之间不同来说明这些选项之间的差异：</p><pre class="oac_no_warn" dir="ltr">void sqlora( /*_ unsigned long *, void * _*/);  /* K&amp;R C */

void sqlora(unsigned long *, void *);           /* ANSI C */

extern "C" {                                    /* CPP */
void sqlora(unsigned long *, void *);
};
</pre><p>指定CODE = CPP时，预编译器<a id="d72932e208" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>生成C ++可编译代码。</p>
                        </li>
                        <li>
                           <p>为输出文件提供特定于平台的文件扩展名（后缀），例如“。C“或”.cc“，而不是标准的”.c“扩展名。（您可以使用CPP_SUFFIX选项覆盖它。）</p>
                        </li>
                        <li>
                           <p>导致PARSE选项的值默认为PARTIAL。您也可以指定PARSE = NONE。如果指定PARSE = FULL，则在预编译时发出错误。</p>
                        </li>
                        <li>
                           <p>允许在代码中使用C ++样式//注释。当CODE = CPP时，SQL语句和PL / SQL块中也允许使用这种注释方式。</p>
                        </li>
                        <li>
                           <p>Pro * C / C ++识别以// +开头的SQL优化器提示。<a id="d72932e228" class="indexterm-anchor"></a></p>
                        </li>
                        <li>
                           <p>要求OTT（对象类型转换器）生成的头文件必须包含在声明部分中。</p>
                           <div class="infoboxnotealso" id="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0__GUID-56991AFB-CD1F-410B-AF85-4CBC47CCE2E1">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="precompiler-options.html#GUID-EA4E8928-3B92-4A29-BC1B-C726BFE4B79A">CODE</a> ”</span>有关CODE选项的KR_C和ANSI_C值的信息。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC3984"></a><a id="LNPCC3983"></a><div class="props_rev_3"><a id="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D" name="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D"></a><h4 id="LNPCC-GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D" class="sect4"><span class="enumeration_section">12.2.2</span>关于解析代码</h4>
                  <div>
                     <p>您必须能够控制Pro * C / C ++ C解析器对代码的影响。您可以使用PARSE预编译器选项来执行此操作，该选项控制预编译器的C解析器如何处理您的代码。</p>
                     <p>PARSE选项的值和效果是：</p>
                     <div class="tblformal" id="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D__GUID-899802DA-238A-4581-9803-EBE92B86CA7E">
                        <p class="titleintable">表12-1 PARSE选项的值和效果</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="PARSE期权的价值和影响" width="100%" border="1" summary="Values and Effects of the PARSE Option" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d72932e279">值</th>
                                 <th align="left" valign="bottom" width="69%" id="d72932e282">效果</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e287" headers="d72932e279 ">
                                    <p>PARSE = NONE</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e287 d72932e282 ">
                                    <p>值NONE具有以下效果：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>只有声明部分才能理解C预处理程序指令。</p>
                                       </li>
                                       <li>
                                          <p>您必须在Declare Section中声明所有主变量。</p>
                                       </li>
                                       <li>
                                          <p>预编译器发布1.x行为</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e304" headers="d72932e279 ">
                                    <p>PARSE =部分</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e304 d72932e282 ">
                                    <p>PARTIAL值具有以下效果：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>所有预处理器指令都被理解</p>
                                       </li>
                                       <li>
                                          <p>您必须在Declare Section中声明所有主变量</p>
                                       </li>
                                    </ul>
                                    <p>如果CODE = CPP，则此选项值是默认值</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e320" headers="d72932e279 ">
                                    <p>PARSE = FULL</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e320 d72932e282 ">
                                    <p>值FULL具有以下效果：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>预编译器C解析器在您的代码上运行。</p>
                                       </li>
                                       <li>
                                          <p>所有预处理程序指令都被理解。</p>
                                       </li>
                                       <li>
                                          <p>您可以在任何可以在C中合法声明的地方声明主变量。</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>如果CODE选项的值不是CPP，则此选项值是默认值。当CODE = CPP时指定PARSE = FULL是错误的。</p>
                     <p>要生成C ++兼容代码，PARSE选项必须是NONE或PARTIAL。如果PARSE = FULL，则C语法分析器运行，并且它不理解代码中的C ++构造，例如类。</p>
                  </div>
               </div><a id="LNPCC3985"></a><div class="props_rev_3"><a id="GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4" name="GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4"></a><h4 id="LNPCC-GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4" class="sect4"><span class="enumeration_section">12.2.3</span>输出文件名扩展名</h4>
                  <div>
                     <p>大多数C编译器都希望输入文件的默认扩展名为“.c”。但是，不同的C ++编译器可以期望不同的文件扩展名。CPP_SUFFIX选项提供了指定预编译器生成的文件扩展名的功能。此选项的值是一个字符串，不带引号或句点。例如，CPP_SUFFIX = cc或CPP_SUFFIX = C.<a id="d72932e365" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCC3986"></a><div class="props_rev_3"><a id="GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912" name="GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912"></a><h4 id="LNPCC-GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912" class="sect4"><span class="enumeration_section">12.2.4</span>系统头文件</h4>
                  <div>
                     <p><a id="d72932e392" class="indexterm-anchor"></a> Pro * C / C ++在特定于平台的标准位置搜索标准系统头文件，例如<code class="codeph">stdio.h</code> 。Pro * C / C ++不会搜索带有扩展名的头文件，例如<code class="codeph">hpp</code>或<code class="codeph">h</code> ++。例如，在几乎所有UNIX系统上，文件<code class="codeph">stdio.h</code>都具有完整路径名<code class="codeph">/usr/include/stdio.h</code> 。
                     </p>
                     <p>但是C ++编译器有自己的<code class="codeph">stdio.h</code>版本，它不在标准系统位置。在为C ++进行预编译时，必须使用SYS_INCLUDE预编译器选项指定Pro * C / C ++搜索以查找系统头文件的目录路径。例如：<a id="d72932e417" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">SYS_INCLUDE=(/usr/lang/SC2.0.1/include,/usr/lang/SC2.1.1/include)
</pre><p>使用INCLUDE预编译器选项指定非系统头文件的位置。在INCLUDE选项指定的目录之前搜索SYS_INCLUDE选项指定的目录。</p>
                     <p>如果PARSE = NONE，则系统文件的SYS_INCLUDE和INCLUDE中指定的值不相关，因为Pro * C / C ++不需要包含系统头文件。（当然，您仍然可以使用EXEC SQL INCLUDE语句包含Pro * C / C ++特定的头文件，例如<code class="codeph">sqlca.h</code> 。）
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-08EDB388-0406-4F03-9D9F-E0AAA8ADB2B5">包括</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3987"></a><div class="props_rev_3"><a id="GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392" name="GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392"></a><h3 id="LNPCC-GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392" class="sect3"><span class="enumeration_section">12.3</span>示例程序</h3>
               <div>
                  <div class="section">
                     <p>本节包括三个包含C ++构造的Pro * C / C ++程序示例。这些程序中的每一个都可以在您的<code class="codeph">demo</code>目录中在线获得。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC3988"></a><div class="props_rev_3"><a id="GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0" name="GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0"></a><h4 id="LNPCC-GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0" class="sect4"><span class="enumeration_section">12.3.1</span> cppdemo1.pc</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">
/*  cppdemo1.pc
 *
 *  Prompts the user for an employee number, then queries the 
 *  emp table for the employee's name, salary and commission.
 *  Uses indicator variables (in an indicator struct) to 
 *  determine if the commission is NULL.
 */

#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// Parse=partial by default when code=cpp,
// so preprocessor directives are recognized and parsed fully.
#define     UNAME_LEN      20
#define     PWD_LEN        40

// Declare section is required when CODE=CPP or
// PARSE={PARTIAL|NONE} or both.
EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR username[UNAME_LEN];  // VARCHAR is an ORACLE pseudotype
  varchar password[PWD_LEN];    // can be in lower case also

  // Define a host structure for the output values
  // of a SELECT statement
  struct empdat {
      VARCHAR   emp_name[UNAME_LEN];
      float     salary;
      float     commission;
  } emprec;

  // Define an indicator struct to correspond to the
  // host output struct
  struct empind {
      short     emp_name_ind;
      short     sal_ind;
      short     comm_ind;
  } emprec_ind;


  // Input host variables
  int   emp_number;
  int   total_queried;
EXEC SQL END DECLARE SECTION;

// Define a C++ class object to match the desired
// struct from the preceding declare section.
class emp {
  char  ename[UNAME_LEN];
  float salary;
  float commission;
public:
  // Define a constructor for this C++ object that
  // takes ordinary C objects.
  emp(empdat&amp;, empind&amp;);
  friend ostream&amp; operator&lt;&lt;(ostream&amp;, emp&amp;);
};

emp::emp(empdat&amp; dat, empind&amp; ind)
{
  strncpy(ename, (char *)dat.emp_name.arr, dat.emp_name.len);
  ename[dat.emp_name.len] = '\0';
  this-&gt;salary = dat.salary;
  this-&gt;commission = (ind.comm_ind &lt; 0) ? 0 : dat.commission;
}

ostream&amp; operator&lt;&lt;(ostream&amp; s, emp&amp; e)
{
  return s &lt;&lt; e.ename &lt;&lt; " earns " &lt;&lt; e.salary &lt;&lt; 
              " plus " &lt;&lt; e.commission &lt;&lt; " commission." 
           &lt;&lt; endl &lt;&lt; endl;
}

// Include the SQL Communications Area
// You can use #include or EXEC SQL INCLUDE
#include &lt;sqlca.h&gt;

// Declare error handling function
void sql_error(char *msg);

main()
{
  char temp_char[32];

  // Register sql_error() as the error handler
  EXEC SQL WHENEVER SQLERROR DO sql_error("ORACLE error:");

  // Connect to ORACLE.  Program calls sql_error()
  // if an error occurs
  // when connecting to the default database.
  // Note the (char *) cast when
  // copying into the VARCHAR array buffer.
  username.len = strlen(strcpy((char *)username.arr, "SCOTT"));
  password.len = strlen(strcpy((char *)password.arr, "TIGER"));
  
  EXEC SQL CONNECT :username IDENTIFIED BY :password;

  // Here again, note the (char *) cast when using VARCHARs
  cout &lt;&lt; "\nConnected to ORACLE as user: "
       &lt;&lt; (char *)username.arr &lt;&lt; endl &lt;&lt; endl;

  // Loop, selecting individual employee's results
  total_queried = 0;
  while (1)
  {
      emp_number = 0;
      printf("Enter employee number (0 to quit): ");
      gets(temp_char);
      emp_number = atoi(temp_char);
      if (emp_number == 0)
        break;

      // Branch to the notfound label when the 
      // 1403 ("No data found") condition occurs
      EXEC SQL WHENEVER NOT FOUND GOTO notfound;

      EXEC SQL SELECT ename, sal, comm
         INTO :emprec INDICATOR :emprec_ind // You can also use 
                                            // C++ style
         FROM EMP                  // Comments in SQL statemtents.
         WHERE EMPNO = :emp_number;

      {
        // Basic idea is to pass C objects to
        // C++ constructors thus
        // creating equivalent C++ objects used in the
        // usual C++ way
        emp e(emprec, emprec_ind);
        cout &lt;&lt; e;
      }

      total_queried++;
      continue;
notfound:
      cout &lt;&lt; "Not a valid employee number - try again." 
           &lt;&lt; endl &lt;&lt; endl;
  } // end while(1)

  cout &lt;&lt; endl &lt;&lt; "Total rows returned was " 
       &lt;&lt; total_queried &lt;&lt; endl;
  cout &lt;&lt; "Have a nice day!" &lt;&lt; endl &lt;&lt; endl;

  // Disconnect from ORACLE
  EXEC SQL COMMIT WORK RELEASE;
  exit(0);
}


void sql_error(char *msg)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    cout &lt;&lt; endl &lt;&lt; msg &lt;&lt; endl;
    cout &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl;
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3989"></a><div class="props_rev_3"><a id="GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075" name="GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075"></a><h4 id="LNPCC-GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075" class="sect4"><span class="enumeration_section">12.3.2</span> cppdemo2.pc</h4>
                  <div>
                     <div class="section">
                        <p>下一个应用程序是一个简单的模块化示例首先，在SQL * Plus中执行以下SQL脚本<code class="codeph">cppdemo2.sql</code> ：</p><pre class="oac_no_warn" dir="ltr"><a id="d72932e528" class="indexterm-anchor"></a>Rem  This is the SQL script that accompanies the cppdemo2 C++ Demo
Rem  Program.  Run this prior to Precompiling the empclass.pc file.
/
CONNECT SCOTT/TIGER
/
CREATE OR REPLACE VIEW emp_view AS SELECT ename, empno FROM EMP
/
CREATE OR REPLACE PACKAGE emp_package AS
  TYPE emp_cursor_type IS REF CURSOR RETURN emp_view%ROWTYPE;
  PROCEDURE open_cursor(curs IN OUT emp_cursor_type);
END emp_package;
/
CREATE OR REPLACE PACKAGE BODY emp_package AS
  PROCEDURE open_cursor(curs IN OUT emp_cursor_type) IS
  BEGIN
    OPEN curs FOR SELECT ename, empno FROM emp_view ORDER BY ename ASC;
  END;
END emp_package;
/
EXIT
/
</pre><p>头文件<code class="codeph">empclass.h</code>定义了类<code class="codeph">emp</code> ：</p><pre class="oac_no_warn" dir="ltr">
// This class definition may be included in a Pro*C/C++ application
// program using the EXEC SQL INCLUDE directive only.  Because it
// contains EXEC SQL syntax, it may not be included using a #include
// directive.  Any program that includes this header must be
// precompiled with the CODE=CPP option.  This emp class definition
// is used when building the cppdemo2 C++ Demo Program.

class emp
{
  public:
    emp();   // Constructor: ALLOCATE Cursor Variable
    ~emp();  // Desctructor: FREE Cursor Variable

    void open();              // Open Cursor
    void fetch() throw (int); // Fetch (throw NOT FOUND condition)
    void close();             // Close Cursor

    void emp_error();         // Error Handler

    EXEC SQL BEGIN DECLARE SECTION;
      // When included using EXEC SQL INCLUDE, class variables have 
      // global scope and are thus basically treated as ordinary
      // global variables by Pro*C/C++ during precompilation.
      char ename[10];
      int empno;
    EXEC SQL END DECLARE SECTION;

  private:
    EXEC SQL BEGIN DECLARE SECTION;
      // Pro*C/C++ treats this as a simple global variable also.
      SQL_CURSOR emp_cursor;
    EXEC SQL END DECLARE SECTION;
};
</pre><p><code class="codeph">empclass.pc</code>中的代码包含<code class="codeph">emp</code>方法：</p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// This example uses a single (global) SQLCA that is shared by the
// emp class implementation as well as the main program for this
// application.
#define SQLCA_STORAGE_CLASS extern
#include &lt;sqlca.h&gt;

// Include the emp class specification in the implementation of the
// class body as well as the application program that makes use of it.
EXEC SQL INCLUDE empclass.h;

emp::emp()
{
  // The scope of this WHENEVER statement spans the entire module.
  // Note that the error handler function is really a member function
  // of the emp class.
  EXEC SQL WHENEVER SQLERROR DO emp_error();
  EXEC SQL ALLOCATE :emp_cursor;  // Constructor - ALLOCATE Cursor.
}

emp::~emp()
{
  EXEC SQL FREE :emp_cursor;      // Destructor - FREE Cursor.
}

void emp::open()
{
  EXEC SQL EXECUTE
    BEGIN
      emp_package.open_cursor(:emp_cursor);
    END;
  END-EXEC;
}

void emp::close()
{
  EXEC SQL CLOSE :emp_cursor;
}

void emp::fetch() throw (int)
{
  EXEC SQL FETCH :emp_cursor INTO :ename, :empno;
  if (sqlca.sqlcode == 1403)
    throw sqlca.sqlcode;     // Like a WHENEVER NOT FOUND statement.
}

void emp::emp_error()
{
  printf("%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);
}
</pre><p>主程序<code class="codeph">cppdemo2.pc</code>使用游标变量：</p><pre class="oac_no_warn" dir="ltr">// Pro*C/C++ sample program demonstrating a simple use of Cursor Variables
// implemented within a C++ class framework.  Build this program as follows
//
//   1. Execute the cppdemo2.sql script within SQL*Plus
//   2. Precompile the empclass.pc program as follows
//      &gt; proc code=cpp sqlcheck=full user=scott/tiger lines=yes empclass
//   3. Precompile the cppdemo2.pc program as follows
//      &gt; proc code=cpp lines=yes cppdemo2
//   4. Compile and Link
//
// Note that you may have to specify various include directories using the
// include option when precompiling.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlca.h&gt;

static void sql_error()
{
  printf("%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);  
}

// Physically include the emp class definition in this module.
EXEC SQL INCLUDE empclass.h;

int main()
{
  EXEC SQL BEGIN DECLARE SECTION;
    char *uid = "scott/tiger";
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO sql_error();
  EXEC SQL CONNECT :uid;

  emp *e = new emp(); // Invoke Constructor - ALLOCATE Cursor Variable.

  e-&gt;open();          // Open the Cursor.

  while (1)
    {
      // Fetch from the Cursor, catching the NOT FOUND condition
      // thrown by the fetch() member function.
      try { e-&gt;fetch(); } catch (int code)  
        { if (code == 1403) break; }
      printf("Employee:  %s[%d]\n", e-&gt;ename, e-&gt;empno);
    }

  e-&gt;close();         // Close the Cursor.

  delete e;           // Invoke Destructor - FREE Cursor Variable.

  EXEC SQL ROLLBACK WORK RELEASE;
  return (0);
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3990"></a><div class="props_rev_3"><a id="GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF" name="GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF"></a><h4 id="LNPCC-GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF" class="sect4"><span class="enumeration_section">12.3.3</span> cppdemo3.pc</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">/*
 * cppdemo3.pc : An example of C++ Inheritance
 *
 * This program finds all salesman and prints their names
 * followed by how much they earn in total (ie; including 
 * any commissions).
 */
 
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;string.h&gt;

#define NAMELEN 10

class employee {    // Base class is a simple employee
public:
  char ename[NAMELEN];
  int sal;
  employee(char *, int);
};

employee::employee(char *ename, int sal)
{
  strcpy(this-&gt;ename, ename);
  this-&gt;sal = sal;
}

// A salesman is a kind of employee
class salesman : public employee
{
  int comm;
public:
  salesman(char *, int, int);
  friend ostream&amp; operator&lt;&lt;(ostream&amp;, salesman&amp;);
};

// Inherits employee attributes
salesman::salesman(char *ename, int sal, int comm)
  : employee(ename, sal), comm(comm) {}  

ostream&amp; operator&lt;&lt;(ostream&amp; s, salesman&amp; m)
{
  return s &lt;&lt; m.ename &lt;&lt; m.sal + m.comm &lt;&lt; endl;  
}

void print(char *ename, int sal, int comm)
{
  salesman man(ename, sal, comm);
  cout &lt;&lt; man;
}

main()
{
  EXEC SQL BEGIN DECLARE SECTION;
    char *uid = "scott/tiger";
    char  ename[NAMELEN];
    int   sal, comm;
    short comm_ind;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR GOTO error;

  EXEC SQL CONNECT :uid;
  EXEC SQL DECLARE c CURSOR FOR
    SELECT ename, sal, comm FROM emp WHERE job = 'SALESMAN'
      ORDER BY ename;
  EXEC SQL OPEN c;

  cout &lt;&lt; "Name    Salary" &lt;&lt; endl &lt;&lt; "------  ------" &lt;&lt; endl;

  EXEC SQL WHENEVER NOT FOUND DO break;
  while(1)
   {
     EXEC SQL FETCH c INTO :ename, :sal, :comm:comm_ind;
     print(ename, sal, (comm_ind &lt; 0) ? 0 : comm);
   }
  EXEC SQL CLOSE c;
  exit(0);

error:
  cout &lt;&lt; endl &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl;
  exit(1);
}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>