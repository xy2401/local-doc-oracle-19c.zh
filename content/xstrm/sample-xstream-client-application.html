<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server.">
      <meta name="description" content="Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server.">
      <title>示例XStream客户端应用程序</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="XStream Guide ">
      <meta property="og:description" content="Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="XStream Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="xstream-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-07T01:45:15-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2009, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96280-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="appendixes.html" title="Previous" type="text/html">
      <link rel="next" href="xstream-out-restrictions.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XStream Guide">
    <meta name="dcterms.isVersionOf" content="XSTRM">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="appendixes.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="xstream-out-restrictions.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">XStream指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="appendixes.html" property="item" typeof="WebPage"><span property="name">附录</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">示例XStream客户端应用程序</li>
            </ol>
            <a id="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" name="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8"></a>
            
            <h2 id="XSTRM-GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" class="sect2"><span class="enumeration_chapter">A</span>样品XStream的客户端应用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sample-xstream-client-application.html#GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94">关于Sample XStream客户端应用程序</a><br>示例XStream客户端应用程序说明了XStream Out和XStream In应用程序所需的基本任务。
                  </li>
                  <li class="ulchildlink"><a href="sample-xstream-client-application.html#GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4">Oracle Call Interface API的示例XStream客户端应用程序</a><br>要为OCI API运行示例XStream客户端应用程序，请编译并链接应用程序文件。
                  </li>
                  <li class="ulchildlink"><a href="sample-xstream-client-application.html#GUID-952CEB45-9E0D-49AE-853A-912524B49853">Java API的示例XStream客户端应用程序</a><br>要为Java API运行示例XStream客户端应用程序，请编译并链接应用程序文件。
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8__GUID-23B0AF79-7AA7-43A2-8A86-14BDFBF48D7E">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="q">“ <a href="xstream-out-concepts.html#GUID-B59B1F79-91F6-4495-B946-5DCEB317E0D6" title="熟悉与XStream Out相关的概念。">XStream Out Concepts</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="introduction-to-xstream.html#GUID-21FC23DF-2881-4CFD-AF74-9A1173D768FF" title="有几种常见的XStream用例。">XStream用例</a> ”</span></p>
                     </li>
                     <li>
                        <p><a href="../lnoci/intro-to-oci-interface-for-XStream.html#LNOCI72903" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></p>
                     </li>
                     <li>
                        <p><a href="../stxjv/index.html" target="_blank"><span><cite>Oracle数据库XStream Java API参考</cite></span></a></p>
                     </li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="appendixes.html#GUID-08D451B5-2D76-447B-B39B-20CC73110D19" title="附录包括有关XStream客户端应用程序和XStream限制的信息。">附录</a></p>
                  </div>
               </div>
            </div>
            <a id="XSTRM1640"></a><a id="XSTRM1568"></a><a id="XSTRM72732"></a><div class="props_rev_3"><a id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94" name="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94"></a><h3 id="XSTRM-GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94" class="sect3"><span class="enumeration_section">A.1</span>关于示例XStream客户端应用程序</h3>
               <div>
                  <p>示例XStream客户端应用程序说明了XStream Out和XStream In应用程序所需的基本任务。</p>
                  <p>该应用程序执行以下任务：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>它附加到XStream出站服务器和入站服务器，并等待来自出站服务器的LCR。出站服务器和入站服务器位于两个不同的数据库中。</p>
                     </li>
                     <li>
                        <p>当它从出站服务器收到LCR时，它会立即将LCR发送到入站服务器。</p>
                     </li>
                     <li>
                        <p>它定期从入站服务器获取已处理的低位置，并将此值发送到出站服务器。</p>
                     </li>
                     <li>
                        <p>它定期从出站服务器向入站服务器发送“ping”LCR，以便在活动较少时将入站服务器处理的低位置向前移动。</p>
                     </li>
                  </ul>
                  <p>在不将LCR发送到入站服务器的XStream Out配置中，客户端应用程序必须以另一种方式获取已处理的低位置。</p>
                  <p>此应用程序无限期地等待来自出站服务器的事务。要中断应用程序，请输入操作系统的中断命令。例如，某些操作系统上的中断命令是<code class="codeph">control-C</code> 。如果程序重新启动，则出站服务器开始从上一次运行期间设置的已处理低位发送LCR。
                  </p>
                  <p><a href="sample-xstream-client-application.html#GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__CBDIHADI">图A-1</a>提供了本节中配置的XStream环境的概述。
                  </p>
                  <div class="figure" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__CBDIHADI">
                     <p class="titleinfigure">图A-1 XStream配置示例</p><img src="img/xstrm508.gif" width="600" alt="下面是图A-1的描述" title="下面是图A-1的描述" longdesc="img_text/xstrm508.html"><br><a href="img_text/xstrm508.html">“图A-1 XStream配置示例”的说明</a></div>
                  <!-- class="figure" -->
                  <p>在运行示例应用程序之前，请确保存在以下组件：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>两个Oracle数据库，它们之间具有网络连接</p>
                     </li>
                     <li>
                        <p>两个数据库上的XStream管理员</p>
                     </li>
                     <li>
                        <p>一个数据库上的出站服务器配置，包括捕获进程，队列和出站服务器</p>
                     </li>
                     <li>
                        <p>另一个数据库上的入站服务器配置</p>
                     </li>
                  </ul>
                  <p>如果您使用多租户容器数据库（CDB）运行示例应用程序，请确保客户端应用程序连接到正确的容器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>当客户端应用程序连接到出站服务器时，它必须连接到根。</p>
                     </li>
                     <li>
                        <p>当客户端应用程序连接到入站服务器时，它必须连接到创建入站服务器的容器。</p>
                     </li>
                  </ul>
                  <p>以下部分中的示例应用程序执行相同的任务。一个示例应用程序使用OCI API，另一个使用Java API。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sample-xstream-client-application.html#GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" title="要为OCI API运行示例XStream客户端应用程序，请编译并链接应用程序文件。">Oracle Call Interface API的示例XStream客户端应用程序</a></p>
                     </li>
                     <li>
                        <p><a href="sample-xstream-client-application.html#GUID-952CEB45-9E0D-49AE-853A-912524B49853" title="要为Java API运行示例XStream客户端应用程序，请编译并链接应用程序文件。">Java API的示例XStream客户端应用程序</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__GUID-4231CE64-849C-4E9B-BDE1-268608E66A2E">
                     <p class="notep1">注意：</p>
                     <p>Oracle数据库安装包括几个XStream演示。这些演示位于以下位置：</p><pre class="oac_no_warn" dir="ltr">$ORACLE_HOME/rdbms/demo/xstream
</pre></div>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__GUID-EA6145CF-AA41-47AE-BB6E-900BE0424BA2">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="general-xstream-concepts.html#GUID-077AAE24-54CF-4102-9969-9540608FFB65" title="每个LCR都有一个位置属性。LCR的位置标识其在交易中的LCR流中的位置。">在LCR流中定位订单</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="configuring-xstream-out.html#GUID-1338E648-E214-4666-98A1-8B8D0085EB23" title="您可以配置XStream Out使用的Oracle数据库组件。">配置XStream Out</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="configuring-xstream-in.html#GUID-B0F20D2D-7F63-4CE6-B15F-435B5A3DFBED" title="您可以配置XStream使用的Oracle数据库组件。">配置XStream</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../arpls/DBMS_XSTREAM_AUTH.html#ARPLS73653" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sample-xstream-client-application.html#GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" title="示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。">示例XStream客户端应用程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="XSTRM1569"></a><div class="props_rev_3"><a id="GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" name="GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4"></a><h3 id="XSTRM-GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" class="sect3"><span class="enumeration_section">A.2</span> Oracle Call Interface API的示例XStream客户端应用程序</h3>
               <div>
                  <p>要为OCI API运行示例XStream客户端应用程序，请编译并链接应用程序文件。</p>
                  <p>接下来，在命令行中输入以下内容：</p><pre class="oac_no_warn" dir="ltr">xio -ob_svr <span class="italic">xout_name</span> -ob_db <span class="italic">sn_xout_db</span> -ob_usr <span class="italic">xout_cu</span> -ob_pwd <span class="italic">xout_cu_pass</span> 
-ib_svr <span class="italic">xin_name</span> -ib_db <span class="italic">sn_xin_db</span> -ib_usr <span class="italic">xin_au</span> -ib_pwd <span class="italic">xin_au_pass</span>
</pre><p>替换以下占位符的适当值：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="italic">xout_name</span>是出站服务器的名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">sn_xout_db</span>是出站服务器数据库的服务名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xout_cu</span>是出站服务器的连接用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xout_cu_pass</span>是出站服务器的连接用户的密码。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_name</span>是入站服务器的名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">sn_xin_db</span>是入站服务器数据库的服务名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_au</span>是入站服务器的应用用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_au_pass</span>是入站服务器的应用用户的密码。
                        </p>
                     </li>
                  </ul>
                  <p>示例客户端应用程序运行时，它会打印有关正在处理的行LCR的信息。输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr"> ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=17.0.74
  owner=HR oname=COUNTRIES 
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=COMMIT txid=17.0.74
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=12.25.77
  owner=OE oname=ORDERS 
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=12.25.77
  owner=OE oname=ORDERS 
</pre><p>此输出包含每行LCR的以下信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">src_db_name</code>显示封装在行LCR中的更改的源数据库。</p>
                     </li>
                     <li>
                        <p><code class="codeph">cmd_type</code>显示进行更改的SQL语句的类型。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">txid</code>显示包含行LCR的事务的事务ID。</p>
                     </li>
                     <li>
                        <p><code class="codeph">owner</code>显示已更改的数据库对象的所有者。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">oname</code>显示已更改的数据库对象的名称。
                        </p>
                     </li>
                  </ul>
                  <p>此演示位于以下位置：</p><pre class="oac_no_warn" dir="ltr">$ORACLE_HOME/rdbms/demo/xstream/oci
</pre><p>演示的文件名是<code class="codeph">xio.c</code>有关编译和运行应用程序的更多信息，请参阅演示目录中的<code class="codeph">README.txt</code>文件。
                  </p>
                  <p>使用OCI API的示例应用程序的代码如下：</p><pre class="oac_no_warn" dir="ltr">#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
 
#ifndef _STDIO_H
#include &lt;stdio.h&gt;
#endif
 
#ifndef _STDLIB_H
#include &lt;stdlib.h&gt;
#endif
 
#ifndef _STRING_H
#include &lt;string.h&gt;
#endif
 
#ifndef _MALLOC_H
#include &lt;malloc.h&gt;
#endif
 
/*---------------------------------------------------------------------- 
 *           Internal structures
 *----------------------------------------------------------------------*/ 
 
#define M_DBNAME_LEN    (128)
 
typedef struct conn_info                                     /* connect info */
{
  oratext * user;
  ub4       userlen;
  oratext * passw;
  ub4       passwlen;
  oratext * dbname;
  ub4       dbnamelen;
  oratext * svrnm;
  ub4       svrnmlen;
} conn_info_t;
 
typedef struct params
{
  conn_info_t  xout;                                        /* outbound info */
  conn_info_t  xin;                                          /* inbound info */
} params_t;
 
typedef struct oci                                            /* OCI handles */
{
  OCIEnv      *envp;                                   /* Environment handle */
  OCIError    *errp;                                         /* Error handle */
  OCIServer   *srvp;                                        /* Server handle */
  OCISvcCtx   *svcp;                                       /* Service handle */
  OCISession  *authp;
  OCIStmt    *stmtp;        
  boolean     attached;
  boolean     outbound;
} oci_t;
 
static void connect_db(conn_info_t *opt_params_p, oci_t ** ocip, ub2 char_csid,
                       ub2 nchar_csid);
static void disconnect_db(oci_t * ocip);
static void ocierror(oci_t * ocip, char * msg);
static void attach(oci_t * ocip, conn_info_t *conn, boolean outbound);
static void detach(oci_t *ocip);
static void get_lcrs(oci_t *xin_ocip, oci_t *xout_ocip);
static void get_chunks(oci_t *xin_ocip, oci_t *xout_ocip);
static void print_lcr(oci_t *ocip, void *lcrp, ub1 lcrtype, 
                      oratext **src_db_name, ub2  *src_db_namel);
static void print_chunk (ub1 *chunk_ptr, ub4 chunk_len, ub2 dty);
static void get_inputs(conn_info_t *xout_params, conn_info_t *xin_params, 
                       int argc, char ** argv);
static void get_db_charsets(conn_info_t *params_p, ub2 *char_csid, 
                            ub2 *nchar_csid);
static void set_client_charset(oci_t *outbound_ocip);
 
#define OCICALL(ocip, function) do {\
sword status=function;\
if (OCI_SUCCESS==status) break;\
else if (OCI_ERROR==status) \
{ocierror(ocip, (char *)"OCI_ERROR");\
exit(1);}\
else {printf("Error encountered %d\n", status);\
exit(1);}\
} while(0)
 
/*---------------------------------------------------------------------
 *                M A I N   P R O G R A M
 *---------------------------------------------------------------------*/
main(int argc, char **argv)
{
  /* Outbound and inbound connection info */
  conn_info_t   xout_params;
  conn_info_t   xin_params;
  oci_t        *xout_ocip = (oci_t *)NULL;
  oci_t        *xin_ocip = (oci_t *)NULL;
  ub2           obdb_char_csid = 0;                 /* outbound db char csid */
  ub2           obdb_nchar_csid = 0;               /* outbound db nchar csid */
 
  /* parse command line arguments */
  get_inputs(&amp;xout_params, &amp;xin_params, argc, argv); 
 
  /* Get the outbound database CHAR and NCHAR character set info */
  get_db_charsets(&amp;xout_params, &amp;obdb_char_csid, &amp;obdb_nchar_csid);
 
  /* Connect to the outbound db and set the client env to the outbound charsets
   * to minimize character conversion when transferring LCRs from outbound 
   * directly to inbound server. 
   */
  connect_db(&amp;xout_params, &amp;xout_ocip, obdb_char_csid, obdb_nchar_csid);
 
  /* Attach to outbound server */
  attach(xout_ocip, &amp;xout_params, TRUE);
 
  /* connect to inbound db and set the client charsets the same as the 
   * outbound db charsets.
   */
  connect_db(&amp;xin_params, &amp;xin_ocip, obdb_char_csid, obdb_nchar_csid);
 
  /* Attach to inbound server */
  attach(xin_ocip, &amp;xin_params, FALSE);
 
  /* Get lcrs from outbound server and send to inbound server */
  get_lcrs(xin_ocip, xout_ocip);
 
  /* Detach from XStream servers */
  detach(xout_ocip);
  detach(xin_ocip);
 
  /* Disconnect from both databases */
  disconnect_db(xout_ocip);
  disconnect_db(xin_ocip);
 
  free(xout_ocip);
  free(xin_ocip);
  exit (0);
}
 
/*---------------------------------------------------------------------
 * connect_db - Connect to the database and set the env to the given
 * char and nchar character set ids. 
 *---------------------------------------------------------------------*/
static void connect_db(conn_info_t *params_p, oci_t **ociptr, ub2 char_csid,
                ub2 nchar_csid)
{
  oci_t        *ocip;
 
  printf ("Connect to Oracle as %.*s@%.*s ",
          params_p-&gt;userlen, params_p-&gt;user, 
          params_p-&gt;dbnamelen, params_p-&gt;dbname);
       
  if (char_csid &amp;&amp; nchar_csid)
    printf ("using char csid=%d and nchar csid=%d", char_csid, nchar_csid);
 
  printf("\n");
 
  ocip = (oci_t *)malloc(sizeof(oci_t));
 
  if (OCIEnvNlsCreate(&amp;ocip-&gt;envp, OCI_OBJECT, (dvoid *)0,
                     (dvoid * (*)(dvoid *, size_t)) 0,
                     (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                     (void (*)(dvoid *, dvoid *)) 0,
                     (size_t) 0, (dvoid **) 0, char_csid, nchar_csid))
  {
    ocierror(ocip, (char *)"OCIEnvCreate() failed");
  }
 
  if (OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;errp,
                     (ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)"OCIHandleAlloc(OCI_HTYPE_ERROR) failed");
  }
 
  /* Logon to database */
  OCICALL(ocip,
          OCILogon(ocip-&gt;envp, ocip-&gt;errp, &amp;ocip-&gt;svcp,
                   params_p-&gt;user, params_p-&gt;userlen,
                   params_p-&gt;passw, params_p-&gt;passwlen,
                   params_p-&gt;dbname, params_p-&gt;dbnamelen));
 
  /* allocate the server handle */
  OCICALL(ocip,
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;srvp,
                         OCI_HTYPE_SERVER, (size_t) 0, (dvoid **) 0));
 
  OCICALL(ocip, 
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;stmtp,
                     (ub4) OCI_HTYPE_STMT, (size_t) 0, (dvoid **) 0));
 
  if (*ociptr == (oci_t *)NULL)
  {
    *ociptr = ocip;
  }
}
 
/*---------------------------------------------------------------------
 * get_db_charsets - Get the database CHAR and NCHAR character set ids.
 *---------------------------------------------------------------------*/
static const oratext GET_DB_CHARSETS[] =  \
 "select parameter, value from nls_database_parameters where parameter = \
 'NLS_CHARACTERSET' or parameter = 'NLS_NCHAR_CHARACTERSET'";
 
#define PARM_BUFLEN      (30)
 
static void get_db_charsets(conn_info_t *params_p, ub2 *char_csid, 
                            ub2 *nchar_csid)
{
  OCIDefine  *defnp1 = (OCIDefine *) NULL;
  OCIDefine  *defnp2 = (OCIDefine *) NULL;
  oratext     parm[PARM_BUFLEN];
  oratext     value[OCI_NLS_MAXBUFSZ];
  ub2         parm_len = 0;
  ub2         value_len = 0;
  oci_t       ocistruct; 
  oci_t      *ocip = &amp;ocistruct;
   
  *char_csid = 0;
  *nchar_csid = 0;
  memset (ocip, 0, sizeof(ocistruct));
 
  if (OCIEnvCreate(&amp;ocip-&gt;envp, OCI_OBJECT, (dvoid *)0,
                     (dvoid * (*)(dvoid *, size_t)) 0,
                     (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                     (void (*)(dvoid *, dvoid *)) 0,
                     (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)"OCIEnvCreate() failed");
  }
 
  if (OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;errp,
                     (ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)"OCIHandleAlloc(OCI_HTYPE_ERROR) failed");
  }
 
  OCICALL(ocip, 
          OCILogon(ocip-&gt;envp, ocip-&gt;errp, &amp;ocip-&gt;svcp,
                   params_p-&gt;user, params_p-&gt;userlen,
                   params_p-&gt;passw, params_p-&gt;passwlen,
                   params_p-&gt;dbname, params_p-&gt;dbnamelen));
 
  OCICALL(ocip, 
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;stmtp,
                     (ub4) OCI_HTYPE_STMT, (size_t) 0, (dvoid **) 0));
 
  /* Execute stmt to select the db nls char and nchar character set */ 
  OCICALL(ocip, 
          OCIStmtPrepare(ocip-&gt;stmtp, ocip-&gt;errp,
                         (CONST text *)GET_DB_CHARSETS,
                         (ub4)strlen((char *)GET_DB_CHARSETS),
                         (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT));
 
  OCICALL(ocip,
          OCIDefineByPos(ocip-&gt;stmtp, &amp;defnp1,
                         ocip-&gt;errp, (ub4) 1, parm,
                         PARM_BUFLEN, SQLT_CHR, (void*) 0,
                         &amp;parm_len, (ub2 *)0, OCI_DEFAULT));
 
  OCICALL(ocip,
          OCIDefineByPos(ocip-&gt;stmtp, &amp;defnp2,
                         ocip-&gt;errp, (ub4) 2, value,
                         OCI_NLS_MAXBUFSZ, SQLT_CHR, (void*) 0,
                         &amp;value_len, (ub2 *)0, OCI_DEFAULT));
 
  OCICALL(ocip, 
          OCIStmtExecute(ocip-&gt;svcp, ocip-&gt;stmtp, 
                         ocip-&gt;errp, (ub4)0, (ub4)0, 
                         (const OCISnapshot *)0,
                         (OCISnapshot *)0, (ub4)OCI_DEFAULT));
 
  while (OCIStmtFetch(ocip-&gt;stmtp, ocip-&gt;errp, 1,
                      OCI_FETCH_NEXT, OCI_DEFAULT) == OCI_SUCCESS)
  {
    value[value_len] = '\0';
    if (parm_len == strlen("NLS_CHARACTERSET") &amp;&amp;
        !memcmp(parm, "NLS_CHARACTERSET", parm_len))
    {
      *char_csid = OCINlsCharSetNameToId(ocip-&gt;envp, value);
      printf("Outbound database NLS_CHARACTERSET = %.*s (csid = %d) \n",
             value_len, value, *char_csid);
    }
    else if (parm_len == strlen("NLS_NCHAR_CHARACTERSET") &amp;&amp;
             !memcmp(parm, "NLS_NCHAR_CHARACTERSET", parm_len))
    {
      *nchar_csid = OCINlsCharSetNameToId(ocip-&gt;envp, value);
      printf("Outbound database NLS_NCHAR_CHARACTERSET = %.*s (csid = %d) \n",
             value_len, value, *nchar_csid);
    }
  }
 
  disconnect_db(ocip);
}
 
/*---------------------------------------------------------------------
 * attach - Attach to XStream server specified in connection info
 *---------------------------------------------------------------------*/
static void attach(oci_t * ocip, conn_info_t *conn, boolean outbound)
{
  sword       err;
 
  printf ("Attach to XStream %s server '%.*s'\n", 
          outbound ? "outbound" : "inbound",
          conn-&gt;svrnmlen, conn-&gt;svrnm);
 
  if (outbound)
  {
    OCICALL(ocip, 
            OCIXStreamOutAttach(ocip-&gt;svcp, ocip-&gt;errp, conn-&gt;svrnm,
                              (ub2)conn-&gt;svrnmlen, (ub1 *)0, 0, OCI_DEFAULT));
  }
  else
  {
    OCICALL(ocip, 
            OCIXStreamInAttach(ocip-&gt;svcp, ocip-&gt;errp, conn-&gt;svrnm,
                               (ub2)conn-&gt;svrnmlen, 
                               (oratext *)"From_XOUT", 9,
                               (ub1 *)0, 0, OCI_DEFAULT));
  }
 
  ocip-&gt;attached = TRUE;
  ocip-&gt;outbound = outbound;
}
 
/*---------------------------------------------------------------------
 * ping_svr - Ping inbound server by sending a commit LCR.
 *---------------------------------------------------------------------*/
static void ping_svr(oci_t *xin_ocip, void *commit_lcr,
                     ub1 *cmtpos, ub2 cmtpos_len, 
                     oratext *source_db, ub2 source_db_len)
{
  OCIDate     src_time;
  oratext     txid[128];
 
  OCICALL(xin_ocip, OCIDateSysDate(xin_ocip-&gt;errp, &amp;src_time));
  sprintf((char *)txid, "Ping %2d:%2d:%2d",
          src_time.OCIDateTime.OCITimeHH,
          src_time.OCIDateTime.OCITimeMI,
          src_time.OCIDateTime.OCITimeSS);
 
  /* Initialize LCR with new txid and commit position */
  OCICALL(xin_ocip,
          OCILCRHeaderSet(xin_ocip-&gt;svcp, xin_ocip-&gt;errp,
                          source_db, source_db_len,
                          (oratext *)OCI_LCR_ROW_CMD_COMMIT,
                          (ub2)strlen(OCI_LCR_ROW_CMD_COMMIT),
                          (oratext *)0, 0,                     /* null owner */
                          (oratext *)0, 0,                    /* null object */
                          (ub1 *)0, 0,                           /* null tag */
                          txid, (ub2)strlen((char *)txid),
                          &amp;src_time, cmtpos, cmtpos_len,
                          0, commit_lcr, OCI_DEFAULT));
 
  /* Send commit lcr to inbound server. */
  if (OCIXStreamInLCRSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, commit_lcr,
                          OCI_LCR_XROW, 0, OCI_DEFAULT) == OCI_ERROR)
  {
    ocierror(xin_ocip, (char *)"OCIXStreamInLCRSend failed in ping_svr()");
  }
}
 
/*---------------------------------------------------------------------
 * get_lcrs - Get LCRs from outbound server and send to inbound server.
 *---------------------------------------------------------------------*/
static void get_lcrs(oci_t *xin_ocip, oci_t *xout_ocip)
{
  sword       status = OCI_SUCCESS;
  void       *lcr;
  ub1         lcrtype;
  oraub8      flag;
  ub1         proclwm[OCI_LCR_MAX_POSITION_LEN];
  ub2         proclwm_len = 0;
  ub1         sv_pingpos[OCI_LCR_MAX_POSITION_LEN];
  ub2         sv_pingpos_len = 0;
  ub1         fetchlwm[OCI_LCR_MAX_POSITION_LEN];
  ub2         fetchlwm_len = 0;
  void       *commit_lcr = (void *)0;
  oratext    *lcr_srcdb = (oratext *)0;
  ub2         lcr_srcdb_len = 0;
  oratext     source_db[M_DBNAME_LEN];
  ub2         source_db_len = 0;
  ub4         lcrcnt = 0;
 
  /* create an lcr to ping the inbound server periodically by sending a
   * commit lcr.
   */
  commit_lcr = (void*)0;
  OCICALL(xin_ocip,
          OCILCRNew(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, OCI_DURATION_SESSION,
                    OCI_LCR_XROW, &amp;commit_lcr, OCI_DEFAULT));
 
  while (status == OCI_SUCCESS)
  {
    lcrcnt = 0;                         /* reset lcr count before each batch */
 
    while ((status = 
                OCIXStreamOutLCRReceive(xout_ocip-&gt;svcp, xout_ocip-&gt;errp,
                                        &amp;lcr, &amp;lcrtype, &amp;flag, 
                                        fetchlwm, &amp;fetchlwm_len, OCI_DEFAULT))
                                               == OCI_STILL_EXECUTING)
    {
      lcrcnt++;
 
      /* print header of LCR just received */
      print_lcr(xout_ocip, lcr, lcrtype, &amp;lcr_srcdb, &amp;lcr_srcdb_len);
 
      /* save the source db to construct ping lcr later */
      if (!source_db_len &amp;&amp; lcr_srcdb_len)
      {
        memcpy(source_db, lcr_srcdb, lcr_srcdb_len);
        source_db_len = lcr_srcdb_len;
      }
      
      /* send the LCR just received */
      if (OCIXStreamInLCRSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, 
                              lcr, lcrtype, flag, OCI_DEFAULT) == OCI_ERROR)
      {
        ocierror(xin_ocip, (char *)"OCIXStreamInLCRSend failed");
      }
 
      /* If LCR has chunked columns (i.e, has LOB/Long/XMLType columns) */
      if (flag &amp; OCI_XSTREAM_MORE_ROW_DATA)
      {
        /* receive and send chunked columns */
        get_chunks(xin_ocip, xout_ocip); 
      }
    }
 
    if (status == OCI_ERROR)
      ocierror(xout_ocip, (char *)"OCIXStreamOutLCRReceive failed");
 
    /* clear the saved ping position if we just received some new lcrs */
    if (lcrcnt)
    {
      sv_pingpos_len = 0;
    }
 
    /* If no lcrs received during previous WHILE loop and got a new fetch 
     * LWM then send a commit lcr to ping the inbound server with the new
     * fetch LWM position.
     */
    else if (fetchlwm_len &gt; 0 &amp;&amp; source_db_len &gt; 0 &amp;&amp;
        (fetchlwm_len != sv_pingpos_len ||
         memcmp(sv_pingpos, fetchlwm, fetchlwm_len))) 
    {
      /* To ensure we don't send multiple lcrs with duplicate position, send
       * a new ping only if we have saved the last ping position.
       */
      if (sv_pingpos_len &gt; 0)
      {     
        ping_svr(xin_ocip, commit_lcr, fetchlwm, fetchlwm_len,
                 source_db, source_db_len); 
      }
 
      /* save the position just sent to inbound server */
      memcpy(sv_pingpos, fetchlwm, fetchlwm_len);
      sv_pingpos_len = fetchlwm_len;
    }
 
    /* flush inbound network to flush all lcrs to inbound server */
    OCICALL(xin_ocip,
            OCIXStreamInFlush(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, OCI_DEFAULT));
 
    
    /* get processed LWM of inbound server */   
    OCICALL(xin_ocip, 
            OCIXStreamInProcessedLWMGet(xin_ocip-&gt;svcp, xin_ocip-&gt;errp,
                                        proclwm, &amp;proclwm_len, OCI_DEFAULT));
 
    if (proclwm_len &gt; 0)
    {
      /* Set processed LWM for outbound server */
      OCICALL(xout_ocip, 
              OCIXStreamOutProcessedLWMSet(xout_ocip-&gt;svcp, xout_ocip-&gt;errp, 
                                           proclwm, proclwm_len, OCI_DEFAULT));
    }
  }
  
  if (status != OCI_SUCCESS)
    ocierror(xout_ocip, (char *)"get_lcrs() encounters error");
}
 
/*---------------------------------------------------------------------
 * get_chunks - Get each chunk for the current LCR and send it to 
 *              the inbound server.
 *---------------------------------------------------------------------*/
static void get_chunks(oci_t *xin_ocip, oci_t *xout_ocip)
{
  oratext *colname;
  ub2      colname_len;
  ub2      coldty;
  oraub8   col_flags;
  ub2      col_csid;
  ub4      chunk_len;
  ub1     *chunk_ptr;
  oraub8   row_flag;
  sword    err;
  sb4      rtncode;
 
  do
  {
    /* Get a chunk from outbound server */
    OCICALL(xout_ocip,
            OCIXStreamOutChunkReceive(xout_ocip-&gt;svcp, xout_ocip-&gt;errp, 
                                      &amp;colname, &amp;colname_len, &amp;coldty, 
                                      &amp;col_flags, &amp;col_csid, &amp;chunk_len, 
                                      &amp;chunk_ptr, &amp;row_flag, OCI_DEFAULT));
   
    /* print chunked column info */
    printf(
     "  Chunked column name=%.*s DTY=%d  chunk len=%d csid=%d col_flag=0x%lx\n",
      colname_len, colname, coldty, chunk_len, col_csid, col_flags);
 
    /* print chunk data */
    print_chunk(chunk_ptr, chunk_len, coldty);
 
    /* Send the chunk just received to inbound server */
    OCICALL(xin_ocip,
            OCIXStreamInChunkSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, colname,
                                  colname_len, coldty, col_flags,
                                  col_csid, chunk_len, chunk_ptr,
                                  row_flag, OCI_DEFAULT));
 
  } while (row_flag &amp; OCI_XSTREAM_MORE_ROW_DATA);
}
 
/*---------------------------------------------------------------------
 * print_chunk - Print chunked column information. Only print the first
 *               50 bytes for each chunk.
 *---------------------------------------------------------------------*/
static void print_chunk (ub1 *chunk_ptr, ub4 chunk_len, ub2 dty)
{
#define MAX_PRINT_BYTES     (50)          /* print max of 50 bytes per chunk */
 
  ub4  print_bytes;
 
  if (chunk_len == 0)
    return;
 
  print_bytes = chunk_len &gt; MAX_PRINT_BYTES ? MAX_PRINT_BYTES : chunk_len;
 
  printf("  Data = ");
  if (dty == SQLT_CHR)
    printf("%.*s", print_bytes, chunk_ptr);
  else
  {
    ub2  idx;
 
    for (idx = 0; idx &lt; print_bytes; idx++)
      printf("%02x", chunk_ptr[idx]);
  }
  printf("\n");
}
 
/*---------------------------------------------------------------------
 * print_lcr - Print header information of given lcr.
 *---------------------------------------------------------------------*/
static void print_lcr(oci_t *ocip, void *lcrp, ub1 lcrtype, 
                      oratext **src_db_name, ub2  *src_db_namel)
{
  oratext     *cmd_type;
  ub2          cmd_type_len;
  oratext     *owner;
  ub2          ownerl;
  oratext     *oname;
  ub2          onamel;
  oratext     *txid;
  ub2          txidl;
  sword        ret;
 
  printf("\n ----------- %s LCR Header  -----------------\n",
         lcrtype == OCI_LCR_XDDL ? "DDL" : "ROW");
 
  /* Get LCR Header information */
  ret = OCILCRHeaderGet(ocip-&gt;svcp, ocip-&gt;errp, 
                        src_db_name, src_db_namel,              /* source db */
                        &amp;cmd_type, &amp;cmd_type_len,            /* command type */
                        &amp;owner, &amp;ownerl,                       /* owner name */
                        &amp;oname, &amp;onamel,                      /* object name */
                        (ub1 **)0, (ub2 *)0,                      /* lcr tag */
                        &amp;txid, &amp;txidl, (OCIDate *)0,   /* txn id  &amp; src time */
                        (ub2 *)0, (ub2 *)0,              /* OLD/NEW col cnts */
                        (ub1 **)0, (ub2 *)0,                 /* LCR position */
                        (oraub8*)0, lcrp, OCI_DEFAULT);
 
  if (ret != OCI_SUCCESS)
    ocierror(ocip, (char *)"OCILCRHeaderGet failed");
  else
  {
    printf("  src_db_name=%.*s\n  cmd_type=%.*s txid=%.*s\n",
           *src_db_namel, *src_db_name, cmd_type_len, cmd_type, txidl, txid );
 
    if (ownerl &gt; 0)
      printf("  owner=%.*s oname=%.*s \n", ownerl, owner, onamel, oname);
  } 
}
 
/*---------------------------------------------------------------------
 * detach - Detach from XStream server
 *---------------------------------------------------------------------*/
static void detach(oci_t * ocip)
{
  sword  err = OCI_SUCCESS;
 
  printf ("Detach from XStream %s server\n",
          ocip-&gt;outbound ? "outbound" : "inbound" );
 
  if (ocip-&gt;outbound)
  {
    OCICALL(ocip, OCIXStreamOutDetach(ocip-&gt;svcp, ocip-&gt;errp, OCI_DEFAULT));
  }
  else
  {
    OCICALL(ocip, OCIXStreamInDetach(ocip-&gt;svcp, ocip-&gt;errp, 
                                     (ub1 *)0, (ub2 *)0,    /* processed LWM */
                                     OCI_DEFAULT));
  }
}
 
/*---------------------------------------------------------------------
 * disconnect_db  - Logoff from the database
 *---------------------------------------------------------------------*/
static void disconnect_db(oci_t * ocip)
{
  if (OCILogoff(ocip-&gt;svcp, ocip-&gt;errp))
  {
    ocierror(ocip, (char *)"OCILogoff() failed");
  }
 
  if (ocip-&gt;errp)
    OCIHandleFree((dvoid *) ocip-&gt;errp, (ub4) OCI_HTYPE_ERROR);
 
  if (ocip-&gt;envp)
    OCIHandleFree((dvoid *) ocip-&gt;envp, (ub4) OCI_HTYPE_ENV);
}
 
/*---------------------------------------------------------------------
 * ocierror - Print error status and exit program
 *---------------------------------------------------------------------*/
static void ocierror(oci_t * ocip, char * msg)
{
  sb4 errcode=0;
  text bufp[4096];
 
  if (ocip-&gt;errp)
  {
    OCIErrorGet((dvoid *) ocip-&gt;errp, (ub4) 1, (text *) NULL, &amp;errcode,
                bufp, (ub4) 4096, (ub4) OCI_HTYPE_ERROR);
    printf("%s\n%s", msg, bufp);
  }
  else
    puts(msg);
 
  printf ("\n");
  exit(1);
}
 
/*--------------------------------------------------------------------
 * print_usage - Print command usage
 *---------------------------------------------------------------------*/
static void print_usage(int exitcode)
{
  puts("\nUsage: xio -ob_svr &lt;outbound_svr&gt; -ob_db &lt;outbound_db&gt;\n" 
         "           -ob_usr &lt;conn_user&gt; -ob_pwd &lt;conn_user_pwd&gt;\n" 
         "           -ib_svr &lt;inbound_svr&gt; -ib_db &lt;inbound_db&gt;\n"
         "           -ib_usr &lt;apply_user&gt; -ib_pwd &lt;apply_user_pwd&gt;\n");
  puts("  ob_svr  : outbound server name\n"
       "  ob_db   : database name of outbound server\n"
       "  ob_usr  : connect user to outbound server\n"
       "  ob_pwd  : password of outbound's connect user\n"
       "  ib_svr  : inbound server name\n"
       "  ib_db   : database name of inbound server\n"
       "  ib_usr  : apply user for inbound server\n"
       "  ib_pwd  : password of inbound's apply user\n");
 
  exit(exitcode);
}
 
/*--------------------------------------------------------------------
 * get_inputs - Get user inputs from command line
 *---------------------------------------------------------------------*/
static void get_inputs(conn_info_t *xout_params, conn_info_t *xin_params, 
                       int argc, char ** argv)
{
  char * option;
  char * value;
 
  memset (xout_params, 0, sizeof(*xout_params));
  memset (xin_params, 0, sizeof(*xin_params));
  while(--argc)
  {
    /* get the option name */
    argv++;
    option = *argv;
 
    /* check that the option begins with a "-" */
    if (!strncmp(option, (char *)"-", 1))
    {
      option ++;
    }
    else
    {
      printf("Error: bad argument '%s'\n", option);
      print_usage(1);
    }
 
    /* get the value of the option */
    --argc;
    argv++;
 
    value = *argv;    
 
    if (!strncmp(option, (char *)"ob_db", 5))
    {
      xout_params-&gt;dbname = (oratext *)value;
      xout_params-&gt;dbnamelen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)"ob_usr", 6))
    {
      xout_params-&gt;user = (oratext *)value;
      xout_params-&gt;userlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)"ob_pwd", 6))
    {
      xout_params-&gt;passw = (oratext *)value;
      xout_params-&gt;passwlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)"ob_svr", 6))
    {
      xout_params-&gt;svrnm = (oratext *)value;
      xout_params-&gt;svrnmlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_db", 5))
    {
      xin_params-&gt;dbname = (oratext *)value;
      xin_params-&gt;dbnamelen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_usr", 6))
    {
      xin_params-&gt;user = (oratext *)value;
      xin_params-&gt;userlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_pwd", 6))
    {
      xin_params-&gt;passw = (oratext *)value;
      xin_params-&gt;passwlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_svr", 6))
    {
      xin_params-&gt;svrnm = (oratext *)value;
      xin_params-&gt;svrnmlen = (ub4)strlen(value);
    }
    else
    {
      printf("Error: unknown option '%s'.\n", option);
      print_usage(1);
    }
  }
 
  /* print usage and exit if any argument is not specified */
  if (!xout_params-&gt;svrnmlen || !xout_params-&gt;passwlen || 
      !xout_params-&gt;userlen || !xout_params-&gt;dbnamelen ||
      !xin_params-&gt;svrnmlen || !xin_params-&gt;passwlen || 
      !xin_params-&gt;userlen || !xin_params-&gt;dbnamelen)
  {
    printf("Error: missing command arguments. \n");
    print_usage(1);
  }
}</pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sample-xstream-client-application.html#GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" title="示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。">示例XStream客户端应用程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="XSTRM1570"></a><div class="props_rev_3"><a id="GUID-952CEB45-9E0D-49AE-853A-912524B49853" name="GUID-952CEB45-9E0D-49AE-853A-912524B49853"></a><h3 id="XSTRM-GUID-952CEB45-9E0D-49AE-853A-912524B49853" class="sect3"><span class="enumeration_section">A.3</span> Java API的示例XStream客户端应用程序</h3>
               <div>
                  <p>要为Java API运行示例XStream客户端应用程序，请编译并链接应用程序文件。</p>
                  <p>接下来，在命令行中输入以下内容：</p><pre class="oac_no_warn" dir="ltr">java xio <span class="italic">xsin_oraclesid</span> <span class="italic">xsin_host</span> <span class="italic">xsin_port</span> <span class="italic">xsin_username</span> 
<span class="italic">xsin_passwd</span> <span class="italic">xin_servername</span> <span class="italic">xsout_oraclesid</span> <span class="italic">xsout_host</span> <span class="italic">xsout_port</span> 
<span class="italic">xsout_username</span> <span class="italic">xsout_passwd</span> <span class="italic">xsout_servername</span>
</pre><p>替换以下占位符的适当值：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="italic">xsin_oraclesid</span>是入站服务器数据库的Oracle SID。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_host</span>是运行入站服务器的计算机系统的主机名。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_port</span>是入站服务器数据库的侦听器的端口号。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_username</span>是入站服务器的应用用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_passwd</span>是入站服务器的应用用户的密码。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_servername</span>是入站服务器的名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_oraclesid</span>是出站服务器数据库的Oracle SID。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_host</span>是运行出站服务器的计算机系统的主机名。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_port</span>是出站服务器数据库的侦听器的端口号。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_username</span>是出站服务器的连接用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_passwd</span>是出站服务器的连接用户的密码。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_servername</span>是出站服务器的名称。
                        </p>
                     </li>
                  </ul>
                  <p>示例客户端应用程序运行时，它会打印有关附加到入站服务器和出站服务器的信息，以及每个服务器的最后位置。输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">xsin_host = server2.example.com
xsin_port = 1482
xsin_ora_sid = db2
xsin connection url: jdbc:oracle:oci:@server2.example.com:1482:db2
xsout_host = server1.example.com
xsout_port = 1481
xsout_ora_sid = db1
xsout connection url: jdbc:oracle:oci:@server1.example.com:1481:db1
Attached to inbound server:xin
Inbound Server Last Position is: 0000000920250000000100000001000000092025000000010000000101
Attached to outbound server:xout
Last Position is: 0000000920250000000100000001000000092025000000010000000101
</pre><p>此演示位于以下位置：</p><pre class="oac_no_warn" dir="ltr">$ORACLE_HOME/rdbms/demo/xstream/java
</pre><p>该演示的文件名是<code class="codeph">xio.java</code> 。有关编译和运行应用程序的更多信息，请参阅演示目录中的<code class="codeph">README.txt</code>文件。
                  </p>
                  <p>使用Java API的示例应用程序的代码如下：</p><pre class="oac_no_warn" dir="ltr">import oracle.streams.*;
import oracle.jdbc.internal.OracleConnection;
import oracle.jdbc.*;
import oracle.sql.*;
import java.sql.*;
import java.util.*;
 
public class xio
{
  public static String xsinusername = null;
  public static String xsinpasswd = null;
  public static String xsinName = null;
  public static String xsoutusername = null;
  public static String xsoutpasswd = null;
  public static String xsoutName = null;
  public static String in_url = null;
  public static String out_url = null;
  public static Connection in_conn = null;
  public static Connection out_conn = null;
  public static XStreamIn xsIn = null;
  public static XStreamOut xsOut = null;
  public static byte[] lastPosition = null;
  public static byte[] processedLowPosition = null;
    
  public static void main(String args[])
  {
    // get connection url to inbound and outbound server
    in_url = parseXSInArguments(args);    
    out_url = parseXSOutArguments(args);    
 
    // create connection to inbound and outbound server
    in_conn = createConnection(in_url, xsinusername, xsinpasswd);
    out_conn = createConnection(out_url, xsoutusername, xsoutpasswd);
 
    // attach to inbound and outbound server
    xsIn = attachInbound(in_conn);
    xsOut = attachOutbound(out_conn);
    
    // main loop to get lcrs 
    get_lcrs(xsIn, xsOut);
    
    // detach from inbound and outbound server
    detachInbound(xsIn);
    detachOutbound(xsOut);
  }
    
  // parse the arguments to get the conncetion url to inbound db
  public static String parseXSInArguments(String args[])
  {
    String trace, pref;
    String orasid, host, port;
    
    if (args.length != 12)
    {
      printUsage();
      System.exit(0);
    }
 
    orasid = args[0];
    host = args[1];
    port = args[2];
    xsinusername = args[3];
    xsinpasswd = args[4];
    xsinName = args[5];
    
    System.out.println("xsin_host = "+host);
    System.out.println("xsin_port = "+port);
    System.out.println("xsin_ora_sid = "+orasid);
 
    String in_url = "jdbc:oracle:oci:@"+host+":"+port+":"+orasid;
    System.out.println("xsin connection url: "+ in_url);
 
    return in_url;
  }
 
  // parse the arguments to get the conncetion url to outbound db
  public static String parseXSOutArguments(String args[])
  {
    String trace, pref;
    String orasid, host, port;
    
    if (args.length != 12)
    {
      printUsage();
      System.exit(0);
    }
 
    orasid = args[6];
    host = args[7];
    port = args[8];
    xsoutusername = args[9];
    xsoutpasswd = args[10];
    xsoutName = args[11];
    
    
    System.out.println("xsout_host = "+host);
    System.out.println("xsout_port = "+port);
    System.out.println("xsout_ora_sid = "+orasid);
 
    String out_url = "jdbc:oracle:oci:@"+host+":"+port+":"+orasid;
    System.out.println("xsout connection url: "+ out_url);
 
    return out_url;
  }
 
  // print out sample program usage message
  public static void printUsage()
  {
    System.out.println("");      
    System.out.println("Usage: java xio "+"&lt;xsin_oraclesid&gt; " + "&lt;xsin_host&gt; "
                                         + "&lt;xsin_port&gt; ");
    System.out.println("                "+"&lt;xsin_username&gt; " + "&lt;xsin_passwd&gt; "
                                         + "&lt;xsin_servername&gt; ");
    System.out.println("                "+"&lt;xsout_oraclesid&gt; " + "&lt;xsout_host&gt; "
                                         + "&lt;xsout_port&gt; ");
    System.out.println("                "+"&lt;xsout_username&gt; " + "&lt;xsout_passwd&gt; "
                                         + "&lt;xsout_servername&gt; ");
  }
 
  // create a connection to an Oracle Database
  public static Connection createConnection(String url, 
                                            String username, 
                                            String passwd)
  {
    try
    {
      DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
      return DriverManager.getConnection(url, username, passwd);
    }
    catch(Exception e)
    {
      System.out.println("fail to establish DB connection to: " +url);
      e.printStackTrace();
      return null;
    }
  }
 
  // attach to the XStream Inbound Server
  public static XStreamIn attachInbound(Connection in_conn)
  {
    XStreamIn xsIn = null;
    try
    {
      xsIn = XStreamIn.attach((OracleConnection)in_conn, xsinName,
                              "XSDEMOINCLIENT" , XStreamIn.DEFAULT_MODE);
 
      // use last position to decide where should we start sending LCRs  
      lastPosition = xsIn.getLastPosition();
      System.out.println("Attached to inbound server:"+xsinName);
      System.out.print("Inbound Server Last Position is: ");
      if (null == lastPosition)
      {
        System.out.println("null");
      }
      else
      {
        printHex(lastPosition);
      }
      return xsIn;
    }
    catch(Exception e)
    {
      System.out.println("cannot attach to inbound server: "+xsinName);
      System.out.println(e.getMessage());
      e.printStackTrace();
      return null;
    }        
  }
 
  // attach to the XStream Outbound Server    
  public static XStreamOut attachOutbound(Connection out_conn)
  {
    XStreamOut xsOut = null;
 
    try
    {
      // when attach to an outbound server, client needs to tell outbound
      // server the last position.
      xsOut = XStreamOut.attach((OracleConnection)out_conn, xsoutName,
                                lastPosition, XStreamOut.DEFAULT_MODE);
      System.out.println("Attached to outbound server:"+xsoutName);
      System.out.print("Last Position is: ");  
      if (lastPosition != null)
      {
        printHex(lastPosition);
      }
      else
      {
        System.out.println("NULL");
      }
      return xsOut;
    }
    catch(Exception e)
    {
      System.out.println("cannot attach to outbound server: "+xsoutName);
      System.out.println(e.getMessage());
      e.printStackTrace();
      return null;
    } 
  }
 
  // detach from the XStream Inbound Server
  public static void detachInbound(XStreamIn xsIn)
  {
    byte[] processedLowPosition = null;
    try
    {
      processedLowPosition = xsIn.detach(XStreamIn.DEFAULT_MODE);
      System.out.print("Inbound server processed low Position is: ");
      if (processedLowPosition != null)
      {
        printHex(processedLowPosition);
      }
      else
      {
        System.out.println("NULL");
      }
    }
    catch(Exception e)
    {
      System.out.println("cannot detach from the inbound server: "+xsinName);
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
 
  // detach from the XStream Outbound Server    
  public static void detachOutbound(XStreamOut xsOut)
  {
    try
    {
      xsOut.detach(XStreamOut.DEFAULT_MODE);
    }
    catch(Exception e)
    {
      System.out.println("cannot detach from the outbound server: "+xsoutName);
      System.out.println(e.getMessage());
      e.printStackTrace();
    }       
  }
 
  public static void get_lcrs(XStreamIn xsIn, XStreamOut xsOut)
  {
    if (null == xsIn) 
    {
      System.out.println("xstreamIn is null");
      System.exit(0);
    }
 
    if (null == xsOut)
    {
      System.out.println("xstreamOut is null");
      System.exit(0);
    }
 
    try
    {
      while(true) 
      {
        // receive an LCR from outbound server
        LCR alcr = xsOut.receiveLCR(XStreamOut.DEFAULT_MODE);
 
        if (xsOut.getBatchStatus() == XStreamOut.EXECUTING) // batch is active
        {
          assert alcr != null;
          // send the LCR to the inbound server
          xsIn.sendLCR(alcr, XStreamIn.DEFAULT_MODE);
 
          // also get chunk data for this LCR if any
          if (alcr instanceof RowLCR)
          {
            // receive chunk from outbound then send to inbound
            if (((RowLCR)alcr).hasChunkData())
            {
              ChunkColumnValue chunk = null; 
              do
              {
                chunk = xsOut.receiveChunk(XStreamOut.DEFAULT_MODE);
                xsIn.sendChunk(chunk, XStreamIn.DEFAULT_MODE);
              } while (!chunk.isEndOfRow());
            }
          }
          processedLowPosition = alcr.getPosition();
        }
        else  // batch is end 
        {
          assert alcr == null;
          // flush the network
          xsIn.flush(XStreamIn.DEFAULT_MODE);
          // get the processed_low_position from inbound server
          processedLowPosition = 
              xsIn.getProcessedLowWatermark();
          // update the processed_low_position at oubound server
          if (null != processedLowPosition)
            xsOut.setProcessedLowWatermark(processedLowPosition, 
                                           XStreamOut.DEFAULT_MODE);
        }
      }
    }
    catch(Exception e)
    {
      System.out.println("exception when processing LCRs");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
 
  public static void printHex(byte[] b) 
  {
    for (int i = 0; i &lt; b.length; ++i) 
    {
      System.out.print(
        Integer.toHexString((b[i]&amp;0xFF) | 0x100).substring(1,3));
    }
    System.out.println("");
  }    
}</pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sample-xstream-client-application.html#GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" title="示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。">示例XStream客户端应用程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>