<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>使用可扩展索引</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQL Language Reference ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQL Language Reference">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sql-language-reference.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-12T15:36:36-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96310-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="Extended-Examples.html" title="Previous" type="text/html">
      <link rel="next" href="Using-XML-in-SQL-Statements.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQL Language Reference">
    <meta name="dcterms.isVersionOf" content="SQLRF">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Extended-Examples.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Using-XML-in-SQL-Statements.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL语言参考</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="Extended-Examples.html" property="item" typeof="WebPage"><span property="name">扩展示例</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用可扩展索引</li>
            </ol>
            <a id="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665" name="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665"></a><a id="SQLRF55547"></a>
            
            <h2 id="SQLRF-GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665" class="sect2">使用可扩展索引</h2>
         </header>
         <div class="ind">
            <div>
               <div class="section">
                  <p>本节提供了简单但实际可扩展索引方案中所需步骤的示例。</p>
                  <p>假设您要对<code class="codeph">HR.employees</code>表中的工资进行排名，然后找到排名在10到20之间的工资。您可以使用<code class="codeph">DENSE_RANK</code>函数，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT last_name, salary FROM
   (SELECT last_name, DENSE_RANK() OVER
      (ORDER BY salary DESC) rank_val, salary FROM employees)
   WHERE rank_val BETWEEN 10 AND 20;</pre><div class="infoboxnotealso" id="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665__GUID-AB15C6BA-D219-439C-8875-6F03E69150A2">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="DENSE_RANK.html#GUID-BB66F574-09DF-4594-87A4-ABD83E8DC3FE">DENSE_RANK</a></p>
                  </div>
                  <p>这种嵌套查询有点复杂，它需要完整扫描<code class="codeph">employees</code>表以及排序。另一种方法是使用可扩展索引来实现相同的目标。生成的查询将更简单。该查询将仅需要索引扫描和rowid的表访问，因此将更有效地执行。
                  </p>
                  <p>第一步是创建实现类型<code class="codeph">position_im</code> ，包括索引定义，维护和创建的方法头。大多数类型的主体都使用PL / SQL，它以斜体显示。
                  </p>
                  <p>由于函数<code class="codeph">ODCIINDEXCREATE()</code>内部的<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句，必须使用<code class="codeph">AUTHID</code> <code class="codeph">CURRENT_USER</code>子句创建该类型。默认情况下，该函数使用定义者权限运行。在后续创建域索引中调用该函数时，调用者不具有相同的权限。
                  </p>
                  <div class="infoboxnotealso" id="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665__GUID-61E9C19B-87B0-412B-A25D-FA127E26CE53">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="CREATE-TYPE.html#GUID-E72E3EE6-DE95-4F58-8941-E2F76D0EAE80">CREATE TYPE</a>和<a href="CREATE-TYPE-BODY.html#GUID-C4F1591A-6F62-4897-9039-2C3F066F1E9D">CREATE TYPE BODY</a></p>
                        </li>
                        <li>
                           <p><a href="../addci/extensible-indexing-interface.html#ADDCI4200" target="_blank"><span class="italic">Oracle数据库数据盒开发人员指南</span></a> ，了解本声明中有关ODCI例程的完整信息</p>
                        </li>
                     </ul>
                  </div><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE position_im AUTHID CURRENT_USER AS OBJECT
(
  curnum  NUMBER,
  howmany NUMBER,
  lower_bound NUMBER,  
  upper_bound NUMBER,  
/* lower_bound and upper_bound are used for the
index-based functional implementation */
  STATIC FUNCTION ODCIGETINTERFACES(ifclist OUT SYS.ODCIOBJECTLIST) RETURN NUMBER, 
  STATIC FUNCTION ODCIINDEXCREATE 
    (ia SYS.ODCIINDEXINFO, parms VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIINDEXTRUNCATE (ia SYS.ODCIINDEXINFO,
                                     env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIINDEXDROP(ia SYS.ODCIINDEXINFO, 
                                env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIINDEXINSERT(ia SYS.ODCIINDEXINFO, rid ROWID,
                                  newval NUMBER, env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIINDEXDELETE(ia SYS.ODCIINDEXINFO, rid ROWID, oldval NUMBER,
                                  env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIINDEXUPDATE(ia SYS.ODCIINDEXINFO, rid ROWID, oldval NUMBER,
                                  newval NUMBER, env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIINDEXSTART(SCTX IN OUT position_im, ia SYS.ODCIINDEXINFO,
                                 op SYS.ODCIPREDINFO, qi SYS.ODCIQUERYINFO,
                                 strt NUMBER, stop NUMBER, lower_pos NUMBER,
                                 upper_pos NUMBER, env SYS.ODCIEnv) RETURN NUMBER,
  MEMBER FUNCTION ODCIINDEXFETCH(SELF IN OUT position_im, nrows NUMBER, 
                                 rids OUT SYS.ODCIRIDLIST, env SYS.ODCIEnv) 
                                 RETURN NUMBER,
  MEMBER FUNCTION ODCIINDEXCLOSE(env SYS.ODCIEnv) RETURN NUMBER
);
/

CREATE OR REPLACE TYPE BODY position_im
IS
   STATIC FUNCTION ODCIGETINTERFACES(ifclist OUT SYS.ODCIOBJECTLIST)
       RETURN NUMBER IS
   BEGIN
       ifclist := SYS.ODCIOBJECTLIST(SYS.ODCIOBJECT('SYS','ODCIINDEX2'));
       RETURN ODCICONST.SUCCESS;
   END ODCIGETINTERFACES;
 STATIC FUNCTION ODCIINDEXCREATE (ia SYS.ODCIINDEXINFO, parms VARCHAR2, env SYS.ODCIEnv) RETURN
 NUMBER
  IS
   stmt   VARCHAR2(2000);
  BEGIN
/* Construct the SQL statement */
   stmt := 'Create Table ' || ia.INDEXSCHEMA || '.' || ia.INDEXNAME ||
           '_STORAGE_TAB' || '(col_val, base_rowid, constraint pk PRIMARY KEY ' ||
           '(col_val, base_rowid)) ORGANIZATION INDEX AS SELECT ' ||
           ia.INDEXCOLS(1).COLNAME || ', ROWID FROM ' || 
           ia.INDEXCOLS(1).TABLESCHEMA || '.' || ia.INDEXCOLS(1).TABLENAME;
   EXECUTE IMMEDIATE stmt;
   RETURN ODCICONST.SUCCESS;
  END;
  STATIC FUNCTION ODCIINDEXDROP(ia SYS.ODCIINDEXINFO, env SYS.ODCIEnv) RETURN NUMBER IS
   stmt VARCHAR2(2000);
  BEGIN
/* Construct the SQL statement */
   stmt := 'DROP TABLE ' || ia.INDEXSCHEMA || '.' || ia.INDEXNAME ||
   '_STORAGE_TAB';
/* Execute the statement */
   EXECUTE IMMEDIATE stmt;
   RETURN ODCICONST.SUCCESS;
  END;
  STATIC FUNCTION ODCIINDEXTRUNCATE(ia SYS.ODCIINDEXINFO, env SYS.ODCIEnv) RETURN NUMBER IS
   stmt VARCHAR2(2000);
  BEGIN
/* Construct the SQL statement */
   stmt := 'TRUNCATE TABLE ' || ia.INDEXSCHEMA || '.' || ia.INDEXNAME || '_STORAGE_TAB';
   
   EXECUTE IMMEDIATE stmt;
   RETURN ODCICONST.SUCCESS;
  END;
  STATIC FUNCTION ODCIINDEXINSERT(ia SYS.ODCIINDEXINFO, rid ROWID,
                          newval NUMBER, env SYS.ODCIEnv) RETURN NUMBER IS
   stmt VARCHAR2(2000);
  BEGIN
/* Construct the SQL statement */
   stmt := 'INSERT INTO ' || ia.INDEXSCHEMA || '.' || ia.INDEXNAME || 
          '_STORAGE_TAB  VALUES (''' || newval || ''' , ''' || rid || ''' )';
/* Execute the SQL statement */
   EXECUTE IMMEDIATE stmt;
   RETURN ODCICONST.SUCCESS;
  END;
  
  STATIC FUNCTION ODCIINDEXDELETE(ia SYS.ODCIINDEXINFO, rid ROWID, oldval NUMBER,
                                  env SYS.ODCIEnv)
     RETURN NUMBER IS
   stmt VARCHAR2(2000);
  BEGIN
/* Construct the SQL statement */
   stmt := 'DELETE FROM ' || ia.INDEXSCHEMA || '.' || ia.INDEXNAME || 
          '_STORAGE_TAB WHERE col_val = ''' || oldval || ''' AND base_rowid = ''' || rid || '''';
/* Execute the statement */
   EXECUTE IMMEDIATE stmt;
   RETURN ODCICONST.SUCCESS;
  END;
  STATIC FUNCTION ODCIINDEXUPDATE(ia SYS.ODCIINDEXINFO, rid ROWID, oldval NUMBER,
                          newval NUMBER, env SYS.ODCIEnv) RETURN NUMBER IS 
   stmt VARCHAR2(2000);
  BEGIN
/* Construct the SQL statement */
   stmt := 'UPDATE ' || ia.INDEXSCHEMA || '.' || ia.INDEXNAME || 
          '_STORAGE_TAB SET col_val = ''' || newval || ''' WHERE f2 = '''|| rid ||'''';
/* Execute the statement */
   EXECUTE IMMEDIATE stmt;
   RETURN ODCICONST.SUCCESS;
  END;
  STATIC FUNCTION ODCIINDEXSTART(SCTX IN OUT position_im, ia SYS.ODCIINDEXINFO,
                         op SYS.ODCIPREDINFO, qi SYS.ODCIQUERYINFO,
                         strt NUMBER, stop NUMBER, lower_pos NUMBER,
                         upper_pos NUMBER, env SYS.ODCIEnv) RETURN NUMBER IS
    rid              VARCHAR2(5072);
    storage_tab_name VARCHAR2(65);
    lower_bound_stmt VARCHAR2(2000);
    upper_bound_stmt VARCHAR2(2000);
    range_query_stmt VARCHAR2(2000);
    lower_bound      NUMBER;
    upper_bound      NUMBER;
    cnum             INTEGER;
    nrows            INTEGER;
    
  BEGIN
/* Take care of some error cases.
    The only predicates in which position operator can appear are
       op() = 1     OR
       op() = 0     OR
       op() between 0 and 1 
*/
    IF (((strt != 1) AND (strt != 0)) OR
        ((stop != 1) AND (stop != 0)) OR
        ((strt = 1) AND (stop = 0))) THEN
      RAISE_APPLICATION_ERROR(-20101, 
                              'incorrect predicate for position_between operator');
    END IF;
    IF (lower_pos &gt; upper_pos) THEN
      RAISE_APPLICATION_ERROR(-20101, 'Upper Position must be greater than or
      equal to Lower Position');
    END IF;
    IF (lower_pos &lt;= 0) THEN
      RAISE_APPLICATION_ERROR(-20101, 'Both Positions must be greater than zero');
    END IF;
    storage_tab_name := ia.INDEXSCHEMA || '.' || ia.INDEXNAME ||
                        '_STORAGE_TAB';
    upper_bound_stmt := 'Select MIN(col_val) FROM (Select /*+ INDEX_DESC(' ||
                        storage_tab_name || ') */ DISTINCT ' ||
                        'col_val FROM ' || storage_tab_name || ' ORDER BY ' ||
                        'col_val DESC) WHERE rownum &lt;= ' || lower_pos;
    EXECUTE IMMEDIATE upper_bound_stmt INTO upper_bound;
    IF (lower_pos != upper_pos) THEN
      lower_bound_stmt := 'Select MIN(col_val) FROM (Select /*+ INDEX_DESC(' || 
                          storage_tab_name || ') */ DISTINCT ' ||
                          'col_val FROM ' || storage_tab_name ||
                          ' WHERE col_val &lt; ' || upper_bound || ' ORDER BY ' ||
                          'col_val DESC) WHERE rownum &lt;= ' || 
                          (upper_pos - lower_pos);
      EXECUTE IMMEDIATE lower_bound_stmt INTO lower_bound;
    ELSE
      lower_bound := upper_bound;
    END IF;
    IF (lower_bound IS NULL) THEN
      lower_bound := upper_bound;
    END IF;
    range_query_stmt := 'Select base_rowid FROM ' || storage_tab_name ||
                        ' WHERE col_val BETWEEN ' || lower_bound || ' AND ' ||
                        upper_bound;
    cnum := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(cnum, range_query_stmt, DBMS_SQL.NATIVE);
/* set context as the cursor number */
    SCTX := position_im(cnum, 0, 0, 0);
/* return success */
    RETURN ODCICONST.SUCCESS;
  END;
  MEMBER FUNCTION ODCIINDEXFETCH(SELF IN OUT position_im, nrows NUMBER,
                                 rids OUT SYS.ODCIRIDLIST, env SYS.ODCIEnv)
   RETURN NUMBER IS
    cnum    INTEGER;
    rid_tab DBMS_SQL.Varchar2_table;
    rlist   SYS.ODCIRIDLIST := SYS.ODCIRIDLIST();
    i       INTEGER;
    d       INTEGER;
  BEGIN
    cnum := SELF.curnum;
    IF self.howmany = 0 THEN
      dbms_sql.define_array(cnum, 1, rid_tab, nrows, 1);
      d := DBMS_SQL.EXECUTE(cnum);
    END IF;
    d := DBMS_SQL.FETCH_ROWS(cnum);
    IF d = nrows THEN
      rlist.extend(d);
    ELSE
      rlist.extend(d+1);
    END IF;
    DBMS_SQL.COLUMN_VALUE(cnum, 1, rid_tab);
    for i in 1..d loop
      rlist(i) := rid_tab(i+SELF.howmany);
    end loop;
    SELF.howmany := SELF.howmany + d;
    rids := rlist;
    RETURN ODCICONST.SUCCESS;
  END;
  MEMBER FUNCTION ODCIINDEXCLOSE(env SYS.ODCIEnv) RETURN NUMBER IS
    cnum INTEGER;
  BEGIN
    cnum := SELF.curnum;
    DBMS_SQL.CLOSE_CURSOR(cnum);
    RETURN ODCICONST.SUCCESS;
  END;
END;
/</pre><p>下一步是为将与indextype关联的运算符创建函数实现<code class="codeph">function_for_position_between</code> 。（PL / SQL块显示在括号中。）
                  </p>
                  <p>此函数用于基于索引的函数评估。因此，它将索引上下文和扫描上下文作为参数。</p>
                  <div class="infoboxnotealso" id="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665__GUID-FF7FAE42-58D1-490F-A3BA-E1878CD8C3F1">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../addci/extensible-indexing-interface.html#ADDCI4200" target="_blank"><span class="italic">Oracle数据库数据盒开发人员指南</span></a> ，了解有关创建基于索引的功能实现的信息</p>
                        </li>
                        <li>
                           <p><a href="CREATE-FUNCTION.html#GUID-156AEDAC-ADD0-4E46-AA56-6D1F7CA63306">CREATE FUNCTION</a>和<a href="../lnpls/function-declaration-and-definition.html#LNPLS01322" target="_blank"><span class="italic">Oracle Database PL / SQL语言参考</span></a></p>
                        </li>
                     </ul>
                  </div><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE FUNCTION function_for_position_between
                           (col NUMBER, lower_pos NUMBER, upper_pos NUMBER,
                            indexctx IN SYS.ODCIIndexCtx,
                            scanctx IN OUT position_im,
                            scanflg IN NUMBER)
RETURN NUMBER AS
  rid              ROWID;
  storage_tab_name VARCHAR2(65);
  lower_bound_stmt VARCHAR2(2000);
  upper_bound_stmt VARCHAR2(2000);
  col_val_stmt     VARCHAR2(2000);
  lower_bound      NUMBER;
  upper_bound      NUMBER;
  column_value     NUMBER;
BEGIN
  IF (indexctx.IndexInfo IS NOT NULL) THEN
    storage_tab_name := indexctx.IndexInfo.INDEXSCHEMA || '.' ||
                        indexctx.IndexInfo.INDEXNAME || '_STORAGE_TAB';
    IF (scanctx IS NULL) THEN
/* This is the first call. Open a cursor for future calls.
   First, do some error checking
*/
      IF (lower_pos &gt; upper_pos) THEN
        RAISE_APPLICATION_ERROR(-20101,
          'Upper Position must be greater than or equal to Lower Position');
      END IF;
      IF (lower_pos &lt;= 0) THEN
        RAISE_APPLICATION_ERROR(-20101,
          'Both Positions must be greater than zero');
      END IF;
/* Obtain the upper and lower value bounds for the range we're interested in.
*/
      upper_bound_stmt := 'Select MIN(col_val) FROM (Select /*+ INDEX_DESC(' ||
                        storage_tab_name || ') */ DISTINCT ' ||
                        'col_val FROM ' || storage_tab_name || ' ORDER BY ' ||
                        'col_val DESC) WHERE rownum &lt;= ' || lower_pos;
      EXECUTE IMMEDIATE upper_bound_stmt INTO upper_bound;
      IF (lower_pos != upper_pos) THEN
        lower_bound_stmt := 'Select MIN(col_val) FROM (Select /*+ INDEX_DESC(' ||
                            storage_tab_name || ') */ DISTINCT ' ||
                            'col_val FROM ' || storage_tab_name ||
                            ' WHERE col_val &lt; ' || upper_bound || ' ORDER BY ' ||
                            'col_val DESC) WHERE rownum &lt;= ' ||
                            (upper_pos - lower_pos);
        EXECUTE IMMEDIATE lower_bound_stmt INTO lower_bound;
      ELSE
        lower_bound := upper_bound;
      END IF;
      IF (lower_bound IS NULL) THEN
        lower_bound := upper_bound;
      END IF;
/* Store the lower and upper bounds for future function invocations for
   the positions.
*/
      scanctx := position_im(0, 0, lower_bound, upper_bound);
    END IF;
/* Fetch the column value corresponding to the rowid, and see if it falls
   within the determined range.
*/
    col_val_stmt := 'Select col_val FROM ' || storage_tab_name ||
                    ' WHERE base_rowid = ''' || indexctx.Rid || '''';
    EXECUTE IMMEDIATE col_val_stmt INTO column_value;
    IF (column_value &lt;= scanctx.upper_bound AND
        column_value &gt;= scanctx.lower_bound AND
        scanflg = ODCICONST.RegularCall) THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  ELSE
    RAISE_APPLICATION_ERROR(-20101, 'A column that has a domain index of' ||
                            'Position indextype must be the first argument');
  END IF;
END;
/
</pre><p>接下来，创建<code class="codeph">position_between</code>运算符，该运算符使用<code class="codeph">function_for_position_between</code>函数。运算符将索引的<code class="codeph">NUMBER</code>列作为第一个参数，后跟<code class="codeph">NUMBER</code>下限和上限作为第二个和第三个参数。
                  </p>
                  <div class="infoboxnotealso" id="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665__GUID-83E3248D-E259-439E-B9FA-555CD489EACF">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="CREATE-OPERATOR.html#GUID-62676C58-6F57-4572-8C09-7984A8E3EE9F">创建运营商</a></p>
                  </div><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE OPERATOR position_between
   BINDING (NUMBER, NUMBER, NUMBER) RETURN NUMBER 
   WITH INDEX CONTEXT, SCAN CONTEXT position_im
   USING function_for_position_between;
</pre><p>在此<code class="codeph">CREATE</code> <code class="codeph">OPERATOR</code>语句中，包含<code class="codeph">WITH</code> <code class="codeph">INDEX</code> <code class="codeph">CONTEXT</code> ， <code class="codeph">SCAN</code> <code class="codeph">CONTEXT</code> <code class="codeph">position_im</code>子句，以便将索引上下文和扫描上下文传递到基于索引的功能评估。
                  </p>
                  <p>现在创建<code class="codeph">position_indextype</code>为INDEXTYPE <code class="codeph">position_operator</code> ：</p>
                  <div class="infoboxnotealso" id="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665__GUID-E0C9E79F-1D27-4DB5-AC07-DF6E478FFDE1">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="CREATE-INDEXTYPE.html#GUID-4A7BD0EC-B3E5-4D1D-95C5-C8B52D01D8CE">CREATE INDEXTYPE</a></p>
                  </div><pre class="oac_no_warn" dir="ltr">CREATE INDEXTYPE position_indextype
   FOR position_between(NUMBER, NUMBER, NUMBER)
   USING position_im;</pre><pre class="oac_no_warn" dir="ltr"></pre><p>运算符<code class="codeph">position_between</code>使用基于索引的功能实现。因此，必须在引用的列上定义域索引，以便可以将索引信息传递到功能评估中。所以，最后的步骤是创建域指数<code class="codeph">salary_index</code>使用<code class="codeph">position_indextype</code>索引类型：</p>
                  <div class="infoboxnotealso" id="GUID-BEAC690B-1FA4-4B31-9B28-FEAF45A01665__GUID-6756F120-D6DB-4D38-80E7-FFDAFE8A751C">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="CREATE-INDEX.html#GUID-1F89BBC0-825F-4215-AF71-7588E31D8BFE">创建指数</a></p>
                  </div><pre class="oac_no_warn" dir="ltr">CREATE INDEX salary_index ON employees(salary) 
   INDEXTYPE IS position_indextype;</pre><pre class="oac_no_warn" dir="ltr"></pre><p>现在您可以使用<code class="codeph">position_between</code>运算符函数重写原始查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT last_name, salary FROM employees
   WHERE position_between(salary, 10, 20)=1
   ORDER BY salary DESC, last_name;

LAST_NAME                     SALARY
------------------------- ----------
Tucker                         10000
King                           10000
Baer                           10000
Bloom                          10000
Fox                             9600
Bernstein                       9500
Sully                           9500
Greene                          9500
Hunold                          9000
Faviet                          9000
McEwen                          9000
Hall                            9000
Hutton                          8800
Taylor                          8600
Livingston                      8400
Gietz                           8300
Chen                            8200
Fripp                           8200
Weiss                           8000
Olsen                           8000
Smith                           8000
Kaufling                        7900</pre></div>
               <!-- class="section" -->
            </div>
         </div>
      </article>
   </body>
</html>