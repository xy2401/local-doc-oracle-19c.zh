<html lang="en-us"  xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Examples using external tables.">
      <meta name="description" content="Examples using external tables.">
      <title>外部表示例</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Utilities ">
      <meta property="og:description" content="Examples using external tables.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Utilities">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96081-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="oracle_hdfs-oracle_hive-access-drivers.html" title="Previous" type="text/html">
      <link rel="next" href="other-oracle-utilities.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities">
    <meta name="dcterms.isVersionOf" content="SUTIL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body >
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle_hdfs-oracle_hive-access-drivers.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="other-oracle-utilities.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">公用事业</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-external-tables.html" property="item" typeof="WebPage"><span property="name">外部表格</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">外部表示例</li>
            </ol>
            <a id="GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" name="GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503"></a>
            
            <h2 id="SUTIL-GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" class="sect2"><span class="enumeration_chapter">18</span>外部表示例</h2>
         </header>
         <div class="ind">
            <div>
               <p>使用外部表的示例。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="using-oracle-external-tables-examples.html#GUID-35F897D9-BBD9-4B5F-BE7C-01FE514CFEBE">使用ORACLE_LOADER访问驱动程序创建分区外部表</a><br>本主题描述使用<code class="codeph">ORACLE_LOADER</code>访问驱动程序创建分区外部表。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-external-tables-examples.html#GUID-576BF53F-B1F3-4EC4-AE53-006A951163AA">使用ORACLE_LOADER访问驱动程序创建分区混合表</a><br>本主题介绍如何使用<code class="codeph">ORACLE_LOADER</code>访问驱动程序创建分区混合表。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-external-tables-examples.html#GUID-9C61CD54-F59D-4F9F-984A-981DD984EAA7">使用ORACLE_DATAPUMP访问驱动程序创建分区外部表</a><br>本节中的示例显示了如何创建子分区外部表。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-external-tables-examples.html#GUID-86BD0507-EB88-4705-9321-E86E60021DD6">使用ORACLE_HDFS访问驱动程序创建分区外部表</a><br>本节中提供的示例显示如何使用<code class="codeph">ORACLE_HDFS</code>访问驱动程序创建分区外部表。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-external-tables-examples.html#GUID-74478A87-C89A-47E1-A8BF-DA556A3C2115">使用ORACLE_HIVE访问驱动程序创建分区外部表</a><br>要为<code class="codeph">ORACLE_HIVE</code>表创建分区外部表，需要一个分区的Hive外部表。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-external-tables-examples.html#GUID-9D3ED2AE-192D-435A-833E-97899778929E">从外部表加载LOB</a><br>外部表对于从单个文件加载大量记录特别有用，因此每个记录都显示在表中自己的行中。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-external-tables-examples.html#GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245">从外部表加载CSV文件</a><br>本主题提供了如何在各种条件下从外部表加载CSV文件的示例。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="oracle-external-tables.html#GUID-038ED956-A6EE-4C6D-B7C9-0D406B8088B6">外部表</a></p>
                  </div>
               </div>
            </div>
            
            <div class="sect2"><a id="GUID-35F897D9-BBD9-4B5F-BE7C-01FE514CFEBE" name="GUID-35F897D9-BBD9-4B5F-BE7C-01FE514CFEBE"></a><h3 id="SUTIL-GUID-35F897D9-BBD9-4B5F-BE7C-01FE514CFEBE" class="sect3"><span class="enumeration_section">18.1</span>使用ORACLE_LOADER访问驱动程序创建分区外部表</h3>
               <div>
                  <p>本主题描述使用<code class="codeph">ORACLE_LOADER</code>访问驱动程序创建分区外部表。
                  </p>
                  <div class="example" id="GUID-35F897D9-BBD9-4B5F-BE7C-01FE514CFEBE__GUID-8454231E-8CBB-4085-ACE5-C46724A0CCE6">
                     <p class="titleinexample">示例18-1使用ORACLE_LOADER创建分区外部表</p>
                     <p>此示例假定有四个数据文件包含以下内容：</p><pre class="pre codeblock"><code>p1a.dat:
1, AAAAA Plumbing,01372,
28, Sparkly Laundry,78907,
13, Andi's Doughnuts,54570,

p1b.dat:
51, DIY Supplies,61614,
87, Fast Frames,22201,
89, Friendly Pharmacy,89901,

p2.dat:
121, Pleasant Pets,33893,
130, Bailey the Bookmonger,99915,
105, Le Bistrot du Chat Noir,94114,

p3.dat:
210, The Electric Eel Diner,07101,
222, Everyt'ing General Store,80118,
231, Big Rocket Market,01754,</code></pre><p>数据文件中有三个字段： <code class="codeph">CUSTOMER_NUMBER</code> ， <code class="codeph">CUSTOMER_NAME</code>和<code class="codeph">POSTAL_CODE</code> 。外部表使用<code class="codeph">CUSTOMER_NUMBER</code>上的范围分区来创建三个分区。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>分区1适用于小于100的<code class="codeph">customer_number</code></p>
                        </li>
                        <li>
                           <p>分区2适用于小于200的<code class="codeph">customer_number</code></p>
                        </li>
                        <li>
                           <p>分区3适用于小于300的<code class="codeph">customer_number</code></p>
                        </li>
                     </ul>
                     <p>请注意，第一个分区有两个数据文件，而其他分区只有一个。以下是SQLPlus用于创建文件的输出。</p><pre class="pre codeblock"><code>SQL&gt; create table customer_list_xt
  2    (CUSTOMER_NUMBER number, CUSTOMER_NAME VARCHAR2(50), POSTAL_CODE CHAR(5))
  3  organization external
  4    (type oracle_loader default directory def_dir1)
  5  partition by range(CUSTOMER_NUMBER)
  6  (
  7    partition p1 values less than (100) location('p1a.dat', 'p1b.dat'),
  8    partition p2 values less than (200) location('p2.dat'),
  9    partition p3 values less than (300) location('p3.dat')
 10  );

Table created.
SQL&gt; </code></pre><p>以下是<code class="codeph">SELECT *</code>对整个表的输出：</p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_xt
  3    order by customer_number;

CUSTOMER_NUMBER CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
              1  AAAAA Plumbing                                    01372
             13  Andi's Doughnuts                                  54570
             28  Sparkly Laundry                                   78907
             51  DIY Supplies                                      61614
             87  Fast Frames                                       22201
             89  Friendly Pharmacy                                 89901
            105  Le Bistrot du Chat Noir                           94114
            121  Pleasant Pets                                     33893
            130  Bailey the Bookmonger                             99915
            210  The Electric Eel Diner                            07101
            222  Everyt'ing General Store                          80118
            231  Big Rocket Market                                 01754

12 rows selected.

SQL&gt; </code></pre><p>以下查询应该只读取第一个分区中的记录：</p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_xt
  3    where customer_number &lt; 20
  4    order by customer_number;

CUSTOMER_NUMBER CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
              1  AAAAA Plumbing                                    01372
             13  Andi's Doughnuts                                  54570

2 rows selected.

SQL&gt; </code></pre><p>以下查询指定要作为<code class="codeph">SELECT</code>语句的一部分读取的分区。
                     </p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_xt partition (p1)
  3    order by customer_number;

CUSTOMER_NUMBER CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
              1  AAAAA Plumbing                                    01372
             13  Andi's Doughnuts                                  54570
             28  Sparkly Laundry                                   78907
             51  DIY Supplies                                      61614
             87  Fast Frames                                       22201
             89  Friendly Pharmacy                                 89901

6 rows selected.

SQL&gt; </code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-external-tables-examples.html#GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" title="使用外部表的示例。">外部表示例</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-576BF53F-B1F3-4EC4-AE53-006A951163AA" name="GUID-576BF53F-B1F3-4EC4-AE53-006A951163AA"></a><h3 id="SUTIL-GUID-576BF53F-B1F3-4EC4-AE53-006A951163AA" class="sect3"><span class="enumeration_section">18.2</span>使用ORACLE_LOADER访问驱动程序创建分区混合表</h3>
               <div>
                  <p>本主题介绍如何使用<code class="codeph">ORACLE_LOADER</code>访问驱动程序创建分区混合表。
                  </p>
                  <div class="section">
                     <p>混合分区表是一种通过允许某些分区驻留在数据库段中以及外部文件或源中的某些分区来扩展Oracle分区的功能。这显着增强了大数据SQL的分区功能，其中表的大部分可以驻留在外部分区中。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-576BF53F-B1F3-4EC4-AE53-006A951163AA__GUID-91E1C38E-962C-4CB9-ACE3-324914C166D5">
                     <p class="titleinexample">例18-2例子</p>
                     <p>以下是创建分区混合l表的语句示例：</p><pre class="pre codeblock"><code>CREATE TABLE hybrid_pt (time_id date, customer number)
  TABLESPACE TS1
  EXTERNAL PARTITION ATTRIBUTES (TYPE ORACLE_LOADER 
                                 DEFAULT DIRECTORY data_dir0
                                 ACCESS PARAMETERS(FIELDS TERMINATED BY ',')
                                 REJECT LIMIT UNLIMITED) 
PARTITION by range (time_id)
(
 PARTITION century_18 VALUES LESS THAN ('01-01-1800')
    EXTERNAL,                                                 &lt;-- empty external partition
  PARTITION century_19 VALUES LESS THAN ('01-01-1900')
    EXTERNAL DEFAULT DIRECTORY data_dir1 LOCATION (‘century19_data.txt'),
  PARTITION century_20 VALUES LESS THAN ('01-01-2000') 
    EXTERNAL LOCATION (‘century20_data.txt'),
  PARTITION year_2000 VALUES LESS THAN ('01-01-2001') TABLESPACE TS2,
  PARTITION pmax VALUES LESS THAN (MAXVALUE)
);
</code></pre><p>在此示例中，该表包含内部和外部分区。表中内部分区的默认表空间是<code class="codeph">TS1</code> 。添加了一个<code class="codeph">EXTERNAL PARTITION ATTRIBUTES</code>子句，用于指定在表级别应用于表中外部分区的参数。该子句对于混合分区表是必需的。在这种情况下，通过<code class="codeph">ORACLE_LOADER</code>访问驱动程序访问外部分区，并在子句中指定访问驱动程序所需的参数。在分区级别，在每个外部分区中指定<code class="codeph">EXTERNAL</code>子句，以及应用于该分区的任何外部参数。
                     </p>
                     <p>在此示例中， <code class="codeph">century_18</code> ， <code class="codeph">century_19</code>和<code class="codeph">century_20</code>是外部分区。 <code class="codeph">century_18</code>是一个空分区，因为它不包含位置。分区<code class="codeph">century_19</code>的缺省目录是<code class="codeph">data_dir1</code> ，它覆盖了表级缺省目录。该分区的位置为<code class="codeph">data_dir1:century19_data.txt</code> 。分区<code class="codeph">century_20</code>具有位置<code class="codeph">data_dir0:century20_data.txt</code> ，因为在分区中未指定缺省目录时，表级缺省目录将应用于某个位置。分区<code class="codeph">year_2000</code>和<code class="codeph">pmax</code>是内部分区。分区<code class="codeph">year_2000</code>具有<code class="codeph">tablespace TS2</code> 。当分区没有指定<code class="codeph">EXTERNAL</code>子句或外部参数时，默认情况下它被假定为内部分区。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-external-tables-examples.html#GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" title="使用外部表的示例。">外部表示例</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-9C61CD54-F59D-4F9F-984A-981DD984EAA7" name="GUID-9C61CD54-F59D-4F9F-984A-981DD984EAA7"></a><h3 id="SUTIL-GUID-9C61CD54-F59D-4F9F-984A-981DD984EAA7" class="sect3"><span class="enumeration_section">18.3</span>使用ORACLE_DATAPUMP访问驱动程序创建分区外部表</h3>
               <div>
                  <p>本节中的示例显示了如何创建子分区外部表。</p>
                  <p>它还显示了如何使用虚拟列对表进行分区。</p>
                  <div class="example" id="GUID-9C61CD54-F59D-4F9F-984A-981DD984EAA7__GUID-211C0AFA-57A4-4F6C-A53E-B2EC777EF686">
                     <p class="titleinexample">示例18-3使用ORACLE_DATAPUMP访问驱动程序创建分区外部表</p>
                     <p>在此示例中，使用的转储文件与使用<code class="codeph">ORACLE_LOADER</code>访问驱动程序在上一个示例中创建的转储文件相同。但是，在此示例中，除了使用<code class="codeph">customer_number</code>对数据进行分区之外，还使用<code class="codeph">postal_code</code>对数据进行子分区。对于每个分区，都有一个子分区，其中<code class="codeph">postal_code</code>小于50000，另一个子分区用于<code class="codeph">postal_code</code>所有其他值。使用三个分区，每个分区包含两个子分区，总共需要六个文件。要创建文件，请使用SQL <code class="codeph">CREATE TABLE AS SELECT</code>语句为分区选择正确的行，然后将这些行写入<code class="codeph">ORACLE_DATAPUMP</code>驱动程序的文件中。
                     </p>
                     <p>以下语句创建一个文件，其中包含分区<code class="codeph">p1</code> （ <code class="codeph">customer_number</code>小于100）的第一个子分区（ <code class="codeph">postal_code</code>小于50000）的数据。
                     </p><pre class="pre codeblock"><code>SQL&gt; create table customer_list_dp_p1_sp1_xt
  2  organization external
  3    (type oracle_datapump default directory def_dir1 location('p1_sp1.dmp'))
  4  as
  5    select customer_number, customer_name, postal_code
  6      from customer_list_xt partition (p1)
  7      where to_number(postal_code) &lt; 50000;

Table created.

SQL&gt; </code></pre><p>此语句创建一个文件，其中包含分区<code class="codeph">p1</code> （customer_number小于100）的第二个子分区（postal_code的所有其他值）的数据。
                     </p><pre class="pre codeblock"><code>SQL&gt; create table customer_list_dp_p1_sp2_xt
  2  organization external
  3    (type oracle_datapump default directory def_dir1 location('p1_sp2.dmp'))
  4  as
  5    select customer_number, customer_name, postal_code
  6      from customer_list_xt partition (p1)
  7      where to_number(postal_code) &gt;= 50000;

Table created. </code></pre><p>其他分区的文件以类似的方式创建，如下所示：</p><pre class="pre codeblock"><code>SQL&gt; create table customer_list_dp_p2_sp1_xt
  2  organization external
  3    (type oracle_datapump default directory def_dir1 location('p2_sp1.dmp'))
  4  as
  5    select customer_number, customer_name, postal_code
  6      from customer_list_xt partition (p2)
  7      where to_number(postal_code) &lt; 50000;

Table created.

SQL&gt;
SQL&gt; create table customer_list_dp_p2_sp2_xt
  2  organization external
  3    (type oracle_datapump default directory def_dir1 location('p2_sp2.dmp'))
  4  as
  5    select customer_number, customer_name, postal_code
  6      from customer_list_xt partition (p2)
  7      where to_number(postal_code) &gt;= 50000;

Table created.

SQL&gt;
SQL&gt; create table customer_list_dp_p3_sp1_xt
  2  organization external
  3    (type oracle_datapump default directory def_dir1 location('p3_sp1.dmp'))
  4  as
  5    select customer_number, customer_name, postal_code
  6      from customer_list_xt partition (p3)
  7      where to_number(postal_code) &lt; 50000;

Table created.

SQL&gt;
SQL&gt; create table customer_list_dp_p3_sp2_xt
  2  organization external
  3    (type oracle_datapump default directory def_dir1 location('p3_sp2.dmp'))
  4  as
  5    select customer_number, customer_name, postal_code
  6      from customer_list_xt partition (p3)
  7      where to_number(postal_code) &gt;= 50000;

Table created.

SQL&gt;
</code></pre><p>您可以从每个外部表中进行选择，以验证它是否包含您要写出的数据。执行SQL <code class="codeph">CREATE TABLE AS SELECT</code>语句后，可以删除这些外部表。
                     </p>
                     <p>要使用虚拟列对表进行分区，请创建分区的<code class="codeph">ORACLE_DATAPUMP</code>表。同样，该表在<code class="codeph">customer_number</code>列上进行了分区，并在<code class="codeph">postal_code</code>列上进行了分区。<code class="codeph">postal_code</code>列是包含数字的字符字段，但此示例根据数值而不是字符串对其进行分区。为此，请创建一个虚拟列<code class="codeph">postal_code_num,</code>其值为<code class="codeph">postal_code</code>字段，转换为<code class="codeph">NUMBER</code>数据类型。<code class="codeph">SUBPARTITION</code>子句使用虚拟列来确定行的子分区。
                     </p><pre class="pre codeblock"><code>SQL&gt; create table customer_list_dp_xt
  2  (customer_number    number,
  3   CUSTOMER_NAME      VARCHAR2(50),
  4   postal_code        CHAR(5),
  5   postal_code_NUM    as (to_number(postal_code)))
  6  organization external
  7    (type oracle_datapump default directory def_dir1)
  8  partition by range(customer_number)
  9  subpartition by range(postal_code_NUM)
 10  (
 11    partition p1 values less than (100)
 12     (subpartition p1_sp1 values less than (50000) location('p1_sp1.dmp'),
 13      subpartition p1_sp2 values less than (MAXVALUE) location('p1_sp2.dmp')),
 14    partition p2 values less than (200)
 15     (subpartition p2_sp1 values less than (50000) location('p2_sp1.dmp'),
 16      subpartition p2_sp2 values less than (MAXVALUE) location('p2_sp2.dmp')),
 17    partition p3 values less than (300)
 18     (subpartition p3_sp1 values less than (50000) location('p3_sp1.dmp'),
 19      subpartition p3_sp2 values less than (MAXVALUE) location('p3_sp2.dmp'))
 20  );

Table created.

SQL&gt; </code></pre><p>如果选择所有行，则返回的数据与使用<code class="codeph">ORACLE_LOADER</code>访问驱动程序在上一个示例中返回的数据相同。
                     </p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_dp_xt
  3    order by customer_number;

customer_number CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
              1  AAAAA Plumbing                                    01372
             13  Andi's Doughnuts                                  54570
             28  Sparkly Laundry                                   78907
             51  DIY Supplies                                      61614
             87  Fast Frames                                       22201
             89  Friendly Pharmacy                                 89901
            105  Le Bistrot du Chat Noir                           94114
            121  Pleasant Pets                                     33893
            130  Bailey the Bookmonger                             99915
            210  The Electric Eel Diner                            07101
            222  Everyt'ing General Store                          80118
            231  Big Rocket Market                                 01754

12 rows selected.

SQL&gt; </code></pre><p><code class="codeph">WHERE</code>子句可以将读取的行限制为子分区。以下查询应该只读取第一个分区的第一个子分区。
                     </p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_dp_xt
  3    where customer_number &lt; 20 and postal_code_NUM &lt; 39998
  4    order by customer_number;

customer_number CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
              1  AAAAA Plumbing                                    01372

1 row selected.

SQL&gt; </code></pre><p>您还可以在查询中指定特定的子分区，如下所示：</p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_dp_xt subpartition (p2_sp2) order by customer_number;

customer_number CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
            105  Le Bistrot du Chat Noir                           94114
            130  Bailey the Bookmonger                             99915

2 rows selected.

SQL&gt; </code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-external-tables-examples.html#GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" title="使用外部表的示例。">外部表示例</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-86BD0507-EB88-4705-9321-E86E60021DD6" name="GUID-86BD0507-EB88-4705-9321-E86E60021DD6"></a><h3 id="SUTIL-GUID-86BD0507-EB88-4705-9321-E86E60021DD6" class="sect3"><span class="enumeration_section">18.4</span>使用ORACLE_HDFS访问驱动程序创建分区外部表</h3>
               <div>
                  <p>本节中提供的示例显示如何使用<code class="codeph">ORACLE_HDFS</code>访问驱动程序创建分区外部表。
                  </p>
                  <div class="example" id="GUID-86BD0507-EB88-4705-9321-E86E60021DD6__GUID-24FA0C40-104A-44AD-97C1-243D86E2BCA6">
                     <p class="titleinexample">示例18-4使用ORACLE_HDFS访问驱动程序创建分区外部表</p>
                     <p>在此示例中，有四个数据文件存储在HDFS目录路径<code class="codeph">"hdfs_pet/"</code> 。
                     </p><pre class="pre codeblock"><code>p1a.dat
1, AAAAA Plumbing,01372,
28, Sparkly Laundry,07101,
13, Andi'''s Doughnuts,01372,

p1b.dat
51, DIY Supplies,07101,
87, Fast Frames,01754,
89, Friendly Pharmacy,01372,

p2.dat
121, Pleasant Pets,01754,
130, Bailey the Bookmonger,01754,
105, Le Bistrot du Chat Noir,01754,

p3.dat
210, The Electric Eel Diner,07101,
222, Everyt'ing General Store,01372,
231, Big Rocket Market,01754,
</code></pre><p>出于此示例的目的，使用以下内容将数据文件写入HDFS目录：</p><pre class="pre codeblock"><code>hadoop dfs -mkdir hdfs_pet
hadoop dfs -put p1a.dat hdfs_pet/p1a.dat
hadoop dfs -put p1b.dat hdfs_pet/p1b.dat
hadoop dfs -put p2.dat hdfs_pet/p2.dat
hadoop dfs -put p3.dat hdfs_pet/p3.dat
</code></pre><p>以下是用于创建分区外部表的<code class="codeph">CREATE TABLE</code>命令：</p><pre class="pre codeblock"><code>create table customer_list_hdfs
  (CUSTOMER_NUMBER number, CUSTOMER_NAME VARCHAR2(50), POSTAL_CODE CHAR(5))
organization external
  (type oracle_hdfs
   default directory def_dir1
   access parameters
   (com.oracle.bigdata.cluster   = hadoop_cl_1
    com.oracle.bigdata.rowformat = delimited fields terminated by ','))
partition by range(CUSTOMER_NUMBER)
(
  partition p1 values less than (100) location('hdfs_pet/p1a.dat', 'hdfs_pet/p1b.dat'),
  partition p2 values less than (200) location('hdfs_pet/p2.dat'),
  partition p3 values less than (300) location('hdfs_pet/p3.dat')
); </code></pre><p>以下查询显示外部表中的<code class="codeph">SELECT</code>操作：</p><pre class="pre codeblock"><code>SQL&gt; select * from customer_list_hdfs order by customer_number;

CUSTOMER_NUMBER CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
              1  AAAAA Plumbing                                    01372
             13  Andi's Doughnuts                                  01372
             28  Sparkly Laundry                                   07101
             51  DIY Supplies                                      07101
             87  Fast Frames                                       01754
             89  Friendly Pharmacy                                 01372
            105  Le Bistrot du Chat Noir                           01754
            121  Pleasant Pets                                     01754
            130  Bailey the Bookmonger                             01754
            210  The Electric Eel Diner                            07101
            222  Everyt'ing General Store                          01372
            231  Big Rocket Market                                 01754

12 rows selected.

SQL&gt; </code></pre><p>您还可以使用<code class="codeph">WHERE</code>子句执行查询，该子句排除无法与<code class="codeph">WHERE</code>子句中的条件匹配的分区，如下所示：</p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_hdfs
  3    where customer_number &lt; 20
  4    order by customer_number;

CUSTOMER_NUMBER CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
              1  AAAAA Plumbing                                    01372
             13  Andi's Doughnuts                                  01372

2 rows selected.

SQL&gt; </code></pre><p>您还可以将要读取的分区指定为<code class="codeph">FROM</code>子句的一部分，如下所示：</p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_hdfs partition (p3)
  3    order by customer_number;

CUSTOMER_NUMBER CUSTOMER_NAME                                      POSTA
--------------- -------------------------------------------------- -----
            210  The Electric Eel Diner                            07101
            222  Everyt'ing General Store                          01372
            231  Big Rocket Market                                 01754

3 rows selected.

SQL&gt; </code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-external-tables-examples.html#GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" title="使用外部表的示例。">外部表示例</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-74478A87-C89A-47E1-A8BF-DA556A3C2115" name="GUID-74478A87-C89A-47E1-A8BF-DA556A3C2115"></a><h3 id="SUTIL-GUID-74478A87-C89A-47E1-A8BF-DA556A3C2115" class="sect3"><span class="enumeration_section">18.5</span>使用ORACLE_HIVE访问驱动程序创建分区外部表</h3>
               <div>
                  <p>要为<code class="codeph">ORACLE_HIVE</code>表创建分区外部表，需要一个分区的Hive外部表。
                  </p>
                  <p>然后，您需要使用PL / SQL过程<code class="codeph">DBMS_HADOOP.CREATE_EXTDDL_FOR_HIVE()</code> 。此外，此示例从上一示例中使用的HDFS文件创建分区Hive表。在可以创建分区的Hive表之前，必须创建一个用于存储数据的HDFS目录。
                  </p>
                  <div class="example" id="GUID-74478A87-C89A-47E1-A8BF-DA556A3C2115__GUID-E076E76E-EEEA-43DE-AD7B-CE53F94909D1">
                     <p class="titleinexample">示例18-5使用ORACLE_HIVE访问驱动程序创建分区外部表</p>
                     <p>这个示例使用前一个示例中的数据文件创建Hive表，显示如何使用<code class="codeph">ORACLE_HDFS</code>创建分区外部表。以下命令均在Hive CLI内执行，因此它们使用Hive语法。
                     </p>
                     <p>首先，使用Hive在HDFS数据文件之上创建Hive外部表，如下所示：</p><pre class="pre codeblock"><code>create external table customer_list_no_part ( customer_number int,
                                              customer_name   string,
                                              postal_code string)
 row format delimited fields terminated by ','
 stored as textfile
 location '/user/doc/hdfs_pet'</code></pre><p>然后执行以下命令告诉Hive动态创建分区：</p><pre class="pre codeblock"><code>set hive.exec.dynamic.partition=true
set hive.exec.dynamic.partition.mode=nonstrict
</code></pre><p>创建分区的Hive表：</p><pre class="pre codeblock"><code>create table customer_list( CUSTOMER_NUMBER int,
                            CUSTOMER_NAME   string)
 partitioned by (postal_code string)
 row format delimited
 fields terminated by '\t'
 location '/user/doc/doc_pet'</code></pre><p>使用表<code class="codeph">customer_list_no_part</code>数据填充配置单元表。这应该为每个具有正确行的分区创建文件。
                     </p><pre class="pre codeblock"><code>insert overwrite table customer_list partition (postal_code) select * from customer_list_no_part</code></pre><p>Hive <code class="codeph">customer_list</code>表填充了行。如下面的查询所示：</p><pre class="pre codeblock"><code>select * from customer_list order by customer_number
1     AAAAA Plumbing    01372
13     Andi's Doughnuts    01372
28     Sparkly Laundry    07101
51     DIY Supplies    07101
87     Fast Frames    01754
89     Friendly Pharmacy    01372
105     Le Bistrot du Chat Noir    01754
121     Pleasant Pets    01754
130     Bailey the Bookmonger    01754
210     The Electric Eel Diner    07101
222     Everyt'ing General Store    01372
231     Big Rocket Market    01754
</code></pre><p>现在，您可以返回SQL * Plus以在Oracle数据库中创建分区外部表。首先，使用PL / SQL函数<code class="codeph">DBMS_HADOOP.CREATE_EXTDDL_FOR_HIVE()</code>来创建外部表。论点如下：</p>
                     <ol>
                        <li>
                           <p>Hadoop集群的名称</p>
                        </li>
                        <li>
                           <p>拥有该表的Hive用户的名称</p>
                        </li>
                        <li>
                           <p>分区Hive表的名称</p>
                        </li>
                        <li>
                           <p>一个布尔值，指示是否要将Hive表中的分区列作为列包含在外部表中</p>
                        </li>
                        <li>
                           <p>创建的分区<code class="codeph">ORACLE_HIVE</code>表的名称</p>
                        </li>
                        <li>
                           <p>一个布尔值，指示是否执行<code class="codeph">CREATE</code> DDL</p>
                        </li>
                        <li>
                           <p><code class="codeph">CLOB</code>包含<code class="codeph">CREATE</code> DDL字符串</p>
                        </li>
                     </ol>
                     <p>此示例获取<code class="codeph">CREATE</code> DDL字符串的<code class="codeph">CLOB</code> ，并使用<code class="codeph">DBMS_OUTPUT.PUT_LINE()</code>过程编写它。设置<code class="codeph">SERVEROUTPUT ON</code>告诉SQL * Plus显示<code class="codeph">DBMS_OUTPUT.PUT_LINE()</code>过程中的数据。将<code class="codeph">LINESIZE</code>设置为132可确保在显示<code class="codeph">DBMS_OUTPUT.PUT_LINE()</code>过程中的数据时，奇数位置没有换行符。
                     </p><pre class="pre codeblock"><code>SQL&gt; SET LINESIZE 132
SQL&gt; SET SERVEROUTPUT ON
SQL&gt;
SQL&gt; DECLARE
  2    DDLtxt clob;
  3  BEGIN
  4    dbms_hadoop.create_extddl_for_hive
  5     ('hadoop_cl_1', 'default', 'customer_list',
  6      TRUE, 'CUSTOMER_LIST_HIVE', TRUE, DDLtxt);
  7    dbms_output.put_line('DDL Text is :  ' || DDLtxt);
  8  END;
  9  /
External table successfully created.
DDL Text is :  CREATE TABLE "DOC"."CUSTOMER_LIST_HIVE" (customer_number NUMBER, customer_name VARCHAR2(4000), postal_code
VARCHAR2(4000))  ORGANIZATION EXTERNAL
 (TYPE ORACLE_HIVE
 DEFAULT DIRECTORY DEFAULT_DIR
 ACCESS PARAMETERS
(
com.oracle.bigdata.cluster=hadoop_cl_1
com.oracle.bigdata.tablename=default.customer_list)
) REJECT LIMIT UNLIMITED
PARTITION BY
LIST (postal_code)
(
PARTITION "P_293620257" VALUES ('01372'),
PARTITION "P_292175793" VALUES ('01754'),
PARTITION "P_717839126"
VALUES ('07101')
)
</code></pre><p>由于Hive未指定<code class="codeph">STRING</code>列的最大字符数，因此外部表的列定义为<code class="codeph">VARCHAR2(4000)</code> 。如果您希望某些列的长度较小，则可以调用<code class="codeph">DBMS_HADOOP.CREATE_EXTDDL_FOR_HIVE()</code>过程并指定您不想执行<code class="codeph">CREATE</code> DDL。然后，您可以编辑<code class="codeph">CLOB</code>返回的<code class="codeph">CREATE</code>语句，以将<code class="codeph">VARCHAR2</code>列的长度设置为更合适的值。
                     </p>
                     <p>另请注意，分区名称中的数字可能会有所不同。</p>
                     <p>现在创建了表，执行<code class="codeph">SELECT *</code>语句将返回所有行。请注意，上面执行的<code class="codeph">SET LINESIZE</code>意味着SQL * Plus对<code class="codeph">customer_name</code>和<code class="codeph">postal_code</code>使用132个字符。
                     </p><pre class="pre codeblock"><code>SQL&gt; select * from customer_list_hive order by customer_number;

CUSTOMER_NUMBER
---------------
CUSTOMER_NAME
------------------------------------------------------------------------------------------------------------------------------POSTAL_CODE
------------------------------------------------------------------------------------------------------------------------------              1
 AAAAA Plumbing
01372

             13
 Andi's Doughnuts
01372

             28
 Sparkly Laundry
07101

             51
 DIY Supplies
07101

             87
 Fast Frames
01754

             89
 Friendly Pharmacy
01372

            105
 Le Bistrot du Chat Noir
01754

            121
 Pleasant Pets
01754

            130
 Bailey the Bookmonger
01754

            210
 The Electric Eel Diner
07101

            222
 Everyt'ing General Store
01372

            231
 Big Rocket Market
01754


12 rows selected.

SQL&gt;
</code></pre><p>SQL执行使用分区信息来修剪与<code class="codeph">WHERE</code>子句中的条件不匹配的分区。
                     </p><pre class="pre codeblock"><code>SQL&gt; select customer_number, customer_name, postal_code
  2    from customer_list_hive
  3    where postal_code = '01754'
  4    order by customer_number;

CUSTOMER_NUMBER
---------------
CUSTOMER_NAME
------------------------------------------------------------------------------------------------------------------------------POSTAL_CODE
------------------------------------------------------------------------------------------------------------------------------             87
 Fast Frames
01754

            105
 Le Bistrot du Chat Noir
01754

            121
 Pleasant Pets
01754

            130
 Bailey the Bookmonger
01754

            231
 Big Rocket Market
01754


5 rows selected.

SQL&gt; </code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-external-tables-examples.html#GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" title="使用外部表的示例。">外部表示例</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-9D3ED2AE-192D-435A-833E-97899778929E" name="GUID-9D3ED2AE-192D-435A-833E-97899778929E"></a><h3 id="SUTIL-GUID-9D3ED2AE-192D-435A-833E-97899778929E" class="sect3"><span class="enumeration_section">18.6</span>从外部表加载LOB</h3>
               <div>
                  <p>外部表对于从单个文件加载大量记录特别有用，因此每个记录都显示在表中自己的行中。</p>
                  <p>以下示例显示了如何执行此类加载。</p>
                  <div class="example" id="GUID-9D3ED2AE-192D-435A-833E-97899778929E__GUID-EF085643-5699-4DAE-BCF2-2E8F3F5FEA3F">
                     <p class="titleinexample">示例18-6从外部表加载LOB</p>
                     <p>假设您定义了一个外部表<code class="codeph">my_ext_table</code> ，如下所示：</p><pre class="pre codeblock"><code>CREATE TABLE my_ext_table ( id NUMBER, author VARCHAR2(30), created DATE, text CLOB )
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY MY_DIRECTORY
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY 0x'0A'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      ( id         CHAR(10),
        author     CHAR(30),
        created    DATE "YYYY-MM-DD",
        text       CHAR(131071)
      )
    )
    LOCATION (
      MY_DIRECTORY:'external.dmp'
    )
);</code></pre><p><code class="codeph">external.dmp</code>文件的内容如下：</p><pre class="pre codeblock"><code>1,Roger,2015-08-08,The quick brown fox jumps over the lazy dog
2,John,2012-01-01,"The angry aligator, acting alone, ate the antelope"</code></pre><p>转储文件中的第二行需要在整个文本字符串周围加引号;否则该字段将以逗号终止。</p>
                     <div class="infoboxnote" id="GUID-9D3ED2AE-192D-435A-833E-97899778929E__GUID-84640F47-FADD-4A35-9E3F-897EC97E8DED">
                        <p class="notep1">注意：</p>虽然在此示例中使用的转储文件中没有问题，但如果全文字符串中的某些内容包含引号，那么您可以将其括在另一组引号中，如下<code class="codeph">alone</code>的单词：<pre class="pre codeblock"><code>2,John,2012-01-01,"The angry aligator, acting ""alone"", ate the antelope"</code></pre></div>
                     <p>如果全文可能包含记录分隔符（0x'0A'或换行符），则可以为每个文档指定单独的文件。外部表不支持填充字段，因此您必须使用<code class="codeph">COLUMN TRANSFORMS</code>子句指定<code class="codeph">fname</code>字段包含外部文件的名称：</p><pre class="pre codeblock"><code>DROP TABLE my_ext_table2;

CREATE TABLE my_ext_table2 ( id NUMBER, author VARCHAR2(30), created DATE, text CLOB )
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY MY_DIRECTORY
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY 0x'0A'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      ( id         CHAR(10),
        author     CHAR(30),
        created    DATE "YYYY-MM-DD",
        fname      char(100)
      )
    COLUMN TRANSFORMS (text FROM LOBFILE(fname) FROM (MY_DIRECTORY) )
    )
    LOCATION (
      'loader.txt'
    )
);

</code></pre><div class="infoboxnote" id="GUID-9D3ED2AE-192D-435A-833E-97899778929E__GUID-291A6B42-90F6-40D4-84CD-3ECE64ED9724">
                        <p class="notep1">注意：</p><code class="codeph">FROM (MY_DIRECTORY)</code>子句实际上不是必需的，因为它已被指定为默认目录。但是，这里显示的是出于示例目的，因为如果<code class="codeph">loader.txt</code>文件和各个CLOB文件位于不同的位置，则需要它。
                     </div>
                     <p>一旦数据在外部表中，您可以将其保留在那里并在外部表上执行常规表操作（DML和大多数DDL），或者您可以使用外部表作为临时表将数据放入普通表中。要创建新的普通（非外部）表，可以使用以下SQL语句：</p><pre class="pre codeblock"><code>CREATE TABLE <span class="variable" translate="no">normaltable</span> AS SELECT * FROM <span class="variable" translate="no">externaltable</span>;</code></pre><p>您可以类似地使用以下SQL语句将数据插入新的普通表：</p><pre class="pre codeblock"><code>INSERT INTO <span class="variable" translate="no">normaltable</span> AS SELECT * FROM <span class="variable" translate="no">externaltable</span>;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-external-tables-examples.html#GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" title="使用外部表的示例。">外部表示例</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245" name="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245"></a><h3 id="SUTIL-GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245" class="sect3"><span class="enumeration_section">18.7</span>从外部表加载CSV文件</h3>
               <div>
                  <p>本主题提供了如何在各种条件下从外部表加载CSV文件的示例。</p>
                  <p>一些示例基于先前的示例。</p>
                  <div class="example" id="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245__GUID-FDD5DCDC-60AA-4AF0-8ED6-79520875DB44">
                     <p class="titleinexample">示例18-7从没有访问参数的CSV文件加载数据</p>
                     <p>此示例需要以下条件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表中列的顺序必须与数据文件中的字段顺序相匹配。</p>
                        </li>
                        <li>
                           <p>数据文件中的记录必须以换行符终止。</p>
                        </li>
                        <li>
                           <p>数据文件中记录中的字段必须用逗号分隔（如果字段值用引号括起来，则<span class="italic">不会</span>从字段中删除引号）。
                           </p>
                        </li>
                        <li>
                           <p>字段中间不能有任何换行符。</p>
                        </li>
                     </ul>
                     <p>外部表的数据如下：</p><pre class="pre codeblock"><code>events_all.csv
Winter Games,10-JAN-2010,10,
Hockey Tournament,18-MAR-2009,3,
Baseball Expo,28-APR-2009,2,
International Football Meeting,2-MAY-2009,14,
Track and Field Finale,12-MAY-2010,3,
Mid-summer Swim Meet,5-JUL-2010,4,
Rugby Kickoff,28-SEP-2009,6,</code></pre><p>外部表的定义如下：</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE EVENTS_XT_1
  2  (EVENT       varchar2(30),
  3   START_DATE  date,
  4   LENGTH      number)
  5  ORGANIZATION EXTERNAL
  6  (default directory def_dir1 location ('events_all.csv'));

Table created.
</code></pre><p>以下显示外部表<code class="codeph">EVENTS_XT_1</code>上的<code class="codeph">SELECT</code>操作：</p><pre class="pre codeblock"><code>SQL&gt; select START_DATE, EVENT, LENGTH
  2    from EVENTS_XT_1
  3    order by START_DATE;

START_DAT EVENT                              LENGTH
--------- ------------------------------ ----------
18-MAR-09 Hockey Tournament                       3
28-APR-09 Baseball Expo                           2
02-MAY-09 International Football Meeting         14
28-SEP-09 Rugby Kickoff                           6
10-JAN-10 Winter Games                           10
12-MAY-10 Track and Field Finale                  3
05-JUL-10 Mid-summer Swim Meet                    4

7 rows selected.

SQL&gt; </code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245__GUID-DBA430E9-A20E-4975-AA6C-728C66FB3F3C">
                     <p class="titleinexample">示例18-8会话的默认日期掩码与数据文件中的数据字段格式不匹配</p>
                     <p>此示例与上一示例相同，不同之处在于会话的默认日期掩码与数据文件中日期字段的格式不匹配。在下面的示例中，日期的会话格式为<code class="codeph">DD-Mon-YYYY</code>而数据文件中的日期格式为<code class="codeph">MM/DD/YYYY</code> 。如果外部表定义没有日期掩码，则<code class="codeph">ORACLE_LOADER</code>访问驱动程序使用会话日期掩码尝试将数据文件中的字符数据转换为日期数据类型。 ou指定日期掩码的访问参数，以用于数据文件中用于在外部表中加载日期列的所有字段。
                     </p>
                     <p>以下是外部表的数据文件的内容：</p><pre class="pre codeblock"><code>events_all_date_fmt.csv
Winter Games,1/10/2010,10
Hockey Tournament,3/18/2009,3
Baseball Expo,4/28/2009,2
International Football Meeting,5/2/2009,14
Track and Field Finale,5/12/2009,3
Mid-summer Swim Meet,7/5/2010,4
Rugby Kickoff,9/28/2009,6</code></pre><p>外部表的定义如下：</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE EVENTS_XT_2
  2  (EVENT       varchar2(30),
  3   START_DATE  date,
  4   LENGTH      number)
  5  ORGANIZATION EXTERNAL
  6  (default directory def_dir1
  7   access parameters (fields date_format date mask "mm/dd/yyyy")
  8   location ('events_all_date_fmt.csv'));

Table created.

SQL&gt; </code></pre><p>以下显示外部表<code class="codeph">EVENTS_XT_2:</code>上的<code class="codeph">SELECT</code>操作<code class="codeph">EVENTS_XT_2:</code></p><pre class="pre codeblock"><code>SQL&gt; select START_DATE, EVENT, LENGTH
  2    from EVENTS_XT_2
  3    order by START_DATE;

START_DAT EVENT                              LENGTH
--------- ------------------------------ ----------
18-MAR-09 Hockey Tournament                       3
28-APR-09 Baseball Expo                           2
02-MAY-09 International Football Meeting         14
12-MAY-09 Track and Field Finale                  3
28-SEP-09 Rugby Kickoff                           6
10-JAN-10 Winter Games                           10
05-JUL-10 Mid-summer Swim Meet                    4

7 rows selected.
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245__GUID-ED72440A-2724-44D9-B945-2344A5CACC73">
                     <p class="titleinexample">示例18-9数据在两个数据文件中分割</p>
                     <p>此示例与本节中的第一个示例相同，但以下情况除外：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>数据分为两个数据文件。</p>
                        </li>
                        <li>
                           <p>每个数据文件都有一行包含字段的名称。</p>
                        </li>
                        <li>
                           <p>数据文件中的某些字段用引号括起来。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">FIELD NAMES ALL FILES</code>告诉访问驱动程序每个文件中的第一行包含一行，其中包含文件中字段的名称。访问驱动程序将字段名称与表中列的名称相匹配。这意味着文件中字段的顺序可能与表中列的顺序不同。如果第一行中的字段名称未包含在引号中，则访问驱动程序会在尝试在表中查找匹配的列名称之前对该名称进行大写。如果字段名称用引号括起来，那么在查找匹配的名称之前，它不会更改名称的大小写。
                     </p>
                     <p>因为字段用引号括起来，所以access参数需要<code class="codeph">CSV WITHOUT EMBEDDED RECORD TERMINATORS</code>子句。本条款规定如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>数据文件中的字段用逗号分隔。</p>
                        </li>
                        <li>
                           <p>如果字段用双引号括起来，则访问驱动程序会从字段值中删除它们。</p>
                        </li>
                        <li>
                           <p>字段值中没有嵌入新行（此选项允许访问驱动程序跳过某些可能会降低外部表上<code class="codeph">SELECT</code>操作性能的检查）。
                           </p>
                        </li>
                     </ul>
                     <p>这两个数据文件如下：</p><pre class="pre codeblock"><code>events_1.csv

"EVENT","START DATE","LENGTH",
"Winter Games", "10-JAN-2010", "10"
"Hockey Tournament", "18-MAR-2009", "3"
"Baseball Expo", "28-APR-2009", "2"
"International Football Meeting", "2-MAY-2009", "14"</code></pre><pre class="pre codeblock"><code>events_2.csv

Event,Start date,Length,
Track and Field Finale, 12-MAY-2009, 3
Mid-summer Swim Meet, 5-JUL-2010, 4
Rugby Kickoff, 28-SEP-2009, 6</code></pre><p>外部表定义如下：</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE EVENTS_XT_3
  2  ("START DATE"  date,
  3   EVENT         varchar2(30),
  4   LENGTH        number)
  5  ORGANIZATION EXTERNAL
  6  (default directory def_dir1
  7   access parameters (records field names all files
  8                      fields csv without embedded record terminators)
  9   location ('events_1.csv', 'events_2.csv'));

Table created.
</code></pre><p>以下显示了<code class="codeph">EVENTS_XT_3</code>外部表上<code class="codeph">SELECT</code>操作的结果：</p><pre class="pre codeblock"><code>SQL&gt; select "START DATE", EVENT, LENGTH
  2    from EVENTS_XT_3
  3    order by "START DATE";

START DAT EVENT                              LENGTH
--------- ------------------------------ ----------
18-MAR-09 Hockey Tournament                       3
28-APR-09 Baseball Expo                           2
02-MAY-09 International Football Meeting         14
12-MAY-09 Track and Field Finale                  3
28-SEP-09 Rugby Kickoff                           6
10-JAN-10 Winter Games                           10
05-JUL-10 Mid-summer Swim Meet                    4

7 rows selected.

</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245__GUID-AB2AA9EF-5D96-43B8-AABC-C18EAD4AB87A">
                     <p class="titleinexample">示例18-10数据在两个文件中分割，只有第一个文件有一行字段名称</p>
                     <p>此示例与示例3相同，只是第一个文件只有一行字段名称。第二个文件的第一行包含实际数据。RECORDS子句更改为“字段名称第一个文件”。</p>
                     <p>这两个数据文件如下：</p><pre class="pre codeblock"><code>events_1.csv (same as for example 3)

"EVENT","START DATE","LENGTH",
"Winter Games", "10-JAN-2010", "10"
"Hockey Tournament", "18-MAR-2009", "3"
"Baseball Expo", "28-APR-2009", "2"
"International Football Meeting", "2-MAY-2009", "14"</code></pre><pre class="pre codeblock"><code>events_2_no_header_row.csv

Track and Field Finale, 12-MAY-2009, 3
Mid-summer Swim Meet, 5-JUL-2010, 4
Rugby Kickoff, 28-SEP-2009, 6
</code></pre><p>外部表定义如下：</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE EVENTS_XT_4
  2  ("START DATE"  date,
  3   EVENT         varchar2(30),
  4   LENGTH        number)
  5  ORGANIZATION EXTERNAL
  6  (default directory def_dir1
  7   access parameters (records field names first file
  8                      fields csv without embedded record terminators)
  9   location ('events_1.csv', 'events_2_no_header_row.csv'));

Table created.
</code></pre><p>以下显示了<code class="codeph">EVENTS_XT_4</code>外部表上的<code class="codeph">SELECT</code>操作：</p><pre class="pre codeblock"><code>SQL&gt; select "START DATE", EVENT, LENGTH
  2    from EVENTS_XT_4
  3    order by "START DATE";

START DAT EVENT                              LENGTH
--------- ------------------------------ ----------
18-MAR-09 Hockey Tournament                       3
28-APR-09 Baseball Expo                           2
02-MAY-09 International Football Meeting         14
12-MAY-09 Track and Field Finale                  3
28-SEP-09 Rugby Kickoff                           6
10-JAN-10 Winter Games                           10
05-JUL-10 Mid-summer Swim Meet                    4

7 rows selected.
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245__GUID-9A1B16E1-8996-4B67-ABAE-926CEF463F3F">
                     <p class="titleinexample">示例18-11文件中字段的顺序与表中列的顺序匹配</p>
                     <p>此示例具有以下条件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>文件中字段的顺序与表中列的顺序相匹配。</p>
                        </li>
                        <li>
                           <p>字段由换行符分隔，并且可选地用双引号括起来。</p>
                        </li>
                        <li>
                           <p>有些字段在其值中嵌入了换行符，这些字段用双引号括起来。</p>
                        </li>
                     </ul>
                     <p>数据文件的内容如下：</p><pre class="pre codeblock"><code>event_contacts_1.csv

Winter Games, 10-JAN-2010, Ana Davis,
Hockey Tournament, 18-MAR-2009, "Daniel Dube
Michel Gagnon",
Baseball Expo, 28-APR-2009, "Robert Brown"
Internation Football Meeting, 2-MAY-2009,"Pete Perez
Randall Barnes
Melissa Gray",
</code></pre><pre class="pre codeblock"><code>event_contacts_2.csv

Track and Field Finale, 12-MAY-2009, John Taylor,
Mid-summer Swim Meet, 5-JUL-2010, "Louise Stewart
Cindy Sanders"
Rugby Kickoff, 28-SEP-2009, "Don Nguyen
Ray Lavoie"</code></pre><p>表定义如下。<code class="codeph">CSV WITH EMBEDDED RECORD TERMINATORS</code>子句告诉访问驱动程序如何处理由双引号括起来的字段，这些字段也有嵌入的新行。
                     </p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE EVENTS_CONTACTS_1
  2  (EVENT       varchar2(30),
  3   START_DATE  date,
  4   CONTACT     varchar2(120))
  5  ORGANIZATION EXTERNAL
  6  (default directory def_dir1
  7   access parameters (fields CSV with embedded record terminators)
  8   location ('event_contacts_1.csv', 'event_contacts_2.csv'));

Table created.
</code></pre><p>以下显示了<code class="codeph">EVENT_CONTACTS_1</code>外部表上的<code class="codeph">SELECT</code>操作的结果：</p><pre class="pre codeblock"><code>SQL&gt; column contact format a30 
SQL&gt; select START_DATE, EVENT, CONTACT
  2    from EVENTS_CONTACTS_1
  3    order by START_DATE;

START_DAT EVENT                          CONTACT
--------- ------------------------------ ------------------------------
18-MAR-09 Hockey Tournament              Daniel Dube
                                         Michel Gagnon

28-APR-09 Baseball Expo                  Robert Brown
02-MAY-09 Internation Football Meeting   Pete Perez
                                         Randall Barnes
                                         Melissa Gray

12-MAY-09 Track and Field Finale         John Taylor
28-SEP-09 Rugby Kickoff                  Don Nguyen
                                         Ray Lavoie

10-JAN-10 Winter Games                   Ana Davis
05-JUL-10 Mid-summer Swim Meet           Louise Stewart
                                         Cindy Sanders

7 rows selected.
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-53C71354-FDC0-4CD7-BBF1-2B7327A1A245__GUID-D5C0DA21-39D9-45C4-90C1-265E821763BD">
                     <p class="titleinexample">示例18-12数据文件中并非所有字段使用访问参数的默认设置</p>
                     <p>此示例显示了当数据文件中的大多数字段使用访问参数的默认设置时要执行的操作，但有一些不这样做。此示例显示如何仅为与默认字段不同的字段设置属性，而不是列出所有字段的设置。差异如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有两个日期字段，其中一个使用会话格式，但<code class="codeph">registration_deadline</code>使用不同的格式</p>
                        </li>
                        <li>
                           <p><code class="codeph">registration_deadline</code>还使用值<code class="codeph">NONE</code>来指示空值。
                           </p>
                        </li>
                     </ul>
                     <p>数据文件的内容如下：</p><pre class="pre codeblock"><code>events_reg.csv

Winter Games,10-JAN-2010,10,12/1/2009,
Hockey Tournament,18-MAR-2009,3,3/11/2009,
Baseball Expo,28-APR-2009,2,NONE
International Football Meeting,2-MAY-2009,14,3/1/2009
Track and Field Finale,12-MAY-2010,3,5/10/010
Mid-summer Swim Meet,5-JUL-2010,4,6/20/2010
Rugby Kickoff,28-SEP-2009,6,NONE  </code></pre><p>表定义如下。<code class="codeph">ALL FIELDS OVERRIDE</code>子句允许您在使用其余字段的默认值时指定该字段的信息。其余字段的数据类型为<code class="codeph">CHAR(255)</code> ，字段数据由带有<code class="codeph">LDRTRIM</code>修剪选项的逗号终止。</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE EVENT_REGISTRATION_1
  2  (EVENT                 varchar2(30),
  3   START_DATE            date,
  4   LENGTH                number,
  5   REGISTRATION_DEADLINE date)
  6  ORGANIZATION EXTERNAL
  7  (default directory def_dir1
  8   access parameters
  9  (fields all fields override
 10     (REGISTRATION_DEADLINE CHAR (10) DATE_FORMAT DATE MASK "mm/dd/yyyy"
 11                           NULLIF REGISTRATION_DEADLINE = 'NONE'))
 12   location ('events_reg.csv'));

Table created.
</code></pre><p>以下显示了<code class="codeph">EVENT_REGISTRATION_1</code>外部表上的<code class="codeph">SELECT</code>操作的结果：</p><pre class="pre codeblock"><code>SQL&gt; select START_DATE, EVENT, LENGTH, REGISTRATION_DEADLINE
  2    from EVENT_REGISTRATION_1
  3    order by START_DATE;

START_DAT EVENT                              LENGTH REGISTRAT
--------- ------------------------------ ---------- ---------
18-MAR-09 Hockey Tournament                       3 11-MAR-09
28-APR-09 Baseball Expo                           2
02-MAY-09 International Football Meeting         14 01-MAR-09
28-SEP-09 Rugby Kickoff                           6
10-JAN-10 Winter Games                           10 01-DEC-09
12-MAY-10 Track and Field Finale                  3 10-MAY-10
05-JUL-10 Mid-summer Swim Meet                    4 20-JUN-10

7 rows selected.

</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-external-tables-examples.html#GUID-03CE63AD-F046-4805-A560-E4CFD7FA8503" title="使用外部表的示例。">外部表示例</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>