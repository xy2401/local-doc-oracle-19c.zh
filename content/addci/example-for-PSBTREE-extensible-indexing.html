<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>PSBTREE：可扩展索引示例</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Cartridge Developer&#39;s Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Cartridge Developer&#39;s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="data-cartridge-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-10T07:34:53-08:00">
      <meta name="dcterms.title" content="Data Cartridge Developer&#39;s Guide">
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96431-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="example-for-power-demand-cartridge.html" title="Previous" type="text/html">
      <link rel="next" href="example-for-pipelined-table-functions-interface-approach.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADDCI">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="example-for-power-demand-cartridge.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="example-for-pipelined-table-functions-interface-approach.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据盒式开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="scenarios-and-examples.html" property="item" typeof="WebPage"><span property="name">场景和示例</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PSBTREE：可扩展索引示例</li>
            </ol>
            <a id="GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF" name="GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF"></a><a id="ADDCI3160"></a>
            
            <h2 id="ADDCI-GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF" class="sect2"><span class="enumeration_chapter">16</span> PSBTREE：可扩展索引示例</h2>
         </header>
         <div class="ind">
            <div>
               <p>这是一个可扩展索引的例子，用C语言实现<code class="codeph">ODCIIndex</code>接口例程。
               </p>
            </div><a id="ADDCI4877"></a><div class="props_rev_3"><a id="GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D" name="GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D"></a><h3 id="ADDCI-GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D" class="sect3"><span class="enumeration_section">16.1</span>关于PSBTREE示例</h3>
               <div>
                  <div class="section">
                     <p>考虑如何在C中实现可扩展索引接口例程。该示例的重点是所有实现共有的主题;它不会公开特定于域的详细信息。</p>
                     <p>该示例的代码位于demo目录中的<code class="codeph">extdemo6.sql</code>文件中。它通过添加indextype支持扩展了早期的示例（ <code class="codeph">extdemo2.sql</code> ，也在demo目录中） <a id="d56830e120" class="indexterm-anchor"></a>范围分区表上的本地域索引。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADDCI4878"></a><div class="props_rev_3"><a id="GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE" name="GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE"></a><h3 id="ADDCI-GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE" class="sect3"><span class="enumeration_section">16.2</span>索引类型的设计</h3>
               <div>
                  <p>该<a id="d56830e178" class="indexterm-anchor"></a>这里实现的indextype，称为<code class="codeph">PSBtree,</code>就像b树索引一样运行。它支持三个用户定义的运算符： <code class="codeph">eq</code> （等于）， <code class="codeph">lt</code> （小于）和<code class="codeph">gt</code> （大于）。这些运算符在<code class="codeph">VARCHAR2</code>数据类型的操作数上运行。
                  </p>
                  <p>索引数据由<code class="codeph">&lt;key, rid&gt;</code>形式的记录组成，其中<code class="codeph">key</code>是索引列的值， <code class="codeph">rid</code>是相应行的行标识符。为了简化indextype的实现，索引数据存储在系统分区表中。
                  </p>
                  <p>当索引是系统管理的本地域索引时，将为每个分区创建系统分区表中的一个分区，以存储该分区的索引数据。因此，索引操作例程仅将<code class="codeph">PSBtree</code>操作<code class="codeph">PSBtree</code>为存储索引数据的表分区上的操作。
                  </p>
                  <p>当用户创建<code class="codeph">PSBtree</code>索引（本地索引）时，将创建<code class="codeph">n</code>表分区，其中包含索引列和<code class="codeph">rowid</code>列，其中<code class="codeph">n</code>是基表中的分区数。插入基表会导致适当插入受影响的索引表分区。删除和更新的处理方式类似。当基于用户定义的运算符（ <code class="codeph">gt</code> ， <code class="codeph">lt</code>和<code class="codeph">eq</code> ）查询<code class="codeph">PSBtree</code> ，针对索引表分区发出适当的查询以检索所有令人满意的行。发生适当的分区修剪，并且仅访问对应于相关或“有趣”分区的索引表分区。
                  </p>
               </div>
            </div><a id="ADDCI4879"></a><div class="props_rev_3"><a id="GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F" name="GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F"></a><h3 id="ADDCI-GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F" class="sect3"><span class="enumeration_section">16.3</span>实施运营商</h3>
               <div>
                  <p><code class="codeph">PSBtree</code>索引类型支持三个运算符： <code class="codeph">eq</code> ， <code class="codeph">gt</code>和<code class="codeph">lt</code> 。每个操作员都有相应的功能实现。
                  </p>
               </div><a id="ADDCI4880"></a><div class="props_rev_3"><a id="GUID-72B9F965-1889-44D6-A0E7-27868DAAF155" name="GUID-72B9F965-1889-44D6-A0E7-27868DAAF155"></a><h4 id="ADDCI-GUID-72B9F965-1889-44D6-A0E7-27868DAAF155" class="sect4"><span class="enumeration_section">16.3.1</span>功能实现</h4>
                  <div>
                     <p>考虑比较运算符的功能实现。<a href="example-for-PSBTREE-extensible-indexing.html#GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B">实现EQUALS运算符</a>部分解释了如何实现<code class="codeph">eq</code> （等于）， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF">实现</a>少量<a href="example-for-PSBTREE-extensible-indexing.html#GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF">运算符</a>部分解释了如何实现<code class="codeph">lt</code> （小于），并且<a href="example-for-PSBTREE-extensible-indexing.html#GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242">实现GREAT THAN运算符</a>部分解释了如何实现<code class="codeph">gt</code> （大于）运算符。
                     </p>
                  </div><a id="CACFGDEF"></a><div class="props_rev_3"><a id="GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B" name="GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B"></a><h5 id="ADDCI-GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B" class="sect5"><span class="enumeration_section">16.3.1.1</span>实现EQUALS运算符</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">eq</code>的功能实现由函数（ <code class="codeph">bt_eq</code> ）提供，该函数接收两个<code class="codeph">VARCHAR2</code>参数，如果它们相等则返回<code class="codeph">1</code> ，否则返回<code class="codeph">0</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION bt_eq(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
&nbsp;&nbsp;IF a = b then
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 1;
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 0;
&nbsp;&nbsp;END IF;
END;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBEEIH"></a><div class="props_rev_3"><a id="GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF" name="GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF"></a><h5 id="ADDCI-GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF" class="sect5"><span class="enumeration_section">16.3.1.2</span>实现<span class="enumeration_section">少于</span>运营商</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">lt</code>的函数实现由函数（ <code class="codeph">bt_lt</code> ）提供，该函数接收两个<code class="codeph">VARCHAR2</code>参数，如果第一个参数小于第二个参数则返回<code class="codeph">1</code> ，否则返回<code class="codeph">0</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION bt_lt(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
&nbsp;&nbsp;IF a &lt; b then
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 1;
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 0;
&nbsp;&nbsp;END IF;
END;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACDGGHF"></a><div class="props_rev_3"><a id="GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242" name="GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242"></a><h5 id="ADDCI-GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242" class="sect5"><span class="enumeration_section">16.3.1.3</span>实施<span class="enumeration_section">大于</span>运营商</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">gt</code>的功能实现由函数（ <code class="codeph">bt_gt</code> ）提供，该函数接收两个<code class="codeph">VARCHAR2</code>参数，如果第一个参数大于第二个参数则返回<code class="codeph">1</code> ，否则返回<code class="codeph">0</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION bt_gt(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
&nbsp;&nbsp;IF a &gt; b then
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 1;
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 0;
&nbsp;&nbsp;END IF;
END;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4885"></a><a id="ADDCI4886"></a><a id="ADDCI4887"></a><a id="ADDCI4884"></a><div class="props_rev_3"><a id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B" name="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B"></a><h4 id="ADDCI-GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B" class="sect4"><span class="enumeration_section">16.3.2</span>运营商</h4>
                  <div>
                     <p>要创建运算符，必须指定运算符的签名及其返回类型及其功能实现。<a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">例16-1</a>显示了如何创建<code class="codeph">eq</code> （等于）， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">例16-2</a>显示了如何创建<code class="codeph">lt</code> （小于）， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">例16-3</a>显示了如何创建<code class="codeph">gt</code> （大于）运算符。
                     </p>
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">
                        <p class="titleinexample">例16-1创建EQUALS运算符</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR eq 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_eq;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">
                        <p class="titleinexample">例16-2创建少数运算符</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR lt 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_lt;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">
                        <p class="titleinexample">示例16-3创建更大的运算符</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR gt 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_gt;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4888"></a><div class="props_rev_3"><a id="GUID-F76F035E-4432-4555-9039-2E66E064D67E" name="GUID-F76F035E-4432-4555-9039-2E66E064D67E"></a><h3 id="ADDCI-GUID-F76F035E-4432-4555-9039-2E66E064D67E" class="sect3"><span class="enumeration_section">16.4</span>实现ODCIIndex接口</h3>
               <div>
                  <p>要实现<code class="codeph">PSBTREE</code> ，您必须实现<code class="codeph">ODCIIndex</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>例程。您可以使用Oracle支持的任何语言实现索引例程。本讨论使用C编程语言实现<a href="extensible-indexing-interface.html#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces（）</a>例程。请注意，这些需要提前设置，例如为已编译的C代码创建库对象<code class="codeph">extdemo6l</code> 。
                  </p>
               </div><a id="ADDCI4890"></a><a id="ADDCI4889"></a><div class="props_rev_3"><a id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1" name="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1"></a><h4 id="ADDCI-GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1" class="sect4"><span class="enumeration_section">16.4.1</span>定义PSBTREE的实现类型</h4>
                  <div>
                     <div class="section">
                        <p>定义实现<code class="codeph">ODCIIndex</code>接口例程的实现类型，如<a href="example-for-PSBTREE-extensible-indexing.html#GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">例16-4所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">
                        <p class="titleinexample">示例16-4创建PSBTREE索引类型</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE psbtree_im AUTHID CURRENT_USER AS OBJECT
(
&nbsp;&nbsp;scanctx RAW(4),
&nbsp;&nbsp;STATIC FUNCTION ODCIGetInterfaces(ifclist OUT SYS.ODCIObjectList)
&nbsp;&nbsp;&nbsp;&nbsp;RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexCreate (ia SYS.ODCIIndexInfo, parms VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexAlter (ia sys.ODCIIndexInfo, 
&nbsp;&nbsp;&nbsp;&nbsp;parms IN OUT VARCHAR2, altopt number, env sys.ODCIEnv) RETURN NUMBER, 
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexDrop(ia SYS.ODCIIndexInfo, env SYS.ODCIEnv) 
&nbsp;&nbsp;&nbsp;&nbsp;RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexExchangePartition(ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;&nbsp;&nbsp;ia1 SYS.ODCIIndexInfo, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexUpdPartMetadata(ia sys.ODCIIndexInfo, 
&nbsp;&nbsp;&nbsp;&nbsp;palist sys.ODCIPartInfoList, env sys.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexInsert(ia SYS.ODCIIndexInfo, rid VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;newval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexDelete(ia SYS.ODCIIndexInfo, rid VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;oldval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexUpdate(ia SYS.ODCIIndexInfo, rid VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;oldval VARCHAR2, newval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexStart(sctx IN OUT psbtree_im, ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;&nbsp;&nbsp;op SYS.ODCIPredInfo, qi sys.ODCIQueryInfo, strt number, stop number,
&nbsp;&nbsp;&nbsp;&nbsp;cmpval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;MEMBER FUNCTION ODCIIndexFetch(nrows NUMBER, rids OUT SYS.ODCIridlist,
&nbsp;&nbsp;&nbsp;&nbsp;env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;MEMBER FUNCTION ODCIIndexClose(env SYS.ODCIEnv) RETURN NUMBER
);
/
SHOW ERRORS</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4892"></a><a id="ADDCI4891"></a><div class="props_rev_3"><a id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8" name="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8"></a><h4 id="ADDCI-GUID-2616416C-EC74-41FD-B435-7956E4CB49E8" class="sect4"><span class="enumeration_section">16.4.2</span>创建实现类型主体</h4>
                  <div>
                     <div class="section">
                        <p>定义实现类型主体，如<a href="example-for-PSBTREE-extensible-indexing.html#GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">例16-5所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">
                        <p class="titleinexample">示例16-5为PBSTREE创建实现主体</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE BODY psbtree_im IS </pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4893"></a><div class="props_rev_3"><a id="GUID-385BF144-F676-468E-A9A6-7633E0939A1A" name="GUID-385BF144-F676-468E-A9A6-7633E0939A1A"></a><h4 id="ADDCI-GUID-385BF144-F676-468E-A9A6-7633E0939A1A" class="sect4"><span class="enumeration_section">16.4.3</span>在实现主体中定义PL / SQL例程</h4>
                  <div>
                     <div class="section">
                        <p>考虑如何在PL / SQL中实现索引定义例程。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADDCI4894"></a><div class="props_rev_3"><a id="GUID-CD482284-5973-4954-9086-DAFD9E872FE7" name="GUID-CD482284-5973-4954-9086-DAFD9E872FE7"></a><h5 id="ADDCI-GUID-CD482284-5973-4954-9086-DAFD9E872FE7" class="sect5"><span class="enumeration_section">16.4.3.1</span>在PL / SQL中为<span class="enumeration_section">PBSTREE</span>实现ODCIGetInterfaces（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces（）</a>例程通过其<code class="codeph">OUT</code>参数返回预期的接口名称。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIGetInterfaces(
&nbsp;&nbsp;ifclist OUT sys.ODCIObjectList) 
RETURN NUMBER IS
BEGIN
&nbsp;&nbsp;ifclist := sys.ODCIObjectList(sys.ODCIObject('SYS','ODCIINDEX2'));
&nbsp;&nbsp;RETURN ODCIConst.Success;
END ODCIGetInterfaces;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACGFBIH"></a><div class="props_rev_3"><a id="GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83" name="GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83"></a><h5 id="ADDCI-GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83" class="sect5"><span class="enumeration_section">16.4.3.2</span>在PL / SQL中为<span class="enumeration_section">PBSTREE</span>实现ODCIIndexCreate（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-C14A0478-6EA1-4EAE-BAA6-AA59EE5D300C">ODCIIndexCreate（）</a>例程创建一个包含两列的系统分区索引存储表。第一列存储<code class="codeph">VARCHAR2</code>索引列值。该例程利用传入的信息来确定调用它的上下文。动态SQL用于执行动态构造的SQL语句。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexCreate (
  ias sys.ODCIIndexInfo,
  parms VARCHAR2,
  env sys.ODCIEnv)
RETURN NUMBER IS
  i INTEGER;
  stmt VARCHAR2(2000);
  cursor cur1(ianame VARCHAR2) IS
    SELECT partition_name, parameters
    FROM user_ind_partitions
    WHERE index_name = ianame
    ORDER BY partition_position;
  cursor cur2(ianame VARCHAR2) IS
    SELECT subpartition_name, parameters
    FROM user_ind_subpartitions
    WHERE index_name = ianame
    ORDER BY partition_position, subpartition_position;
BEGIN
  stmt := '';
  
  IF (env.CallProperty is null) THEN
    stmt := 'create table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree(f1 VARCHAR2(1000), f2 rowid)';
  
  ELSIF (env.CallProperty = sys.ODCIConst.FirstCall) THEN
    stmt := '';
    i := 1;
    
    IF (bitand(ia.IndexInfoFlags, ODCIConst.CompPartn) = 0) THEN
      FOR c1 in cur1(ia.IndexName) LOOP
        IF (i &gt; 1) THEN
          stmt := stmt || ',';
        END IF;
        stmt := stmt || 'partition ' || c2.partition_name;
        i := i + 1;
      END LOOP;
    ELSE
      FOR c1 in cur1(ia.IndexName) LOOP
        IF (i &gt; 1) THEN
          stmt := stmt || ',';
        END IF;
        stmt := stmt || 'partition ' || c2.subpartition_name;
        i := i + 1;
      END LOOP;
    END IF;
    stmt := 'create table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree (f1 VARCHAR2(1000), f2 rowid) partition by system ' ||
      '(' || stmt || ')';
  
  ELSIF (env.CallProperty = sys.ODCIConst.FinalCall) THEN
    stmt := 'create index ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbti on ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree (f1) local';
  END IF;
  
  dbms_output.put_line('Create');
  dbms_output.put_line(stmt);
  
  -- execute the statement
  IF ((env.CallProperty is null) OR
      (env.CallProperty = sys.ODCIConst.FirstCall) OR
      (env.CallProperty = sys.ODCIConst.FinalCall) ) THEN
    execute immediate stmt;
  
    IF (env.CallProperty is null) THEN
      execute immediate 'insert into ' || ia.IndexSchema || '.' || ia.IndexName
        || '_sbtree select ' || ia.IndexCols(1).ColName || ', ROWID from ' ||
        ia.IndexCols(1).TableSchema || '.' || ia.IndexCols(1).TableName;
      execute immediate 'create index ' || ia.IndexSchema || '.' ||
        ia.IndexName || '_sbti on ' || ia.IndexSchema || '.' ||
        ia.IndexName || '_sbtree (f1)';
    END IF;
  END IF;
  
  RETURN ODCIConst.Success;
END ODCIIndexCreate;
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACDJCFF"></a><div class="props_rev_3"><a id="GUID-43232667-0102-4BCD-9C00-D106F8D049D2" name="GUID-43232667-0102-4BCD-9C00-D106F8D049D2"></a><h5 id="ADDCI-GUID-43232667-0102-4BCD-9C00-D106F8D049D2" class="sect5"><span class="enumeration_section">16.4.3.3</span>在PL / SQL中为<span class="enumeration_section">PBSTREE</span>实现ODCIIndexDrop（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-F128CB3B-6B3E-41C3-A623-67BCB5BC9292">ODCIIndexDrop（）</a>例程删除索引存储表。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexDrop(
&nbsp;&nbsp;ia sys.ODCIIndexInfo,
&nbsp;&nbsp;env sys.ODCIEnv) 
RETURN NUMBER IS
&nbsp;&nbsp;stmt VARCHAR2(1000);
&nbsp;&nbsp;cnum INTEGER;
&nbsp;&nbsp;junk INTEGER;
BEGIN
&nbsp;&nbsp;-- construct the sql statement
&nbsp;&nbsp;stmt := '';

&nbsp;&nbsp;IF (env.CallProperty is null) THEN
&nbsp;&nbsp;&nbsp;&nbsp;stmt := 'drop table ' || ia.IndexSchema || '.' || ia.IndexName || '_sbtree';
&nbsp;&nbsp;&nbsp;&nbsp;dbms_output.put_line('Drop');
&nbsp;&nbsp;&nbsp;&nbsp;dbms_output.put_line(stmt);
&nbsp;&nbsp;&nbsp;&nbsp;execute immediate stmt;
&nbsp;&nbsp;END IF;
&nbsp;&nbsp;RETURN ODCIConst.Success;
END ODCIIndexDrop;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACCCEAE"></a><div class="props_rev_3"><a id="GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878" name="GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878"></a><h5 id="ADDCI-GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878" class="sect5"><span class="enumeration_section">16.4.3.4</span>在PL / SQL中为<span class="enumeration_section">PSBTREE</span>实现ODCIIndexAlter（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-9DB1D609-69C3-483B-AA77-087AD51A3A55">ODCIIndexAlter（）</a>例程可以执行许多索引更改任务，例如重建和重命名索引。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexAlter (
  ia sys.ODCIIndexInfo,
  parms IN OUT VARCHAR2,
  altopt NUMBER,
  env sys.ODCIEnv)
RETURN NUMBER IS
  stmt VARCHAR2(2000);
BEGIN
  stmt := '';
  IF (altopt = ODCIConst.AlterIndexRebuild) THEN
    IF (ia.IndexPartition is null) THEN
      stmt := 'insert into ' || ia.IndexSchema || '.' || ia.IndexName ||
				'_sbtree select ' || ia.IndexCols(1).ColName || ', ROWID from ' ||
				ia.IndexCols(1).ColName || ', ROWID from ' ||
				ia.IndexCols(1).TableSchema || '.' || ia.IndexCols(1).TableName;
    ELSIF (bitand(ia.IndexInfoFlags, ODCIConst.CompPartn) = 0) THEN
      stmt := 'insert into ' || ia.IndexSchema || '.' || ia.IndexName ||
				'_sbtree select partition (' || ia.IndexPartition || ')' ||
				ia.IndexCols(1).ColName || ', ROWID from ' ||     
        ia.IndexCols(1).TableSchema || '.' || ia.IndexCols(1).TableName ||
        ' partition (' || ia.IndexCols(1).TablePartition || ')';
    ELSE
      stmt := 'insert into ' || ia.IndexSchema || '.' || ia.IndexName ||
				'_sbtree select partition (' || ia.IndexPartition || ')' || 
				ia.IndexCols(1).ColName || ', ROWID from ' ||
        ia.IndexCols(1).TableSChema || '.' || ia.IndexCols(1).TableName ||
        ' subpartition (' || ia.IndexCols(1).TablePartition || ')';
    END IF;
    
  ELSIF (altopt = ODCIConst.AlterIndexRename) THEN
    IF (ia.IndexPartition is not null) THEN
      stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
        '_sbtree rename partition ' || ia.IndexPartition || ' to ' || parms;
    ELSE
      stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
        '_sbtree rename to ' || parms || '_sbtree';
    END IF;
  END IF;
  
  dbms_output.put_line('Alter');
  IF ((altopt = ODCIConst.AlterIndexRebuild) OR (altopt = ODCIConst.AlterIndexRename))
  THEN
    dbms_output.put_line(stmt);
    execute immediate stmt;
  END IF;
  RETURN ODCIConst.Success;
END ODCIIndexAlter;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBFDJC"></a><div class="props_rev_3"><a id="GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA" name="GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA"></a><h5 id="ADDCI-GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA" class="sect5"><span class="enumeration_section">16.4.3.5</span>在PL / SQL中为<span class="enumeration_section">PSBTREE</span>实现ODCIIndexUpdPartMetadata（）</h5>
                     <div>
                        <div class="section">
                           <p>为了处理分区维护操作，内核代表用户执行维护任务。indextype用于维护其元数据，应具有<a href="extensible-indexing-interface.html#GUID-C2C4DB40-106A-491C-B241-985B69DC2FE1">ODCIIndexUpdPartMetadata（）</a>例程。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexUpdPartMetadata(
&nbsp;&nbsp;ia sys.ODCIIndexInfo, 
&nbsp;&nbsp;palist sys.ODCIPartInfoList, 
&nbsp;&nbsp;env sys.ODCIEnv) 
RETURN NUMBER IS
&nbsp;&nbsp;col  number;
BEGIN
&nbsp;&nbsp;dbms_output.put_line('ODCIUpdPartMetadata');
&nbsp;&nbsp;sys.ODCIIndexInfoDump(ia);
&nbsp;&nbsp;sys.ODCIPartInfoListDump(palist);
&nbsp;&nbsp;sys.ODCIEnvDump(env);
&nbsp;&nbsp;RETURN ODCIConst.Success;
END ODCIIndexUpdPartMetadata;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJCGBH"></a><div class="props_rev_3"><a id="GUID-395A7999-CD4F-4995-8455-F6D51D3710EF" name="GUID-395A7999-CD4F-4995-8455-F6D51D3710EF"></a><h5 id="ADDCI-GUID-395A7999-CD4F-4995-8455-F6D51D3710EF" class="sect5"><span class="enumeration_section">16.4.3.6</span>在PL / SQL中为<span class="enumeration_section">PSBTREE</span>实现ODCIIndexExchangePartition（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-7914F874-620F-48F1-ADDC-040CC82D46ED">ODCIIndexExchangePartition（）</a>与正在交换的索引分区交换索引存储表，以及全局域索引的索引存储表。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexExchangePartition(
  ia sys.ODCIIndexInfo,
  ia1 sys.ODCIIndexInfo,
  env sys.ODCIEnv)
RETURN NUMBER IS
  stmt VARCHAR2(2000);
  cnum INTEGER;
  junk INTEGER;
BEGIN
  stmt := '';
  dbms_output.put_line('Exchange Partition');
 
  -- construct the sql statements
  IF bitand(ia.IndexInfoFlags, ODCIConst.CompPartn) = 0 OR
     bitand(ia.IndexInfoFlags, ODCIConst.SubPartn) = ODCIConst.SubPartn THEN
    -- non-composite partitioned or exchanging subpartition
    stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree exchange partition ' || ia.IndexPartition || ' with table ' ||
      ia1.IndexSchema || '.' || ia1.IndexName || '_sbtree';
     
    dbms_output.put_line(stmt);
    execute immediate stmt;
  ELSE
    -- composite partition exchange
    stmt := 'create table temp_exch (f1 VARCHAR2(1000), f2 rowid)';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree exchange partition ' || ia.IndexPartition || ' with table ' ||
      'temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    stmt := 'alter table ' || ia1.IndexSchema || '.' || ia1.IndexName ||
      '_sbtree exchange partition ' || ia1.IndexPartition || ' with table ' ||
      'temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree exchange partition ' || ia.IndexPartition || ' with table ' ||
      'temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    -- exchange done, drop temporal table
    stmt := 'drop table temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
  END IF;
 
  RETURN ODCIConst.Success;
END ODCIIndexExchangePartition;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4900"></a><div class="props_rev_3"><a id="GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0" name="GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0"></a><h4 id="ADDCI-GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0" class="sect4"><span class="enumeration_section">16.4.4</span>注册ODCIIndex <span class="italic">XXX</span> （）方法的C实现</h4>
                  <div>
                     <div class="section">
                        <p>为已编译的C方法创建<code class="codeph">extdemo6l</code>库对象后，必须注册每个例程的实现。<a href="example-for-PSBTREE-extensible-indexing.html#GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB">注册ODCIIndexInsert（）</a>部分<a href="example-for-PSBTREE-extensible-indexing.html#GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB">的实现</a>演示了如何注册ODCIIndexInsert（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3">注册实现ODCIIndexDelete（）</a>部分注册ODCIIndexDelete（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-20EAB399-76F5-4C79-AE81-63B8956504F7">注册实现ODCIIndexUpdate（）</a>部分注册ODCIIndexUpdate（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3">注册ODCIIndexStart（）</a>部分<a href="example-for-PSBTREE-extensible-indexing.html#GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3">的实现</a>注册ODCIIndexStart（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE">注册实现ODCIIndexFetch（）</a>部分注册ODCIIndexFetch（）实现，并<a href="example-for-PSBTREE-extensible-indexing.html#GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32">注册实现ODCIIndexClose（）</a>部分注册ODCIIndexClose（）实现。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="CACGAHCG"></a><div class="props_rev_3"><a id="GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB" name="GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB"></a><h5 id="ADDCI-GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB" class="sect5"><span class="enumeration_section">16.4.4.1</span>注册ODCIIndexInsert（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexInsert(
&nbsp;&nbsp;ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;rid VARCHAR2,
&nbsp;&nbsp;newval VARCHAR2,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspi"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;rid,
&nbsp;&nbsp;rid indicator,
&nbsp;&nbsp;newval,
&nbsp;&nbsp;newval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBHAHC"></a><div class="props_rev_3"><a id="GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3" name="GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3"></a><h5 id="ADDCI-GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3" class="sect5"><span class="enumeration_section">16.4.4.2</span>注册ODCIIndexDelete（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-4B2E080D-FE8B-4598-9084-56FBE255196B">ODCIIndexDelete（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexDelete(
&nbsp;&nbsp;ia SYS.ODCIIndexInfo, 
&nbsp;&nbsp;rid VARCHAR2,
&nbsp;&nbsp;oldval VARCHAR2, 
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspd"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;rid,
&nbsp;&nbsp;rid indicator,
&nbsp;&nbsp;oldval,
&nbsp;&nbsp;oldval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBCCEH"></a><div class="props_rev_3"><a id="GUID-20EAB399-76F5-4C79-AE81-63B8956504F7" name="GUID-20EAB399-76F5-4C79-AE81-63B8956504F7"></a><h5 id="ADDCI-GUID-20EAB399-76F5-4C79-AE81-63B8956504F7" class="sect5"><span class="enumeration_section">16.4.4.3</span>注册ODCIIndexUpdate（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-CB42E738-EFD1-4053-9DDF-BEF455F92815">ODCIIndexUpdate（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexUpdate(
&nbsp;&nbsp;ia SYS.ODCIIndexInfo, 
&nbsp;&nbsp;rid VARCHAR2,
&nbsp;&nbsp;oldval VARCHAR2,
&nbsp;&nbsp;newval VARCHAR2,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspu"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;rid,
&nbsp;&nbsp;rid indicator,
&nbsp;&nbsp;oldval,
&nbsp;&nbsp;oldval indicator,
&nbsp;&nbsp;newval,
&nbsp;&nbsp;newval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJADGC"></a><div class="props_rev_3"><a id="GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3" name="GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3"></a><h5 id="ADDCI-GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3" class="sect5"><span class="enumeration_section">16.4.4.4</span>注册ODCIIndexStart（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-53F2321C-B0F8-4783-AC1B-056372A0C073">ODCIIndexStart（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexStart(
&nbsp;&nbsp;sctx IN OUT psbtree_im,
&nbsp;&nbsp;ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;op SYS.ODCIPredInfo,
&nbsp;&nbsp;qi SYS.ODCIQueryInfo,
&nbsp;&nbsp;strt NUMBER,
&nbsp;&nbsp;stop NUMBER,
&nbsp;&nbsp;cmpval VARCHAR2,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbsps"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;sctx,
&nbsp;&nbsp;sctx indicator struct,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;op,
&nbsp;&nbsp;op indicator struct,
&nbsp;&nbsp;qi,
&nbsp;&nbsp;qi indicator struct,
&nbsp;&nbsp;strt,
&nbsp;&nbsp;strt indicator,
&nbsp;&nbsp;stop,
&nbsp;&nbsp;stop indicator,
&nbsp;&nbsp;cmpval,
&nbsp;&nbsp;cmpval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADDCI4905"></a><div class="props_rev_3"><a id="GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE" name="GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE"></a><h5 id="ADDCI-GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE" class="sect5"><span class="enumeration_section">16.4.4.5</span>注册ODCIIndexFetch（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-BB601420-A858-46E3-A9AC-3433220D4F82">ODCIIndexFetch（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">MEMBER FUNCTION ODCIIndexFetch(
&nbsp;&nbsp;nrows NUMBER,
&nbsp;&nbsp;rids OUT SYS.ODCIRidList,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspf"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;self,
&nbsp;&nbsp;self indicator struct,
&nbsp;&nbsp;nrows,
&nbsp;&nbsp;nrows indicator,
&nbsp;&nbsp;rids,
&nbsp;&nbsp;rids indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
 );</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACIDHBA"></a><div class="props_rev_3"><a id="GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32" name="GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32"></a><h5 id="ADDCI-GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32" class="sect5"><span class="enumeration_section">16.4.4.6</span>注册ODCIIndexClose（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-2F49CDE4-C064-4644-948C-BBF014FDD8C8">ODCIIndexClose（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">MEMBER FUNCTION ODCIIndexClose (
&nbsp;&nbsp;env SYS.ODCIEnv) 
RETURN NUMBER AS EXTERNAL
name "qxiqtbspc"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;self,
&nbsp;&nbsp;self indicator struct,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4908"></a><a id="ADDCI4909"></a><a id="ADDCI4907"></a><div class="props_rev_3"><a id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE" name="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE"></a><h4 id="ADDCI-GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE" class="sect4"><span class="enumeration_section">16.4.5</span>在C实现中定义其他结构</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">stuct</code> <code class="codeph">qxiqtim</code> ， <code class="codeph">struct qciqtin</code>和<code class="codeph">struct</code> <code class="codeph">qxiqtcx</code>用于映射对象类型及其<code class="codeph">null</code>值（在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6中</a>演示），以及在获取调用期间保持状态（在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7中</a>演示）。这些结构由<a href="example-for-PSBTREE-extensible-indexing.html#GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4">实施主体</a>中<a href="example-for-PSBTREE-extensible-indexing.html#GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4">定义C方法中</a>描述的方法使用。
                        </p>
                        <p>用于映射ODCI类型的C <code class="codeph">struct</code>在文件<code class="codeph">odci.h</code>中定义。例如，C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo</code>是相应ODCI对象类型的映射。C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo_ind</code>是<code class="codeph">null</code>对象的映射。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">
                        <p class="titleinexample">示例16-6定义对象类型的映射及其空值</p>
                        <p>我们已经定义了一个C <code class="codeph">struct</code> <code class="codeph">qxiqtim</code>作为对象类型的映射。对于相应的<code class="codeph">null</code>对象，还有一个额外的C <code class="codeph">struct</code> <code class="codeph">qxiqtin</code> 。可以从对象类型转换器（OTT）生成对象类型的C <code class="codeph">struct</code>及其<code class="codeph">null</code>对象。
                        </p><pre class="oac_no_warn" dir="ltr">/* The index implementation type is an object type with a single RAW attribute
 * used to store the context key value. 
 * C mapping of the implementation type : */

struct qxiqtim{
&nbsp;&nbsp;OCIRaw *sctx_qxiqtim;
}; 
typedef struct qxiqtim qxiqtim;

struct qxiqtin{
  short atomic_qxiqtin;
  short scind_qxiqtin;
}; 
typedef struct qxiqtin qxiqtin;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">
                        <p class="titleinexample">例16-7在获取呼叫期间保持扫描状态</p>
                        <p>有一组OCI句柄必须在获取调用期间缓存并检索。AC <code class="codeph">struct</code> <code class="codeph">qxiqtcx</code>定义为保存所有必要的扫描状态。此结构从<code class="codeph">OCI_DURATION_STATEMENT</code>内存中分配，以确保它持续到<code class="codeph">fetch</code>结束。在使用所需信息填充结构后，指向结构的指针将保存在OCI上下文中。上下文由通过调用OCI例程生成的4字节密钥标识。4字节密钥存储在扫描上下文中 - <code class="codeph">exiting</code> 。此对象将返回到Oracle服务器，并作为参数传递给下一个fetch调用。
                        </p><pre class="oac_no_warn" dir="ltr">/* The index scan context - should be stored in "statement" duration memory
 * and used by start, fetch and close routines.
 */
struct qxiqtcx
{
&nbsp;&nbsp;OCIStmt *stmthp;
&nbsp;&nbsp;OCIDefine *defnp;
&nbsp;&nbsp;OCIBind *bndp;
&nbsp;&nbsp;char ridp[19];
}; 
typedef struct qxiqtcx qxiqtcx;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4910"></a><div class="props_rev_3"><a id="GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4" name="GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4"></a><h4 id="ADDCI-GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4" class="sect4"><span class="enumeration_section">16.4.6</span>在实施机构中定义C方法</h4>
                  <div>
                     <p>考虑如何在C语言中实现PSBEETree方法。</p>
                  </div><a id="CACJIECE"></a><div class="props_rev_3"><a id="GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C" name="GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C"></a><h5 id="ADDCI-GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C" class="sect5"><span class="enumeration_section">16.4.6.1</span>在C中实现常见错误处理例程</h5>
                     <div>
                        <div class="section">
                           <p>此函数用于检查和处理来自所有<code class="codeph">OCI</code>例程的返回码。它会检查状态代码并在出现错误时引发异常。
                           </p><pre class="oac_no_warn" dir="ltr">static int qxiqtce(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;OCIError *errhp,
&nbsp;&nbsp;sword status)
{
&nbsp;&nbsp;text errbuf[512];
&nbsp;&nbsp;sb4 errcode = 0;
&nbsp;&nbsp;int errnum = 29400;  /* choose some oracle error number */
&nbsp;&nbsp;int rc = 0;

&nbsp;&nbsp;switch (status)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;case OCI_SUCCESS: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case OCI_ERROR:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) OCIErrorGet((dvoid *)errhp, (ub4)1, (text *)NULL, &amp;errcode,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errbuf, (ub4)sizeof(errbuf), OCI_HTYPE_ERROR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Raise exception */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIExtProcRaiseExcpWithMsg(ctx, errnum, errbuf, strlen((char *)errbuf));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) sprintf((char *)errbuf, "Warning - some error\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Raise exception */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIExtProcRaiseExcpWithMsg(ctx, errnum, errbuf, strlen((char *)errbuf));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;}
&nbsp;&nbsp;return (rc);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJJDAC"></a><div class="props_rev_3"><a id="GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB" name="GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB"></a><h5 id="ADDCI-GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB" class="sect5"><span class="enumeration_section">16.4.6.2</span>实施ODCIIndexInsert（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>插入例程<a href="extensible-indexing-interface.html#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert（）</a>解析并执行一个将新行插入索引表的语句。新行包含索引列的新值和作为参数传入的<code class="codeph">rowid</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspi(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;char              *rid,
&nbsp;&nbsp;short             rid_ind,
&nbsp;&nbsp;char              *newval,
&nbsp;&nbsp;short             newval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;         /* error handle */
&nbsp;&nbsp;OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
&nbsp;&nbsp;OCIBind *bndp = (OCIBind *) 0;            /* bind handle */

&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;           /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;char insstmt[2000];                       /* sql insert statement */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                    /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                    /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                     /* index info flag  

&nbsp;&nbsp;/* allocate memory for OCINumber first */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));

&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/*****************************
&nbsp;&nbsp;* Construct insert Statement *
&nbsp;&nbsp;******************************/
&nbsp;&nbsp;if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(insstmt, "INSERT into %s.%s_sbtree values (:newval, :mrid)",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, (OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;(void)sprintf(insstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"INSERT into %s.%s_sbtree partition (DATAOBJ_TO_PARTITION(%s, :partiden))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUES (:newval, :mrid)",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName));
&nbsp;&nbsp;}

&nbsp;&nbsp;/***************************************
&nbsp;&nbsp;* Parse and Execute Create Statement   *
&nbsp;&nbsp;****************************************/

&nbsp;&nbsp;/* allocate stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;&nbsp;&nbsp;/* prepare the statement */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)insstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(insstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;(colinfo-&gt;TablePartitionIden), sizeof(partiden), OCI_NUMBER_UNSIGNED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for partiden */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text *)":partiden", sizeof(":partiden")-1, (dvoid *)&amp;partiden,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for newval */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":newval",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":newval")-1, (dvoid *)newval, (sb4)(strlen(newval)+1),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for rid */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":mrid",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":mrid")-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Execute statement */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;&nbsp;&nbsp;/* free stmt handle */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACFICAJ"></a><div class="props_rev_3"><a id="GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19" name="GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19"></a><h5 id="ADDCI-GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19" class="sect5"><span class="enumeration_section">16.4.6.3</span>实施ODCIIndexDelete（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>delete例程构造一个SQL语句，用于从索引表中删除与从基表中删除的行相对应的行。索引表中的行由<code class="codeph">rowid</code>的值标识，该值作为参数传递给此例程。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspd(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;char              *rid,
&nbsp;&nbsp;short             rid_ind,
&nbsp;&nbsp;char              *oldval,
&nbsp;&nbsp;short             oldval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;         /* error handle */
&nbsp;&nbsp;OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
&nbsp;&nbsp;OCIBind *bndp = (OCIBind *) 0;            /* bind handle */
 
&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;           /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;
 
&nbsp;&nbsp;char delstmt[2000];                       /* sql delete statement */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                    /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                    /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                     /* index info flag  
 
&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;/*****************************
&nbsp;&nbsp;* Construct delete Statement *
&nbsp;&nbsp;******************************/
&nbsp;&nbsp;if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(delstmt, "DELETE FROM %s.%s_sbtree WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, (OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(delstmt, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"DELETE FROM %s.%s_sbtree partition (DATAOBJ_TO_PARTITION(%s, :partiden))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName));
&nbsp;&nbsp;}

&nbsp;&nbsp;/***************************************
&nbsp;&nbsp;* Parse and Execute delete Statement   *
&nbsp;&nbsp;****************************************/

/* allocate stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

/* prepare the statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)delstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(delstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(colinfo-&gt;TablePartitionIden),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(partiden), OCI_NUMBER_UNSIGNED, ( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for partiden */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(text *)":partiden", sizeof(":partiden")-1, (dvoid *)&amp;partiden,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/* Set up bind for rid */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":rr")-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Execute statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1, (ub4)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* free stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9" name="GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9"></a><h5 id="ADDCI-GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9" class="sect5"><span class="enumeration_section">16.4.6.4</span>实施ODCIIndexUpdate（）为PSBTree用C</h5>
                     <div>
                        <div class="section">
                           <p>update例程构造一个SQL语句来更新索引表中与基表中正在更新的行相对应的行。索引表中的行由<code class="codeph">rowid</code>的值标识，该值作为参数传递给此例程。旧列值（ <code class="codeph">oldval</code> ）将替换为新值（ <code class="codeph">newval</code> ）。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspu(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;char              *rid,
&nbsp;&nbsp;short             rid_ind,
&nbsp;&nbsp;char              *oldval,
&nbsp;&nbsp;short             oldval_ind,
&nbsp;&nbsp;char              *newval,
&nbsp;&nbsp;short             newval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;         /* error handle */
&nbsp;&nbsp;OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
&nbsp;&nbsp;OCIBind *bndp = (OCIBind *) 0;            /* bind handle */

&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;           /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;char updstmt[2000];                       /* sql upate statement */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                    /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                    /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                     /* index info flag  

&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/*****************************
&nbsp;&nbsp;* Construct update Statement *
&nbsp;&nbsp;******************************/
&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(updstmt, "UPDATE %s.%s_sbtree SET f1 = :newval WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(updstmt, "UPDATE %s.%s_sbtree partition 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(DATAOBJ_TO_PARTITION(%s, :partiden)) SET f1 = :newval WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName));
&nbsp;&nbsp;}

&nbsp;&nbsp;/****************************************
&nbsp;&nbsp;* Parse and Execute Create Statement   *
&nbsp;&nbsp;****************************************/

&nbsp;&nbsp;/* allocate stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* prepare the statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)updstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(updstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;(colinfo-&gt;TablePartitionIden), sizeof(partiden), OCI_NUMBER_UNSIGNED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for partiden */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(text *)":partiden", sizeof(":partiden")-1, (dvoid *)&amp;partiden,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/* Set up bind for newval */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":newval",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":newval")-1, (dvoid *)newval, (sb4)(strlen(newval)+1), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Set up bind for rid */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":rr")-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Execute statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* free stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83" name="GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83"></a><h5 id="ADDCI-GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83" class="sect5"><span class="enumeration_section">16.4.6.5</span>实施ODCIIndexStart（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>启动例程执行<code class="codeph">psbtree</code>索引扫描的设置。根据运算符谓词，其参数和返回值的边界的查询信息作为参数传递给此函数。索引扫描例程之间共享的扫描上下文是<code class="codeph">psbtree_im</code>类型的实例。
                           </p>
                           <p>此函数设置扫描索引表的游标。扫描检索索引表中满足指定谓词的行的存储rowid。索引表的谓词是基于作为参数传入的运算符谓词信息生成的。例如，如果运算符谓词的形式为<code class="codeph">eq(col, 'joe') = 1</code> ，则索引表上的谓词设置为<code class="codeph">f1 = 'joe'</code> 。
                           </p>
                           <p>该函数使用<code class="codeph">struct</code> s <code class="codeph">qxiqtim</code> ， <code class="codeph">qxiqtin</code>和<code class="codeph">qxiqtcx</code> ，它们在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6</a>和<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7中</a>进行了演示。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbsps(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;qxiqtim           *sctx,
&nbsp;&nbsp;qxiqtin           *sctx_ind,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;ODCIPredInfo      *pr,
&nbsp;&nbsp;ODCIPredInfo_ind  *pr_ind,
&nbsp;&nbsp;ODCIQueryInfo     *qy,
&nbsp;&nbsp;ODCIQueryInfo_ind *qy_ind,
&nbsp;&nbsp;OCINumber         *strt,
&nbsp;&nbsp;short             strt_ind,
&nbsp;&nbsp;OCINumber         *stop,
&nbsp;&nbsp;short             stop_ind,
&nbsp;&nbsp;char              *cmpval,
&nbsp;&nbsp;short             cmpval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;sword status;
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;                          /* error handle */
&nbsp;&nbsp;OCISession *usrhp = (OCISession *) 0;                       /* user handle */
&nbsp;&nbsp;qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

&nbsp;&nbsp;int strtval;                   /* start bound */
&nbsp;&nbsp;int stopval;                   /* stop bound */

&nbsp;&nbsp;int errnum = 29400;            /* choose some oracle error number */
&nbsp;&nbsp;char errmsg[512];              /* error message buffer */
&nbsp;&nbsp;size_t errmsglen;              /* Length of error message */

&nbsp;&nbsp;char relop[3];                 /* relational operator used in sql stmt */
&nbsp;&nbsp;char selstmt[2000];            /* sql select statement */

&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;       /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;
&nbsp;&nbsp;ub4 key;                              /* key value set in "sctx" */

&nbsp;&nbsp;ub1 *rkey;                            /* key to retrieve context */
&nbsp;&nbsp;ub4 rkeylen;                          /* length of key */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                 /* index info flag  

&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get the user handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;usrhp, (ub4 *)0, (ub4)OCI_ATTR_SESSION, errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/**********************************************/
&nbsp;&nbsp;/* Allocate memory to hold index scan context */
&nbsp;&nbsp;/**********************************************/
&nbsp;&nbsp;if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIMemoryAlloc((dvoid *)usrhp, errhp, (dvoid **)&amp;icx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_DURATION_STATEMENT, (ub4)(sizeof(qxiqtcx)), OCI_MEMORY_CLEARED)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;icx-&gt;stmthp = (OCIStmt *)0;
&nbsp;&nbsp;icx-&gt;defnp = (OCIDefine *)0;
&nbsp;&nbsp;icx-&gt;bndp = (OCIBind *)0;
&nbsp;&nbsp;}

&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/*************************/
&nbsp;&nbsp;&nbsp;&nbsp;/* Retrieve scan context */
&nbsp;&nbsp;&nbsp;&nbsp;/*************************/
&nbsp;&nbsp;&nbsp;&nbsp;rkey = OCIRawPtr(envhp, sctx-&gt;sctx_qxiqtim);
&nbsp;&nbsp;&nbsp;&nbsp;rkeylen = OCIRawSize(envhp, sctx-&gt;sctx_qxiqtim);

&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rkey, (ub1)rkeylen, (dvoid **)&amp;(icx))))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;/* Check that the bounds are valid */
&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;/* convert from oci numbers to native numbers */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, strt, sizeof(strtval), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_NUMBER_SIGNED, (dvoid *)&amp;strtval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, stop, sizeof(stopval),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_NUMBER_SIGNED, (dvoid *)&amp;stopval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* verify that strtval/stopval are both either 0 or 1 */
&nbsp;&nbsp;if (!(((strtval == 0) &amp;&amp; (stopval == 0)) || ((strtval == 1) &amp;&amp; (stopval == 1))))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(errmsg, (char *)"Incorrect predicate for sbtree operator");
&nbsp;&nbsp;&nbsp;&nbsp;errmsglen = (size_t)strlen(errmsg);
&nbsp;&nbsp;&nbsp;&nbsp;if (OCIExtProcRaiseExcpWithMsg(ctx, errnum, (text *)errmsg, errmsglen)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!= OCIEXTPROC_SUCCESS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use cartridge error services here */;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;/*********************************************/
&nbsp;&nbsp;/* Generate the SQL statement to be executed */
&nbsp;&nbsp;/*********************************************/
&nbsp;&nbsp;if (memcmp((dvoid *)OCIStringPtr(envhp, pr-&gt;ObjectName), (dvoid *)"EQ", 2) == 0)
&nbsp;&nbsp;&nbsp;&nbsp;if (strtval == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"=");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"!=");
&nbsp;&nbsp;&nbsp;&nbsp;else if 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memcmp((dvoid *)OCIStringPtr(envhp, pr-&gt;ObjectName), (dvoid *)"LT",2) == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strtval == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&lt;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&gt;=");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strtval == 1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&gt;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&lt;=");

&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(selstmt, "select f2 from %s.%s_sbtree where f1 %s :val",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relop);
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(colinfo-&gt;TablePartitionIden),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(partiden), OCI_NUMBER_UNSIGNED, ( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;(void)sprintf(selstmt, "select f2 from %s.%s_sbtree partition 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(DATAOBJ_TO_PARTITION(%s, %d)) where f1 %s :val",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName), partiden, relop);
&nbsp;&nbsp;}
&nbsp;&nbsp;
&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;/* Parse, bind, define and execute */
&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* allocate stmt handle */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid **)&amp;(icx-&gt;stmthp), (ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/* prepare the statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(icx-&gt;stmthp, errhp, (text *)selstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(selstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Set up bind for compare value */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(icx-&gt;stmthp, &amp;(icx-&gt;bndp), errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(text *)":val", sizeof(":val")-1, (dvoid *)cmpval, (sb4)(strlen(cmpval)+1),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Set up define */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIDefineByPos(icx-&gt;stmthp, &amp;(icx-&gt;defnp), errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)1, (dvoid *)(icx-&gt;ridp), (sb4) sizeof(icx-&gt;ridp), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* execute */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, icx-&gt;stmthp, errhp, (ub4)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/************************************/
&nbsp;&nbsp;/* Set index context to be returned */
&nbsp;&nbsp;/************************************/
&nbsp;&nbsp;if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* generate a key */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGenerateKey((dvoid *)usrhp, errhp, &amp;key)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* set the memory address of the struct to be saved in the context */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextSetValue((dvoid *)usrhp, errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_DURATION_STATEMENT, (ub1 *)&amp;key, (ub1)sizeof(key), (dvoid *)icx)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* statement duration memory alloc for key */ 
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIMemoryAlloc(( void *)usrhp, errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( void **)&amp;(sctx-&gt;sctx_qxiqtim), OCI_DURATION_STATEMENT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)(sizeof(key)+sizeof(ub4)), OCI_MEMORY_CLEARED)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* set the key as the member of "sctx" */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIRawAssignBytes(envhp, errhp, (ub1 *)&amp;key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4)sizeof(key), &amp;(sctx-&gt;sctx_qxiqtim))))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind-&gt;atomic_qxiqtin = OCI_IND_NOTNULL;
&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind-&gt;scind_qxiqtin = OCI_IND_NOTNULL;

&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACGCEBA"></a><div class="props_rev_3"><a id="GUID-9034448B-7A7C-4A11-A904-6E8954792162" name="GUID-9034448B-7A7C-4A11-A904-6E8954792162"></a><h5 id="ADDCI-GUID-9034448B-7A7C-4A11-A904-6E8954792162" class="sect5"><span class="enumeration_section">16.4.6.6</span>实施ODCIIndexFetch（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>由start程序设置的扫描上下文作为参数传递给fetch例程。此函数首先从扫描上下文中检索4字节密钥。扫描上下文的C映射是<code class="codeph">qxiqtim</code> （参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6</a> ）。接下来，key用于查找OCI上下文。这给出了保存OCI句柄的<code class="codeph">qxiqtcx</code>结构的内存地址（参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7</a> ）。
                           </p>
                           <p>此函数返回满足运算符谓词的下一批rowid。它使用<code class="codeph">nrows</code>参数的值作为批处理的大小。它从打开的游标重复获取rowid并填充<code class="codeph">rowid</code>列表。当批处理已满或没有剩余rowid时，该函数会将它们返回给Oracle服务器。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspf(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;qxiqtim           *self,
&nbsp;&nbsp;qxiqtin           *self_ind,
&nbsp;&nbsp;OCINumber         *nrows,
&nbsp;&nbsp;short             nrows_ind,
&nbsp;&nbsp;OCIArray          **rids,
&nbsp;&nbsp;short             *rids_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;sword status;
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;                          /* error handle */
&nbsp;&nbsp;OCISession *usrhp = (OCISession *) 0;                       /* user handle */
&nbsp;&nbsp;qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

&nbsp;&nbsp;int idx = 1;
&nbsp;&nbsp;int nrowsval;

&nbsp;&nbsp;OCIArray *ridarrp = *rids;                  /* rowid collection */
&nbsp;&nbsp;OCIString *ridstr = (OCIString *)0;

&nbsp;&nbsp;int done = 0;
&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;ub1 *key;                                   /* key to retrieve context */
&nbsp;&nbsp;ub4 keylen;                                 /* length of key */

&nbsp;&nbsp;/*******************/
&nbsp;&nbsp;/* Get OCI handles */
&nbsp;&nbsp;/*******************/
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get the user handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;usrhp, (ub4 *)0, (ub4)OCI_ATTR_SESSION, errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;/* Retrieve context from key    */
&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;key = OCIRawPtr(envhp, self-&gt;sctx_qxiqtim);
&nbsp;&nbsp;keylen = OCIRawSize(envhp, self-&gt;sctx_qxiqtim);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp, key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub1)keylen, (dvoid **)&amp;(icx))))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get value of nrows */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, nrows, sizeof(nrowsval),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_NUMBER_SIGNED, (dvoid *)&amp;nrowsval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/****************/
&nbsp;&nbsp;/* Fetch rowids */
&nbsp;&nbsp;/****************/
&nbsp;&nbsp;while (!done)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (idx &gt; nrowsval)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = 1;
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status =OCIStmtFetch(icx-&gt;stmthp, errhp, (ub4)1, (ub2) 0, (ub4)OCI_DEFAULT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (status == OCI_NO_DATA)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short col_ind = OCI_IND_NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* have to create dummy oci string */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringAssignText(envhp, errhp, (text *)"dummy", (ub2)5, &amp;ridstr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* append null element to collection */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollAppend(envhp, errhp, (dvoid *)ridstr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;col_ind, (OCIColl *)ridarrp)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (status == OCI_SUCCESS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringAssignText(envhp, errhp, (text *)icx-&gt;ridp, (ub2)18, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIString **)&amp;ridstr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* append rowid to collection */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollAppend(envhp, errhp, (dvoid *)ridstr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (OCIColl *)ridarrp)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (qxiqtce(ctx, errhp, status))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}

&nbsp;&nbsp;/* free ridstr finally */
&nbsp;&nbsp;if (ridstr &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qxiqtce(ctx, errhp, OCIStringResize(envhp, errhp, (ub4)0, &amp;ridstr))))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;*rids_ind = OCI_IND_NOTNULL;

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBFHDA"></a><div class="props_rev_3"><a id="GUID-43F5A575-F265-43F0-A513-6495057E0BC4" name="GUID-43F5A575-F265-43F0-A513-6495057E0BC4"></a><h5 id="ADDCI-GUID-43F5A575-F265-43F0-A513-6495057E0BC4" class="sect5"><span class="enumeration_section">16.4.6.7</span>实施ODCIIndexClose（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>由start例程设置的扫描上下文作为参数传递给close例程。此函数首先从扫描上下文中检索4字节密钥。扫描上下文的C映射是<code class="codeph">qxiqtim</code> （参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6</a> ）。接下来，基于密钥查找OCI上下文。这给出了保存OCI句柄的结构的内存地址，即<code class="codeph">qxiqtcx</code>结构（参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7</a> ）。
                           </p>
                           <p>此函数关闭并释放所有OCI句柄。它还释放了在启动例程中分配的内存。</p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspc(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;qxiqtim           *self,
&nbsp;&nbsp;qxiqtin           *self_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;sword status;
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;                          /* error handle */
&nbsp;&nbsp;OCISession *usrhp = (OCISession *) 0;                       /* user handle */
&nbsp;&nbsp;qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

&nbsp;&nbsp;int retval = (int) ODCI_SUCCESS;
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;ub1 *key;                                   /* key to retrieve context */
&nbsp;&nbsp;ub4 keylen;                                 /* length of key */

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get the user handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;usrhp, (ub4 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_ATTR_SESSION, errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;/* Retrieve context using key   */
&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;key = OCIRawPtr(envhp, self-&gt;sctx_qxiqtim);
&nbsp;&nbsp;keylen = OCIRawSize(envhp, self-&gt;sctx_qxiqtim);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp, key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub1)keylen, (dvoid **)&amp;(icx))))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Free handles and memory */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)icx-&gt;stmthp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIMemoryFree((dvoid *)usrhp, errhp, (dvoid *)icx)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* free the memory allocated for the index context. */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextClearValue((dvoid *)usrhp, errhp, key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub1)keylen)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="CACGICCC"></a><div class="props_rev_3"><a id="GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2" name="GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2"></a><h4 id="ADDCI-GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2" class="sect4"><span class="enumeration_section">16.4.7</span>为PSBTREE实现Indextype</h4>
                  <div>
                     <p>您应该创建indextype对象并指定它支持的运算符列表。此外，指定实现ODCIIndexXXX（）接口例程的实现类型的名称。</p><pre class="oac_no_warn" dir="ltr">CREATE INDEXTYPE psbtree
FOR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq(VARCHAR2, VARCHAR2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lt(VARCHAR2, VARCHAR2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gt(VARCHAR2, VARCHAR2)
USING psbtree_im
WITH LOCAL RANGE PARTITION
WITH SYSTEM MANAGED STORAGE TABLES</pre></div>
               </div>
            </div><a id="ADDCI4920"></a><div class="props_rev_3"><a id="GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F" name="GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F"></a><h3 id="ADDCI-GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F" class="sect3"><span class="enumeration_section">16.5</span>使用PSBTREE</h3>
               <div>
                  <p>接下来应该创建indextype对象并指定它支持的运算符列表。此外，指定实现<code class="codeph">ODCIIndex</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>接口例程的实现类型的名称。此步骤在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2">实现PSBTREE的索引类型</a>部分中<a href="example-for-PSBTREE-extensible-indexing.html#GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2">进行了演示</a> 。
                  </p>
                  <p>一个典型的使用场景是创建一个范围分区表并填充它，如<a href="example-for-PSBTREE-extensible-indexing.html#GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2">为PSBTREE创建和</a>填充<a href="example-for-PSBTREE-extensible-indexing.html#GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2">分区表</a>部分所示。
                  </p>
                  <p>然后，您可以在列<code class="codeph">f2</code>上创建<code class="codeph">psbtree</code>索引。<code class="codeph">CREATE INDEX</code>语句指定应使用的<a href="example-for-PSBTREE-extensible-indexing.html#GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D">索引类型</a> ，如“在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D">列上创建PSBTREE索引”</a>部分所示。
                  </p>
                  <p>要执行使用其中一个<code class="codeph">psbtree</code>运算符的查询，请使用“ <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C">查询”</a>部分中的“ <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C">使用PSBTREE运算符”中</a>的代码。
                  </p>
               </div><a id="CACCEACF"></a><div class="props_rev_3"><a id="GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2" name="GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2"></a><h4 id="ADDCI-GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2" class="sect4"><span class="enumeration_section">16.5.1</span>为PSBTREE创建和填充分区表</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CREATE TABLE t1 (f1 NUMBER, f2 VARCHAR2(200))
PARTITION BY RANGE(f1)
(
&nbsp;&nbsp;PARTITION p1 VALUES LESS THAN (101),
&nbsp;&nbsp;PARTITION p2 VALUES LESS THAN (201),
&nbsp;&nbsp;PARTITION p3 VALUES LESS THAN (301),
&nbsp;&nbsp;PARTITION p4 VALUES LESS THAN (401)
 );
INSERT INTO t1 VALUES (10, 'aaaa');
INSERT INTO t1 VALUES (200, 'bbbb');
INSERT INTO t1 VALUES (100, 'cccc');
INSERT INTO t1 VALUES (300, 'dddd');
INSERT INTO t1 VALUES (400, 'eeee');
COMMIT;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="CACJJHIG"></a><div class="props_rev_3"><a id="GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D" name="GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D"></a><h4 id="ADDCI-GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D" class="sect4"><span class="enumeration_section">16.5.2</span>在列上创建PSBTREE索引</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CREATE INDEX it1 ON t1(f2) iINDEXTYPE IS psbtree LOCAL 
(PARTITION pe1 PARAMETERS('test1'), PARTITION pe2,
 PARTITION pe3, PARTITION pe4 PARAMETERS('test4')) 
PARAMETERS('test');
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="CACHDCED"></a><div class="props_rev_3"><a id="GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C" name="GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C"></a><h4 id="ADDCI-GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C" class="sect4"><span class="enumeration_section">16.5.3</span>在查询中使用PSBTREE运算符</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT * FROMM t1 WHERE eq(f2, 'dddd') = 1 AND f1&gt;101 ;
</pre><p>此查询的解释计划输出应如下所示：</p><pre class="oac_no_warn" dir="ltr">OPERATION            OPTIONS                PARTITION_START       PARTITION_STOP
--------------------------------------------------------------------------------
SELECT STATEMENT
PARTITION RANGE      ITERATOR               2                     4
TABLE ACCESS         BY LOCAL INDEX ROWID   2                     4
DOMAIN INDEX</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>