<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>主机表</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer&#39;s Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer&#39;s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96466-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="embedded-PLSQL.html" title="Previous" type="text/html">
      <link rel="next" href="error-handling-and-diagnostics.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide">
    <meta name="dcterms.isVersionOf" content="LNPCB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="embedded-PLSQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="error-handling-and-diagnostics.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">主机表</li>
            </ol>
            <a id="GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6" name="GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6"></a>
            
            <h2 id="LNPCB-GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6" class="sect2"><span class="enumeration_chapter">7</span>主机表</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用主机表来简化编码并提高程序性能。您将学习如何使用主机表操作Oracle数据，如何使用单个SQL语句操作主机表的所有元素，如何限制处理的表元素数以及如何使用组项表。</p>
               <p>主要部分是：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="host-tables.html#GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB">主机表</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-4946BC15-629C-49F2-B76B-808B7312B23D">主机表的优点</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2">选择表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2">选择表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-3340D08A-431A-45C9-9003-13636C7278C6">插入表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2">使用表格更新</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D">删除表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-96196A54-F463-4D14-809B-39C58FAEA526">使用指标表</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-81265F69-2532-4014-A048-BF0739CC8486">FOR条款</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0">WHERE子句</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前的条款</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A">组项目表作为主机变量</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026">附加阵列插入/选择语法</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19">使用隐式缓冲插入</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB007"></a><a id="LNPCB451"></a><div class="props_rev_3"><a id="GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB" name="GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB"></a><h3 id="LNPCB-GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB" class="sect3"><span class="enumeration_section">7.1</span>主机表</h3>
               <div>
                  <p><span class="italic">主机表</span> （也称为数组） <span class="italic"> </span>是一组与单个变量关联的相关数据项，称为<span class="italic">元素</span> 。定义为表的指示符变量称为<span class="italic">指标表</span> 。指示符表可以与任何NULLABLE主机表相关联。<a id="d45327e124" class="indexterm-anchor"></a><a id="d45327e126" class="indexterm-anchor"></a><a id="d45327e131" class="indexterm-anchor"></a><a id="d45327e133" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB452"></a><div class="props_rev_3"><a id="GUID-4946BC15-629C-49F2-B76B-808B7312B23D" name="GUID-4946BC15-629C-49F2-B76B-808B7312B23D"></a><h3 id="LNPCB-GUID-4946BC15-629C-49F2-B76B-808B7312B23D" class="sect3"><span class="enumeration_section">7.2</span>主机表的优点</h3>
               <div>
                  <p>主机表可以简化编程，并可以提供极大改进的性能。编写应用程序时，通常会遇到存储和操作大量数据的问题。主机表简化了访问多个返回值的任务。<a id="d45327e159" class="indexterm-anchor"></a></p>
                  <p>主机表允许您使用单个SQL语句操作多个行。因此，通信开销显着降低，尤其是在网络环境中。例如，假设您要将有关300名员工的信息插入EMP表。如果没有主机表，您的程序必须执行300个单独的INSERT  - 每个员工一个。使用主机表时，只需要执行一次INSERT。</p>
               </div>
            </div><a id="LNPCB453"></a><div class="props_rev_3"><a id="GUID-153F146D-2CB9-4050-B12B-259BD75240FE" name="GUID-153F146D-2CB9-4050-B12B-259BD75240FE"></a><h3 id="LNPCB-GUID-153F146D-2CB9-4050-B12B-259BD75240FE" class="sect3"><span class="enumeration_section">7.3</span>数据操作语句中的表</h3>
               <div>
                  <p>Pro * COBOL允许在数据操作语句中使用主机表。您可以在INSERT，UPDATE和DELETE语句中将主机表用作输入变量，并在SELECT和FETCH语句的INTO子句中将输出变量用作输出变量。</p>
                  <p>用于主机表和简单主机变量的语法几乎相同。一个区别是可选的FOR子句，它允许您控制表处理。此外，在SQL语句中混合主机表和简单主机变量存在限制。</p>
               </div><a id="LNPCB454"></a><div class="props_rev_3"><a id="GUID-BB596F1E-F23E-455B-8114-B8B4D046AA7D" name="GUID-BB596F1E-F23E-455B-8114-B8B4D046AA7D"></a><h4 id="LNPCB-GUID-BB596F1E-F23E-455B-8114-B8B4D046AA7D" class="sect4"><span class="enumeration_section">7.3.1</span>声明主机表</h4>
                  <div>
                     <div class="section">
                        <p>您在数据部门中声明和标注主机表。在以下示例中，声明了三个主机表，每个表都标有50个元素：<a id="d45327e217" class="indexterm-anchor"></a><a id="d45327e221" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     .... 
 01  EMP-TABLES. 
     05  EMP-NUMBER  OCCURS 50 TIMES PIC S9(4) COMP. 
     05  EMP-NAME    OCCURS 50 TIMES PIC X(10. 
     05  SALARY      OCCURS 50 TIMES PIC S9(5)V99 COMP-3. 
     .... </pre><p>您可以使用OCCURS子句中的INDEXED BY短语指定索引，如下一个示例所示：</p><pre class="oac_no_warn" dir="ltr">     ... 
 01  EMP-TABLES. 
     05  EMP-NUMBER  PIC X(10) OCCURS 50 TIMES 
         INDEXED BY EMP-INDX. 
             ... 
     ... </pre><p>INDEXED BY短语隐式声明索引项EMP-INDX。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB455"></a><div class="props_rev_3"><a id="GUID-ED2BF09F-0C7F-4BC7-93DD-FD513800C735" name="GUID-ED2BF09F-0C7F-4BC7-93DD-FD513800C735"></a><h5 id="LNPCB-GUID-ED2BF09F-0C7F-4BC7-93DD-FD513800C735" class="sect5"><span class="enumeration_section">7.3.1.1</span>限制</h5>
                     <div>
                        <p>不允许使用多维主机表。因此，以下示例中声明的二维主机表<span class="italic">无效</span> ：<a id="d45327e260" class="indexterm-anchor"></a><a id="d45327e264" class="indexterm-anchor"></a><a id="d45327e266" class="indexterm-anchor"></a><a id="d45327e270" class="indexterm-anchor"></a><a id="d45327e274" class="indexterm-anchor"></a><a id="d45327e278" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     ... 
 01  NATION.
     05  STATE                OCCURS 50 TIMES. 
         10  STATE-NAME       PIC X(25).
         10  COUNTY           OCCURS 25 TIMES.
             15  COUNTY-NAME  PIX X(25).
     ... 
</pre><p>也不允许使用可变长度的主机表。例如，以下EMP-REC声明<span class="italic">对于主机变量无效</span> ： <a id="d45327e289" class="indexterm-anchor"></a><a id="d45327e291" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">     ... 
 01  EMP-FILE. 
     05  REC-COUNT  PIC S9(3) COMP. 
     05  EMP-REC    OCCURS 0 TO 250 TIMES 
         DEPENDING ON REC-COUNT. 
     ... 
</pre><p><a id="d45327e299" class="indexterm-anchor"></a><a id="d45327e303" class="indexterm-anchor"></a>一次获取中可访问的SQL语句中的主机表元素的最大数量为32K（或者可能更大，具体取决于您的平台和可用内存）。如果您尝试访问超过最大值的数字，则会出现“参数超出范围”运行时错误。如果语句是匿名PL / SQL块，则可访问元素的数量限制为32512除以数据类型的大小。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCB456"></a><div class="props_rev_3"><a id="GUID-FEC4C293-671B-4620-AFE3-180AF5716A50" name="GUID-FEC4C293-671B-4620-AFE3-180AF5716A50"></a><h4 id="LNPCB-GUID-FEC4C293-671B-4620-AFE3-180AF5716A50" class="sect4"><span class="enumeration_section">7.3.2</span>引用主机表</h4>
                  <div>
                     <div class="section">
                        <p>如果在单个SQL语句中使用多个主机表，则它们的维度应相同。但是，这不是必需的，因为Pro * COBOL始终使用SQL操作的<span class="italic">最小</span>维度。在以下示例中，只有25行<a id="d45327e336" class="indexterm-anchor"></a><a id="d45327e340" class="indexterm-anchor"></a>插入<a id="d45327e345" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> WORKING-STORAGE SECTION. 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-TABLES. 
     05  EMP-NUMBER   PIC S9(4) COMP OCCURS 50 TIMES. 
     05  EMP-NAME     PIC X(10) OCCURS 50 TIMES. 
     05  DEPT-NUMBER  PIC S9(4) COMP OCCURS 25 TIMES. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
*    Populate host tables here. 
     ... 
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
         VALUES (:EMP-NUMBER, :EMP-NAME, :DEPT-NUMBER) 
     END-EXEC. </pre><p>主机表<span class="italic">不能</span>在SQL语句中下标。例如，以下INSERT语句<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr"> WORKING-STORAGE SECTION. 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-TABLES. 
     05  EMP-NUMBER   PIC S9(4) COMP OCCURS 50 TIMES. 
     05  EMP-NAME     PIC X(10) OCCURS 50 TIMES. 
     05  DEPT-NUMBER  PIC S9(4) COMP OCCURS 50 TIMES. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
     PERFORM LOAD-EMP VARYING J FROM 1 BY 1 UNTIL J &gt; 50. 
     ... 
 LOAD-EMP. 
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
         VALUES (:EMP-NUMBER(J), :EMP-NAME(J), 
             :DEPT-NUMBER(J)) 
     END-EXEC. 
</pre><p>您无需在PERFORM VARYING语句中处理主机表。而是在SQL语句中使用未预订的表名。Pro * COBOL将包含维度为<span class="italic">n的</span>主表的SQL语句视为使用<span class="italic">n个</span>不同标量主变量执行<span class="italic">n</span>次的相同语句，但效率更高。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB457"></a><div class="props_rev_3"><a id="GUID-A16E169C-0B12-464E-957D-3DBA9113CAEA" name="GUID-A16E169C-0B12-464E-957D-3DBA9113CAEA"></a><h4 id="LNPCB-GUID-A16E169C-0B12-464E-957D-3DBA9113CAEA" class="sect4"><span class="enumeration_section">7.3.3</span>使用指标表</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用指示符表将NULL分配给输入主机表中的元素，并检测输出主机表中的NULL或截断值（仅限字符列）。以下示例显示如何使用指示符表执行INSERT： <a id="d45327e398" class="indexterm-anchor"></a><a id="d45327e402" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr"> WORKING-STORAGE SECTION. 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-TABLES. 
     05  EMP-NUMBER   PIC S9(4) COMP OCCURS 50 TIMES. 
     05  DEPT-NUMBER  PIC S9(4) COMP OCCURS 50 TIMES. 
     05  COMMISSION   PIC S9(5)V99 COMP-3 OCCURS 50 TIMES. 
     05  COMM-IND     PIC S9(4) COMP OCCURS 50 TIMES. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
*    Populate the host and indicator tables. 
*    Set indicator table to all zeros.
     ... 
     EXEC SQL INSERT INTO EMP (EMPNO, DEPTNO, COMM) 
         VALUES (:EMP-NUMBER, :DEPT-NUMBER, 
             :COMMISSION:COMM-IND) 
     END-EXEC. 
</pre><p>指标表的维度必须大于或等于主表的维度。</p>
                        <p>使用主机表SELECT和FETCH时，建议您使用指示符变量。这样，您可以在关联的输出主机表中测试NULL。</p>
                        <p>如果选择NULL或将其提取到没有关联指示符变量的主变量中，则程序将停止处理，将<span class="italic">sqlca.sqlerrd（3）设置</span>为已处理的行数，并返回错误。
                        </p>
                        <p>默认情况下会选择NULL，但您可以使用UNSAFE_NULL = YES选项将其关闭。</p>
                        <p>当DBMS = V7或V8时，程序不会将截断视为错误。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB458"></a><div class="props_rev_3"><a id="GUID-2411D823-706F-4F86-B0AB-DEA6B816E305" name="GUID-2411D823-706F-4F86-B0AB-DEA6B816E305"></a><h4 id="LNPCB-GUID-2411D823-706F-4F86-B0AB-DEA6B816E305" class="sect4"><span class="enumeration_section">7.3.4</span>包含表的主机组项</h4>
                  <div>
                     <div class="section">
                        <p><span class="bold">注意：</span>如果您有包含表的主机组项，则必须使用表的相应组项作为指示符。例如，如果您的组项目如下：</p><pre class="oac_no_warn" dir="ltr"> 01  DEPARTURE.
     05 HOUR    PIC X(2) OCCURS 3 TIMES.
     05 MINUTE  PIC X(2) OCCURS 3 TIMES.
</pre><p>以下指标变量<span class="italic">不能</span>使用：</p><pre class="oac_no_warn" dir="ltr"> 01  DEPARTURE-IND PIC S9(4) COMP OCCURS 6 TIMES.
</pre><p>与表组项一起使用的指示符变量本身必须是表的组项，如下所示：</p><pre class="oac_no_warn" dir="ltr">  01  DEPARTURE-IND.
      05 HOUR-IND   PIC S9(4) COMP OCCURS 3 TIMES.
      05 MINUTE-IND PIC S9(4) COMP OCCURS 3 TIMES.</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB459"></a><div class="props_rev_3"><a id="GUID-ABAC969A-FD7D-464E-8E7D-CE7E8C9C094A" name="GUID-ABAC969A-FD7D-464E-8E7D-CE7E8C9C094A"></a><h4 id="LNPCB-GUID-ABAC969A-FD7D-464E-8E7D-CE7E8C9C094A" class="sect4"><span class="enumeration_section">7.3.5</span> Oracle限制</h4>
                  <div>
                     <div class="section">
                        <p>混合主机表标主机变量中的值，SET，进入或WHERE子句是<span class="italic">不允许</span>的。如果任何主机变量是主机表，则所有主机变量都必须是主机表。 <a id="d45327e490" class="indexterm-anchor"></a><a id="d45327e494" class="indexterm-anchor"></a> 
                        </p>
                        <p>你不能使用主机表<a id="d45327e501" class="indexterm-anchor"></a><a id="d45327e503" class="indexterm-anchor"></a> UPDATE或DELETE语句中的CURRENT OF子句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB460"></a><div class="props_rev_3"><a id="GUID-8B13D572-8E98-43B6-93CE-C12FD6E63568" name="GUID-8B13D572-8E98-43B6-93CE-C12FD6E63568"></a><h4 id="LNPCB-GUID-8B13D572-8E98-43B6-93CE-C12FD6E63568" class="sect4"><span class="enumeration_section">7.3.6</span> ANSI限制和要求</h4>
                  <div>
                     <p>阵列接口是ANSI / ISO嵌入式SQL标准的Oracle扩展。但是，当您使用MODE = ANSI进行预编译时，仍然允许使用数组SELECT和FETCH。如果需要，可以使用FIPS flagger预编译器选项标记数组的使用。<a id="d45327e533" class="indexterm-anchor"></a></p>
                  </div>
               </div>
            </div><a id="LNPCB461"></a><div class="props_rev_3"><a id="GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2" name="GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2"></a><h3 id="LNPCB-GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2" class="sect3"><span class="enumeration_section">7.4</span>选择表格</h3>
               <div>
                  <div class="section">
                     <p>您可以在SELECT语句中将主机表用作输出变量。如果知道select将返回的最大行数，只需使用该数量的元素定义主机表。在以下示例中，您可以直接选择三个主机表。该表定义为50行，知道select将返回不超过50行。<a id="d45327e562" class="indexterm-anchor"></a><a id="d45327e566" class="indexterm-anchor"></a><a id="d45327e570" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     01  EMP-REC-TABLES.
         05  EMP-NUMBER   OCCURS 50 TIMES PIC S9(4) COMP.
         05  EMP-NAME     OCCURS 50 TIMES PIC X(10) VARYING.
         05  SALARY       OCCURS 50 TIMES PIC S9(6)V99
                          DISPLAY SIGN LEADING SEPARATE.
     ...
     EXEC SQL SELECT ENAME, EMPNO, SAL
         INTO :EMP-NAME, :EMP-NUMBER, :SALARY
         FROM EMP
         WHERE SAL &gt; 1000
     END-EXEC.
</pre><p>在此示例中，SELECT语句最多返回50行。如果符合条件的行少于50个，或者您只想检索50行，则此方法就足够了。但是，如果有超过50个符合条件的行，则无法以这种方式检索所有行。如果重新执行SELECT语句，它只会再次返回前50行，即使更多符合条件。您必须定义更大的表或声明游标以与FETCH语句一起使用。</p>
                     <p>如果SELECT INTO语句返回的行数多于您定义的表的大小，则Oracle会发出错误消息，除非您指定SELECT_ERROR = NO。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-FF4FD0A6-A076-40AC-A1F2-9758122A34C2">SELECT_ERROR</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB462"></a><div class="props_rev_3"><a id="GUID-37DAFCCC-30FE-4609-92AB-35C45AD25D21" name="GUID-37DAFCCC-30FE-4609-92AB-35C45AD25D21"></a><h4 id="LNPCB-GUID-37DAFCCC-30FE-4609-92AB-35C45AD25D21" class="sect4"><span class="enumeration_section">7.4.1</span>批量提取</h4>
                  <div>
                     <p>当您正在处理的数据大小（大于约100行）以及您不知道将返回多少行时，请使用批量提取。</p>
                     <p>如果您不知道select将返回的最大行数，您可以声明并打开游标，然后在“批处理”中从中获取它。循环内的批量提取可让您轻松检索大量行。每次提取都会返回当前活动集中的下一批行。在以下示例中，您将获取20行批处理：<a id="d45327e611" class="indexterm-anchor"></a><a id="d45327e613" class="indexterm-anchor"></a><a id="d45327e615" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> ...
 01  EMP-REC-TABLES.
     05  EMP-NUMBER    OCCURS 20 TIMES PIC S9(4) COMP.
     05  EMP-NAME      OCCURS 20 TIMES PIC X(10) VARYING.
     05  SALARY        OCCURS 20 TIMES PIC S9(6)V99
                       DISPLAY SIGN LEADING SEPARATE.
     ...
     EXEC SQL DECLARE EMPCURSOR CURSOR FOR
     SELECT EMPNO, SAL FROM EMP
     END-EXEC.
     ...
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     ...
     EXEC SQL WHENEVER NOT FOUND DO PERFORM END-IT.
 LOOP.
     EXEC SQL FETCH EMPCURSOR INTO :EMP-NUMBER, :SALARY END-EXEC.
* --  process batch of rows
     ...
     GO TO LOOP.
 END-IT.
...
</pre><p>不要忘记检查上次获取中实际返回的行数并处理它们。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-tables.html#GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4">示例程序3：批量获取</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB463"></a><div class="props_rev_3"><a id="GUID-D253F033-4C06-4299-869A-D46BF15B597F" name="GUID-D253F033-4C06-4299-869A-D46BF15B597F"></a><h4 id="LNPCB-GUID-D253F033-4C06-4299-869A-D46BF15B597F" class="sect4"><span class="enumeration_section">7.4.2</span>使用SQLERRD（3）</h4>
                  <div>
                     <p>对于INSERT，UPDATE和DELETE语句，SQLERRD（3）记录处理的行数。</p>
                     <p>在表操作期间发生错误时，SQLERRD（3）也很有用。处理在导致错误的行停止，因此SQLERRD（3）给出成功处理的行数。</p>
                  </div>
               </div><a id="LNPCB464"></a><div class="props_rev_3"><a id="GUID-70333183-03EB-4AD0-9DE2-6E701AE365E2" name="GUID-70333183-03EB-4AD0-9DE2-6E701AE365E2"></a><h4 id="LNPCB-GUID-70333183-03EB-4AD0-9DE2-6E701AE365E2" class="sect4"><span class="enumeration_section">7.4.3</span>提取的行数</h4>
                  <div>
                     <p>每次提取最多返回表中的条目数。在以下情况下返回的行数较少：<a id="d45327e679" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>达到活动集的结尾。“未找到数据”警告代码返回到SQLCA中的SQLCODE。例如，如果您获取条目数为100的表，则会发生这种情况，但只返回20行。</p>
                        </li>
                        <li>
                           <p>仍然需要获取完整批次的行。例如，如果您将70行输入到条目数为20的表中，则会发生这种情况，因为在第三次提取之后，仍然只有10行需要提取。</p>
                        </li>
                        <li>
                           <p>处理行时检测到错误。提取失败，适用的错误代码返回给SQLCODE。</p>
                        </li>
                     </ul>
                     <p>返回的累计行数可以在SQLCA的SQLERRD的第三个元素中找到，在本指南中称为SQLERRD（3）。这适用于每个打开的游标。在以下示例中，请注意如何单独维护每个游标的状态：<a id="d45327e695" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL OPEN CURSOR1 END-EXEC.
     EXEC SQL OPEN CURSOR2 END-EXEC.
     EXEC SQL FETCH CURSOR1 INTO :TABLE-OF-20 END-EXEC.
* --  now running total in SQLERRD(3) is 20
     EXEC SQL FETCH CURSOR2 INTO :TABLE-OF-30 END-EXEC.
* --  now running total in SQLERRD(3) is 30, not 50
     EXEC SQL FETCH CURSOR1 INTO :TABLE-OF-20 END-EXEC.
* --  now running total in SQLERRD(3) is 40 (20 + 20)
     EXEC SQL FETCH CURSOR2 INTO :TABLE-OF-30 END-EXEC.
* --  now running total in SQLERRD(3) is 60 (30 + 30)</pre></div>
               </div><a id="LNPCB466"></a><a id="LNPCB465"></a><div class="props_rev_3"><a id="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441" name="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441"></a><h4 id="LNPCB-GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441" class="sect4"><span class="enumeration_section">7.4.4</span>使用主机表的限制</h4>
                  <div>
                     <p>仅在子查询中允许在SELECT语句的WHERE子句中使用主机表。此外，由于Pro * COBOL始终采用表的最小维度，因此不要在SELECT或FETCH语句的INTO子句中将简单主机变量与主机表混合，因为只检索一行。如果任何主机变量是表，那么所有主变量都必须是表。<a id="d45327e726" class="indexterm-anchor"></a><a id="d45327e730" class="indexterm-anchor"></a></p>
                     <p><a href="host-tables.html#GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__I6325">主机表在SELECT INTO</a>中<a href="host-tables.html#GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__I6325">有效</a>显示主机表的哪些使用在SELECT INTO语句中有效。
                     </p>
                     <div class="tblformal" id="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__GUID-664F57EE-D356-4CBC-A402-64BEC09BA0C3">
                        <p class="titleintable">表7-1 <span class="italic" id="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__I6325"><span class="bold">主机表在SELECT INTO中有效</span></span></p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="主机表在SELECT INTO中有效" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d45327e751">INTO条款</th>
                                 <th align="left" valign="bottom" width="42%" id="d45327e754">条款</th>
                                 <th align="left" valign="bottom" width="24%" id="d45327e757">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e762" headers="d45327e751 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e762 d45327e754 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e762 d45327e757 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e772" headers="d45327e751 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e772 d45327e754 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e772 d45327e757 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e782" headers="d45327e751 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e782 d45327e754 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e782 d45327e757 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e792" headers="d45327e751 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e792 d45327e754 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e792 d45327e757 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-tables.html#GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0">WHERE子句</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB467"></a><div class="props_rev_3"><a id="GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71" name="GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71"></a><h4 id="LNPCB-GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71" class="sect4"><span class="enumeration_section">7.4.5</span>获取NULL</h4>
                  <div>
                     <p>当UNSAFE_NULL = YES时，如果在缺少指示符表的主机表中选择或获取NULL，则不会生成错误。因此，在进行表选择和提取时，Oracle建议您使用指标表。这是因为这使得在关联的输出主机表中更容易找到NULL。</p>
                     <p>当UNSAFE_NULL = NO时，如果在缺少指标表的主机表中选择或获取NULL，则Oracle停止处理，将SQLERRD（3）设置为处理的行数，并发出错误消息：</p>
                     <div class="infoboxnotealso" id="GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71__GUID-E70221B5-31DC-49BB-AFD1-F53E6B62EAAD">
                        <p class="notep1">也可以看看：</p><a href="embedded-SQL.html#GUID-CB6FDC6E-6FED-478D-8A47-B9CDE504C102">使用指示符变量</a>来学习如何查找NULL和截断值。
                     </div>
                  </div>
               </div><a id="LNPCB468"></a><div class="props_rev_3"><a id="GUID-CAB9A065-0D56-4AA9-976D-DABA90E50E5C" name="GUID-CAB9A065-0D56-4AA9-976D-DABA90E50E5C"></a><h4 id="LNPCB-GUID-CAB9A065-0D56-4AA9-976D-DABA90E50E5C" class="sect4"><span class="enumeration_section">7.4.6</span>获取截断值</h4>
                  <div>
                     <p>如果在缺少指示符表的主机表中选择或获取截断的列值，Oracle会设置SQLWARN（2）。</p>
                     <p>您可以在截断发生之前检查SQLERRD（3）以查找处理的行数。行处理的计数包括导致截断错误的行。</p>
                     <p>在执行表选择和提取时，您可以使用指标表。这样，如果Oracle将一个或多个截断的列值分配给输出主机表，则可以在关联的指标表中找到列值的原始长度。</p>
                  </div>
               </div><a id="LNPCB469"></a><div class="props_rev_3"><a id="GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4" name="GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4"></a><h4 id="LNPCB-GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4" class="sect4"><span class="enumeration_section">7.4.7</span>示例程序3：批量获取</h4>
                  <div>
                     <div class="section">
                        <p>可以在演示目录中找到以下主机表示例程序。</p><pre class="oac_no_warn" dir="ltr">      *****************************************************************
      * Sample Program 3:  Host Tables                                *
      *                                                               *
      * This program logs on to ORACLE, declares and opens a cursor,  *
      * fetches in batches using host tables, and prints the results. *
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID. HOST-TABLES.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(15) VARYING.
       01  PASSWD            PIC X(15) VARYING.
       01  EMP-REC-TABLES.
           05  EMP-NUMBER    OCCURS 5 TIMES PIC S9(4) COMP.
           05  EMP-NAME      OCCURS 5 TIMES PIC X(10) VARYING.
           05  SALARY        OCCURS 5 TIMES PIC S9(6)V99
                             DISPLAY SIGN LEADING SEPARATE.
           EXEC SQL VAR SALARY IS DISPLAY(8,2) END-EXEC.
           EXEC SQL END DECLARE SECTION END-EXEC.
           EXEC SQL INCLUDE SQLCA END-EXEC.
       01  NUM-RET           PIC S9(9) COMP VALUE ZERO.
       01  PRINT-NUM         PIC S9(9) COMP VALUE ZERO.
       01  COUNTER           PIC S9(9) COMP.
       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-EMP-NUMBER  PIC 9(4).
           05  D-SALARY      PIC Z(4)9.99.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL 
               WHENEVER SQLERROR DO PERFORM SQL-ERROR
           END-EXEC.
           PERFORM LOGON.
           EXEC SQL 
               DECLARE C1 CURSOR FOR
               SELECT EMPNO, SAL, ENAME 
               FROM EMP
           END-EXEC.
           EXEC SQL
               OPEN C1
           END-EXEC.

       FETCH-LOOP.
           EXEC SQL 
               WHENEVER NOT FOUND DO PERFORM SIGN-OFF
           END-EXEC.
           EXEC SQL 
               FETCH C1 
               INTO :EMP-NUMBER, :SALARY, :EMP-NAME
           END-EXEC.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           PERFORM PRINT-IT.
           MOVE SQLERRD(3) TO NUM-RET.
           GO TO FETCH-LOOP.

       LOGON.
           MOVE "SCOTT" TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE "TIGER" TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
              CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY " ".
           DISPLAY "CONNECTED TO ORACLE AS USER:  ", USERNAME-ARR.

       PRINT-IT.
           DISPLAY " ".
           DISPLAY "EMPLOYEE NUMBER  SALARY   EMPLOYEE NAME".
           DISPLAY "---------------  -------  -------------".
           PERFORM PRINT-ROWS
               VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; PRINT-NUM.

       PRINT-ROWS.      
           MOVE EMP-NUMBER(COUNTER) TO D-EMP-NUMBER.
           MOVE SALARY(COUNTER) TO D-SALARY.
           DISPLAY "           ", D-EMP-NUMBER, " ", D-SALARY, "  ",
               EMP-NAME-ARR IN EMP-NAME(COUNTER).
           MOVE SPACES TO EMP-NAME-ARR IN EMP-NAME(COUNTER).

       SIGN-OFF.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           IF (PRINT-NUM &gt; 0) PERFORM PRINT-IT.
           EXEC SQL 
               CLOSE C1 
           END-EXEC. 
           EXEC SQL 
               COMMIT WORK RELEASE 
           END-EXEC.
           DISPLAY " ".
           DISPLAY "HAVE A GOOD DAY.".
           DISPLAY " ".
           STOP RUN.

       SQL-ERROR.
           EXEC SQL 
               WHENEVER SQLERROR CONTINUE 
           END-EXEC.
           DISPLAY " ".
           DISPLAY "ORACLE ERROR DETECTED:".
           DISPLAY " ".
           DISPLAY SQLERRMC.
           EXEC SQL 
               ROLLBACK WORK RELEASE 
           END-EXEC.
           STOP RUN.</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB470"></a><div class="props_rev_3"><a id="GUID-3340D08A-431A-45C9-9003-13636C7278C6" name="GUID-3340D08A-431A-45C9-9003-13636C7278C6"></a><h3 id="LNPCB-GUID-3340D08A-431A-45C9-9003-13636C7278C6" class="sect3"><span class="enumeration_section">7.5</span>插入表格</h3>
               <div>
                  <p>您可以在INSERT语句中将主机表用作输入变量。在执行INSERT语句之前，只需确保您的程序使用数据填充表。如果表中的某些元素不相关，则可以使用FOR子句来控制插入的行数。<a id="d45327e929" class="indexterm-anchor"></a><a id="d45327e933" class="indexterm-anchor"></a><a id="d45327e937" class="indexterm-anchor"></a></p>
                  <p>使用主机表插入的示例如下：</p><pre class="oac_no_warn" dir="ltr"> 01  EMP-REC-TABLES.
     05  EMP-NUMBER    OCCURS 50 TIMES PIC S9(4) COMP.
     05  EMP-NAME      OCCURS 50 TIMES PIC X(10) VARYING.
     05  SALARY        OCCURS 50 TIMES PIC S9(6)V99
                       DISPLAY SIGN LEADING SEPARATE.
* -- populate the host tables
     EXEC SQL INSERT INTO EMP (ENAME, EMPNO, SAL)
         VALUES (:EMP-NAME, :EMP-NUMBER, :SALARY)
     END-EXEC.
</pre><p>插入的行数将在SQLERRD（3）中提供。</p>
                  <p>主机表<span class="italic">不能</span>在SQL语句中下标。例如，以下INSERT语句无效：</p><pre class="oac_no_warn" dir="ltr">     PERFORM VARYING I FROM 1 BY 1 UNTIL I = TABLE-DIMENSION.
        EXEC SQL INSERT INTO EMP (ENAME, EMPNO, SAL)
            VALUES (:EMP-NAME(I), :EMP-NUMBER(I), :SALARY(I))
        END_EXEC
     END-PERFORM.</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="host-tables.html#GUID-81265F69-2532-4014-A048-BF0739CC8486">FOR条款</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB471"></a><div class="props_rev_3"><a id="GUID-3A7041C7-D8FC-46A2-96F9-5ADEC2AF16AF" name="GUID-3A7041C7-D8FC-46A2-96F9-5ADEC2AF16AF"></a><h4 id="LNPCB-GUID-3A7041C7-D8FC-46A2-96F9-5ADEC2AF16AF" class="sect4"><span class="enumeration_section">7.5.1</span>主机表限制</h4>
                  <div>
                     <div class="section">
                        <p>将简单主机变量与INSERT，UPDATE或DELETE语句的VALUES子句中的主机表混合会导致只处理任何主机表的第一个元素，因为简单主机变量被视为维度为1的主表，而Pro * COBOL始终使用最小的声明尺寸。发生这种情况时会收到警告。<a id="d45327e984" class="indexterm-anchor"></a><a id="d45327e988" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB472"></a><div class="props_rev_3"><a id="GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2" name="GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2"></a><h3 id="LNPCB-GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2" class="sect3"><span class="enumeration_section">7.6</span>使用表格更新</h3>
               <div>
                  <p>您还可以在UPDATE语句中将主机表用作输入变量，如以下示例所示：<a id="d45327e1017" class="indexterm-anchor"></a><a id="d45327e1021" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> 01  EMP-REC-TABLES.
     05  EMP-NUMBER    OCCURS 50 TIMES PIC S9(4) COMP.
     05  SALARY        OCCURS 50 TIMES PIC S9(6)V99 
                           DISPLAY SIGN LEADING SEPARATE.
 ...
* --  populate the host tables
     EXEC SQL
         UPDATE EMP SET SAL = :SALARY WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
</pre><p>SQLERRD（3）中提供了通过发出此语句更新的行数。这不一定是主机表中的行数。数<span class="italic">不</span>包括由更新级联处理的行（这将导致随后的更新）。
                  </p>
                  <p>如果表中的某些元素不相关，则可以使用FOR子句限制更新的行数。</p>
                  <p>最后一个示例显示了使用唯一密钥（ <span class="italic">EMP-NUMBER</span> ）的典型更新。每个表元素只限一行进行更新。在以下示例中，每个表元素限定多行：</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ...
            05  JOB-TITLE      OCCURS 10 TIMES PIC X(10) VARYING.
            05  COMMISSION     OCCURS 50 TIMES PIC S9(6)V99
                              DISPLAY SIGN LEADING SEPARATE.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host tables
     EXEC SQL
         UPDATE EMP SET COMM = :COMMISSION WHERE JOB = :JOB-TITLE
     END-EXEC.</pre></div><a id="LNPCB474"></a><a id="LNPCB473"></a><div class="props_rev_3"><a id="GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A" name="GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A"></a><h4 id="LNPCB-GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A" class="sect4"><span class="enumeration_section">7.6.1</span> UPDATE中的限制</h4>
                  <div>
                     <div class="section">
                        <p>您不能在UPDATE语句中使用具有CURRENT OF子句的主机表。有关替代方案，请参阅<span class="q">“ <a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前条款</a> ”</span> 。
                        </p>
                        <p><a href="host-tables.html#GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A__g12833" title="q">表7-2</a>显示了主表的哪些用法在UPDATE语句中有效：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A__g12833">
                        <p class="titleintable">表7-2主机表在UPDATE中有效</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="主机表在UPDATE中有效" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d45327e1089">SET子句</th>
                                 <th align="left" valign="bottom" width="43%" id="d45327e1092">条款</th>
                                 <th align="left" valign="bottom" width="23%" id="d45327e1095">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1100" headers="d45327e1089 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1100 d45327e1092 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1100 d45327e1095 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1110" headers="d45327e1089 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1110 d45327e1092 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1110 d45327e1095 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1120" headers="d45327e1089 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1120 d45327e1092 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1120 d45327e1095 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1130" headers="d45327e1089 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1130 d45327e1092 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1130 d45327e1095 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="LNPCB475"></a><div class="props_rev_3"><a id="GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D" name="GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D"></a><h3 id="LNPCB-GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D" class="sect3"><span class="enumeration_section">7.7</span>删除表格</h3>
               <div>
                  <p>您还可以在DELETE语句中将主机表用作输入变量。这样做就像使用WHERE子句中的主机表的连续元素重复执行DELETE语句。因此，每次执行都可能从表中删除零个，一个或多个行。使用主机表删除的示例如下：<a id="d45327e1163" class="indexterm-anchor"></a><a id="d45327e1167" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ... 
         05  EMP-NUMBER    OCCURS 50 TIMES PIC S9(4) COMP.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host table
     EXEC SQL
         DELETE FROM EMP WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
</pre><p>删除的累计行数可以在SQLERRD（3）中找到。这个数字<span class="italic">不</span>包括被删除级联处理的行。
                  </p>
                  <p>最后一个示例显示了使用唯一键（ <span class="italic">EMP-NUMBER</span> ）的典型删除。每个表元素只限一行进行删除。在以下示例中，每个表元素限定多行：</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ...
            05  JOB-TITLE    OCCURS 10 TIMES PIC X(10) VARYING.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host table
     EXEC SQL
        DELETE FROM EMP WHERE JOB = :JOB-TITLE
     END-EXEC.</pre></div><a id="LNPCB476"></a><div class="props_rev_3"><a id="GUID-37B00D0A-329C-4438-8B2A-3C005D22933B" name="GUID-37B00D0A-329C-4438-8B2A-3C005D22933B"></a><h4 id="LNPCB-GUID-37B00D0A-329C-4438-8B2A-3C005D22933B" class="sect4"><span class="enumeration_section">7.7.1</span> DELETE中的限制</h4>
                  <div>
                     <div class="section">
                        <p>您不能在DELETE语句中使用具有CURRENT OF子句的主机表。有关替代方案，请参阅<span class="q">“ <a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前条款</a> ”</span> 。<a id="d45327e1221" class="indexterm-anchor"></a><a id="d45327e1225" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB477"></a><div class="props_rev_3"><a id="GUID-96196A54-F463-4D14-809B-39C58FAEA526" name="GUID-96196A54-F463-4D14-809B-39C58FAEA526"></a><h3 id="LNPCB-GUID-96196A54-F463-4D14-809B-39C58FAEA526" class="sect3"><span class="enumeration_section">7.8</span>使用指标表</h3>
               <div>
                  <p>您可以使用指示符表将NULL分配给输入主机表，并检测输出主机表中的NULL或截断值。以下示例显示如何使用指标表插入：</p><pre class="oac_no_warn" dir="ltr"> 01  EMP-REC-VARS.
     05  EMP-NUMBER  OCCURS 50 TIMES PIC S9(4) COMP.
     05  DEPT-NUMBER OCCURS 50 TIMES PIC S9(4) COMP.
     05  COMMISSION  OCCURS 50 TIMES  PIC S9(6)V99
                            DISPLAY SIGN LEADING SEPARATE.
* -- indicator table:
     05  COMM-IND    OCCURS 50 TIMES  PIC S9(4) COMP.
* --  populate the host tables
* --  populate the indicator table; to insert a NULL into 
* --  the COMM column, assign -1 to the appropriate element in
* --  the indicator table
     EXEC SQL
         INSERT INTO EMP (EMPNO, DEPTNO, COMM)
         VALUES (:EMP_NUMBER, :DEPT-NUMBER, :COMMISSION:COMM-IND)
     END-EXEC.
</pre><p>指标表的条目数不能小于主表的条目数。</p>
               </div>
            </div><a id="LNPCB478"></a><div class="props_rev_3"><a id="GUID-81265F69-2532-4014-A048-BF0739CC8486" name="GUID-81265F69-2532-4014-A048-BF0739CC8486"></a><h3 id="LNPCB-GUID-81265F69-2532-4014-A048-BF0739CC8486" class="sect3"><span class="enumeration_section">7.9</span> FOR条款</h3>
               <div>
                  <div class="section">
                     <p>您可以使用可选的FOR子句来设置由以下任何SQL语句处理的表元素的数量：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>删除</p>
                        </li>
                        <li>
                           <p>EXECUTE（请参阅Oracle Dynamic SQL中有关<a href="Oracle-dynamic-SQL-method-4.html#GUID-C6256169-5928-466C-B7C7-960D20705EED">Oracle动态SQL的信息：方法4</a> 。
                           </p>
                        </li>
                        <li>
                           <p>取</p>
                        </li>
                        <li>
                           <p>插入</p>
                        </li>
                        <li>
                           <p>打开</p>
                        </li>
                        <li>
                           <p>UPDATE</p>
                        </li>
                     </ul>
                     <p>FOR子句在UPDATE，INSERT和DELETE语句中特别有用。使用这些语句，您可能不想使用整个表。FOR子句允许您将所使用的元素限制为所需的数字，如以下示例所示：<a id="d45327e1308" class="indexterm-anchor"></a><a id="d45327e1312" class="indexterm-anchor"></a><a id="d45327e1316" class="indexterm-anchor"></a><a id="d45327e1318" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  EMP-REC-VARS.
     05  EMP-NAME  OCCURS 1000 TIMES  PIC X(20) VARYING.
     05  SALARY    OCCURS 100  TIMES  PIC S9(6)V99
                   DISPLAY SIGN LEADING SEPARATE.
 01 ROWS-TO-INSERT PIC S9(4) COMP.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host tables
     MOVE 25 TO ROWS-TO-INSERT.
* -- set FOR-clause variable
* -- will process only 25 rows
     EXEC SQL FOR :ROWS-TO-INSERT  
         INSERT INTO EMP (ENAME, SAL)
         VALUES (:EMP-NAME, :SALARY)
     END-EXEC.
</pre><p>FOR子句必须使用整数主机变量来计算表元素。例如，以下声明是非法的：</p><pre class="oac_no_warn" dir="ltr">* -- illegal
     EXEC SQL FOR 25           
     INSERT INTO EMP (ENAME, EMPNO, SAL)
         VALUES (:EMP-NAME, :EMP-NUMBER, :SALARY)
     END-EXEC.
</pre><p>FOR子句变量指定要处理的表元素的数量。确保该数字不超过最小的表格尺寸。在内部，该值被视为无符号数量。尝试通过使用已签名的主机变量传递负值将导致不可预测的行为。</p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCB479"></a><div class="props_rev_3"><a id="GUID-383AE9B8-FD57-4506-B93A-AA9228070DD7" name="GUID-383AE9B8-FD57-4506-B93A-AA9228070DD7"></a><h4 id="LNPCB-GUID-383AE9B8-FD57-4506-B93A-AA9228070DD7" class="sect4"><span class="enumeration_section">7.9.1</span>限制</h4>
                  <div>
                     <div class="section">
                        <p>两个限制使FOR子句语义清晰：您不能在SELECT语句中使用FOR子句或使用CURRENT OF子句。<a id="d45327e1355" class="indexterm-anchor"></a><a id="d45327e1359" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB480"></a><div class="props_rev_3"><a id="GUID-6A115D6B-DDB2-4734-A616-676F5057D061" name="GUID-6A115D6B-DDB2-4734-A616-676F5057D061"></a><h5 id="LNPCB-GUID-6A115D6B-DDB2-4734-A616-676F5057D061" class="sect5"><span class="enumeration_section">7.9.1.1</span>在SELECT语句中</h5>
                     <div>
                        <p>如果在SELECT语句中使用FOR子句，则会收到错误消息。</p>
                        <p>SELECT语句中不允许使用FOR子句，因为它的含义不清楚。这是否意味着“执行此SELECT语句<span class="italic">n</span>次”？或者，它是否意味着“执行此SELECT语句一次，但返回<span class="italic">n</span>行”？前一种情况的问题是每次执行都可能返回多行。在后一种情况下，最好声明一个游标并在FETCH语句中使用FOR子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL FOR :LIMIT FETCH EMPCURSOR INTO ...</pre></div>
                  </div><a id="LNPCB481"></a><div class="props_rev_3"><a id="GUID-204ED877-76C1-46E8-AE9A-CA0DC7D1F958" name="GUID-204ED877-76C1-46E8-AE9A-CA0DC7D1F958"></a><h5 id="LNPCB-GUID-204ED877-76C1-46E8-AE9A-CA0DC7D1F958" class="sect5"><span class="enumeration_section">7.9.1.2</span>使用CURRENT OF子句</h5>
                     <div>
                        <p>您可以使用UPDATE或DELETE语句中的CURRENT OF子句来引用FETCH语句返回的最新行，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL DECLARE EMPCURSOR CURSOR FOR 
         SELECT ENAME, SAL FROM EMP WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
     ... 
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     ...
     EXEC SQL FETCH emp_cursor INTO :EM-NAME, :SALARY END-EXEC.
     ...
     EXEC SQL UPDATE EMP SET SAL = :NEW-SALARY
         WHERE CURRENT OF EMPCURSOR
     END-EXEC.
</pre><p>但是，您不能将FOR子句与CURRENT OF子句一起使用。以下语句无效，因为<span class="italic">LIMIT</span>的唯一逻辑值为1（您只能更新或删除当前行一次）：</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL FOR :LIMIT UPDA-CURSOR END-EXEC.
     ...
     EXEC SQL FOR :LIMIT DELETE FROM EMP 
         WHERE CURRENT OF emp_cursor
     END-EXEC.</pre></div>
                  </div>
               </div>
            </div><a id="LNPCB482"></a><div class="props_rev_3"><a id="GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0" name="GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0"></a><h3 id="LNPCB-GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0" class="sect3"><span class="enumeration_section">7.10</span> WHERE子句</h3>
               <div>
                  <div class="section">
                     <p>PRO * COBOL对待包含条目具有<span class="italic">n个</span>不同标量变量（各个表元素<span class="italic">）N</span>等执行相同的SQL语句的<span class="italic">n</span>倍的数量的主机表的SQL语句。仅当此类处理不明确时，预编译器才会发出错误消息：<a id="d45327e1464" class="indexterm-anchor"></a><a id="d45327e1468" class="indexterm-anchor"></a></p>
                     <p>例如，假设声明：</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ...
     05  MGRP-NUMBER  OCCURS 50 TIMES  PIC S9(4) COMP.
     05  JOB-TITLE    OCCURS 50 TIMES  PIC X(20) VARYING.
 01  I PIC S9(4) COMP.
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre><p>如果声明如下，那将是模棱两可的：</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL SELECT MGR INTO :MGR-NUMBER FROM EMP
         WHERE JOB = :JOB-TITLE
     END-EXEC.
</pre><p>被视为如下陈述</p><pre class="oac_no_warn" dir="ltr">     PERFORM VARYING I FROM 1 BY 1 UNTIL I = 50
     SELECT MGR INTO :MGR-NUMBER(I) FROM EMP
         WHERE JOB = :JOB_TITLE(I)
     END-EXEC
     END-PERFORM.
</pre><p>因为多行可能符合WHERE子句搜索条件，但只有一个输出变量可用于接收数据。因此，会发出错误消息。</p>
                     <p>另一方面，如果声明如此，则不会含糊不清</p><pre class="oac_no_warn" dir="ltr">      EXEC SQL
         UPDATE EMP SET MGR = :MGR_NUMBER
         WHERE EMPNO IN (SELECT EMPNO FROM EMP WHERE
         JOB = :JOB-TITLE)
     END-EXEC.
</pre><p>被视为如下陈述</p><pre class="oac_no_warn" dir="ltr">     PERFORM VARYING I FROM 1 BY 1 UNTIL I = 50
<span class="bold">         </span>UPDATE EMP SET MGR = :MGR_NUMBER(I)
             WHERE EMPNO IN
             (SELECT EMPNO FROM EMP WHERE JOB = :JOB-TITLE(I))
         END-EXEC
     END-PERFORM.
</pre><p>因为在WHERE子句中匹配<span class="italic">JOB-TITLE的</span>每一行的SET子句中都有一个<span class="italic">MGR-NUMBER</span> ，即使每个<span class="italic">JOB-TITLE</span>匹配多行也是如此。与每个<span class="italic">JOB-TITLE</span>匹配的所有行都可以设置为相同的<span class="italic">MGR-NUMBER</span> ，因此不会发出错误消息。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCB483"></a><div class="props_rev_3"><a id="GUID-48EF2A66-B3E8-4E99-81C2-083482363350" name="GUID-48EF2A66-B3E8-4E99-81C2-083482363350"></a><h3 id="LNPCB-GUID-48EF2A66-B3E8-4E99-81C2-083482363350" class="sect3"><span class="enumeration_section">7.11</span>模仿当前的条款</h3>
               <div>
                  <p>CURRENT OF子句使您可以对游标中的最新行执行UPDATE或DELETE。使用CURRENT OF子句会将FOR UPDATE子句添加到游标中。添加此子句可以锁定光标在独占模式下标识的所有行。请注意，您不能将CURRENT OF与主机表一起使用。而是将FOR UPDATE附加到游标的定义并显式选择ROWID列，然后在更新或删除期间使用该值来标识当前行。一个例子如下：<a id="d45327e1539" class="indexterm-anchor"></a><a id="d45327e1543" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">         05  EMP-NAME    OCCURS 25 TIMES PIC X(20) VARYING.
         05  JOB-TITLE   OCCURS 25 TIMES PIC X(15) VARYING.
         05  OLD-TITLE   OCCURS 25 TIMES PIC X(15) VARYING.
         05  ROW-ID      OCCURS 25 TIMES PIC X(18) VARYING.
     ...
     EXEC SQL DECLARE EMPCURSOR CURSOR FOR
         SELECT ENAME, JOB, ROWID FROM EMP
         FOR UPDATE
     END-EXEC.
     ...
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     ...
     EXEC SQL WHENEVER NOT FOUND GOTO <span class="bold">...</span>
     ...
     PERFORM
        <span class="bold"> </span>EXEC SQL
             FETCH EMPCURSOR
             INTO :EMP-NAME, :JOB-TITLE, :ROW-ID
         END-EXEC
         ...
         EXEC SQL
             DELETE FROM EMP
             WHERE JOB = :OLD-TITLE AND ROWID = :ROW-ID
         END-EXEC
         EXEC SQL COMMIT WORK END-EXEC
      END-PERFORM.</pre></div>
            </div><a id="LNPCB484"></a><div class="props_rev_3"><a id="GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A" name="GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A"></a><h3 id="LNPCB-GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A" class="sect3"><span class="enumeration_section">7.12</span>组项目表作为主机变量</h3>
               <div>
                  <p>Pro * COBOL允许在嵌入式SQL语句中使用组项（也称为<span class="italic">记录</span> ）表。组项的表可以在SELECT或FETCH语句的INTO子句中引用，也可以在INSERT语句的VALUES列表中引用。
                  </p>
                  <p>例如，给出以下声明：</p><pre class="oac_no_warn" dir="ltr"> 01    TABLES.
       05   EMP-TABLE           OCCURS 20 TIMES.
            10    EMP-NUMBER    PIC S9(4) COMP.
            10    EMP-NAME      PIC X(10).
            10    DEPT-NUMBER   PIC S9(4) COMP.
</pre><p>以下声明有效：</p><pre class="oac_no_warn" dir="ltr">       EXEC SQL INSERT INTO EMP(EMPNO, ENAME, DEPTNO)
            VALUES(:EMP-TABLE)
       END-EXEC.
</pre><p>假设组项已经填充了数据，则语句批量插入包含员工编号，员工姓名和部门编号的20行到EMP表中。</p>
                  <p>确保组项的顺序与SQL语句中的顺序相对应。</p>
                  <p>要使用指标变量，请设置组项目的第二个表格，其中包含组项目中每个变量的指示符变量：</p><pre class="oac_no_warn" dir="ltr"> 01     TABLES-IND.
        05   EMP-TABLE-IND  OCCURS 20 TIMES.
             10   EMP-NUMBER-IND       PIC S9(4) COMP.
             10   EMP-NAME-IND         PIC S9(4) COMP.
             10   DEPT-NUMBER_IND      PIC S9(4) COMP.
</pre><p>组项的主机指标表可以如下使用：</p><pre class="oac_no_warn" dir="ltr">        EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO)
            VALUES (:EMP-TABLE:EMP-TABLE-IND)
        END-EXEC.
</pre><p>如果已知数据的确切特征，则可以方便地为组项指定基本项目指示符：</p><pre class="oac_no_warn" dir="ltr">        05    EMP-TABLE-IND     PIC S9(4) COMP
                                OCCURS 20 TIMES.
</pre><p>组项的主机表不能具有作为表的组项。例如：</p><pre class="oac_no_warn" dir="ltr"> 01   TABLES.
      05   EMP-TABLE               OCCURS 20 TIMES.
           10  EMP-NUMBER          PIC S9(4) COMP OCCURS 10 TIMES.
           10  EMP-NAME            PIC X(10).
           10  DEPT-NUMBER         PIC S9(4) COMP.
</pre><p><code class="codeph">EMP-TABLE</code> <span class="italic">不能</span>用作主机变量，因为<code class="codeph">EMP-NUMBER</code>是一个表。
                  </p>
                  <p>不允许嵌套组项的主机表。例如：</p><pre class="oac_no_warn" dir="ltr"> 01   TABLES.
      05   TEAM-TABLE                   OCCURS 20 TIMES
           10   EMP-TABLE
                15   EMP-NUMBER         PIC S9(4) COMP.
                15   EMP-NAME           PIC X(10).
           10   DEPT-TABLE.
                15   DEPT-NUMBER        PIC S9(4) COMP.
                15   DEPT-NAME          PIC X(10).
</pre><p><code class="codeph">TEAM-TABLE</code>不能用作主变量，因为其成员（ <code class="codeph">EMP-TABLE</code>和<code class="codeph">DEPT-TABLE</code> ）本身就是组项。
                  </p>
                  <p>最后，适用于Pro * COBOL中主机表的限制也适用于组项目表：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>不允许使用多维和可变长度的表。</p>
                     </li>
                     <li>
                        <p>如果在单个SQL语句中使用多个表，则它们的维度应该相同。</p>
                     </li>
                     <li>
                        <p>SQL语句中的主机表不得下标。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPCB485"></a><div class="props_rev_3"><a id="GUID-C8565154-1FBC-4CF6-807B-E82CA72450A2" name="GUID-C8565154-1FBC-4CF6-807B-E82CA72450A2"></a><h3 id="LNPCB-GUID-C8565154-1FBC-4CF6-807B-E82CA72450A2" class="sect3"><span class="enumeration_section">7.13</span>示例程序14：组项目表</h3>
               <div>
                  <div class="section">
                     <p>该程序登录，声明并打开游标，使用组项目表批量提取。阅读初始评论了解详情。<a id="d45327e1683" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">      *****************************************************************
      * Sample Program 14:  Tables of group items                     *
      *                                                               *
      * This program logs on to ORACLE, declares and opens a cursor,  *
      * fetches in batches using a table of group items , and prints  *
      * the results.  This sample is identical to sample3 except that *
      * instead of using three separate host tables of five elements  *
      * each, it uses a five-element table of three group items.      *
      * The output should be identical.                               *
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TABLE-OF-GROUP-ITEMS.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(15) VARYING.
       01  PASSWD            PIC X(15) VARYING.
       01  EMP-REC-TABLE OCCURS 5 TIMES.
           05  EMP-NUMBER    PIC S9(4) COMP.
           05  SALARY        PIC S9(6)V99
                             DISPLAY SIGN LEADING SEPARATE.
           05  EMP-NAME      PIC X(10) VARYING.
           EXEC SQL VAR SALARY IS DISPLAY(8,2) END-EXEC.
           EXEC SQL END DECLARE SECTION END-EXEC.
           EXEC SQL INCLUDE SQLCA END-EXEC.
       01  NUM-RET           PIC S9(9) COMP VALUE ZERO.
       01  PRINT-NUM         PIC S9(9) COMP VALUE ZERO.
       01  COUNTER           PIC S9(9) COMP.
       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-EMP-NUMBER  PIC 9(4).
           05  D-SALARY      PIC Z(4)9.99.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL 
               WHENEVER SQLERROR DO PERFORM SQL-ERROR
           END-EXEC.
           PERFORM LOGON.
           EXEC SQL 
               DECLARE C1 CURSOR FOR
               SELECT EMPNO, SAL, ENAME 
               FROM EMP
           END-EXEC.
           EXEC SQL
               OPEN C1
           END-EXEC.

       FETCH-LOOP.
           EXEC SQL 
               WHENEVER NOT FOUND DO PERFORM SIGN-OFF
           END-EXEC.
           EXEC SQL 
               FETCH C1 
               INTO :EMP-REC-TABLE
           END-EXEC.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           PERFORM PRINT-IT.
           MOVE SQLERRD(3) TO NUM-RET.
           GO TO FETCH-LOOP.

       LOGON.
           MOVE "SCOTT" TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE "TIGER" TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
              CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY " ".
           DISPLAY "CONNECTED TO ORACLE AS USER:  ", USERNAME-ARR.

       PRINT-IT.
           DISPLAY " ".
           DISPLAY "EMPLOYEE NUMBER  SALARY   EMPLOYEE NAME".
           DISPLAY "---------------  -------  -------------".
           PERFORM PRINT-ROWS
               VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; PRINT-NUM.

       PRINT-ROWS.      
           MOVE EMP-NUMBER(COUNTER) TO D-EMP-NUMBER.
           MOVE SALARY(COUNTER) TO D-SALARY.
           DISPLAY "           ", D-EMP-NUMBER, " ", D-SALARY, "  ",
               EMP-NAME-ARR IN EMP-NAME(COUNTER).
           MOVE SPACES TO EMP-NAME-ARR IN EMP-NAME(COUNTER).

       SIGN-OFF.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           IF (PRINT-NUM &gt; 0) PERFORM PRINT-IT.
           EXEC SQL 
               CLOSE C1 
           END-EXEC. 
           EXEC SQL 
               COMMIT WORK RELEASE 
           END-EXEC.
           DISPLAY " ".
           DISPLAY "HAVE A GOOD DAY.".
           DISPLAY " ".
           STOP RUN.

       SQL-ERROR.
           EXEC SQL 
               WHENEVER SQLERROR CONTINUE 
           END-EXEC.
           DISPLAY " ".
           DISPLAY "ORACLE ERROR DETECTED:".
           DISPLAY " ".
           DISPLAY SQLERRMC.
           EXEC SQL 
               ROLLBACK WORK RELEASE 
           END-EXEC.
           STOP RUN.
 </pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCB487"></a><a id="LNPCB488"></a><a id="LNPCB489"></a><a id="LNPCB490"></a><a id="LNPCB486"></a><div class="props_rev_3"><a id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026" name="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026"></a><h3 id="LNPCB-GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026" class="sect3"><span class="enumeration_section">7.14</span>附加阵列插入/选择语法</h3>
               <div>
                  <p>Oracle预编译器还支持主机表的DB2插入和获取语法。支持的附加阵列插入和获取语法分别显示在以下图像中。</p>
                  <div class="figure" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-82DD6843-ABF5-4AA4-AF88-37EA45827E55">
                     <p class="titleinfigure">图7-1附加插入语法</p><img src="img/insert2.png" alt="下面是图7-1的描述" title="下面是图7-1的描述" longdesc="img_text/insert2.html"><br><a href="img_text/insert2.html">“图7-1附加插入语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="figure" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-600F105F-F662-4676-857F-8CF8AF02CFC0">
                     <p class="titleinfigure">图7-2其他获取语法</p><img src="img/fetch2.png" alt="下面是图7-2的描述" title="下面是图7-2的描述" longdesc="img_text/fetch2.html"><br><a href="img_text/fetch2.html">“图7-2附加提取语法”的说明</a></div>
                  <!-- class="figure" -->
                  <p>可选的ROWSET和ROWSET STARTING AT子句用于获取方向（FIRST，PRIOR，NEXT，LAST，CURRENT，RELATIVE和ABSOLUTE）。请考虑以下示例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>第一行</p>
                     </li>
                     <li>
                        <p>先前的行</p>
                     </li>
                     <li>
                        <p>下一行</p>
                     </li>
                     <li>
                        <p>最后一行</p>
                     </li>
                     <li>
                        <p>当前行</p>
                     </li>
                     <li>
                        <p>ROWSET在RELATIVEn开始</p>
                     </li>
                     <li>
                        <p>在ABSOLUTEn开始的ROWSET</p>
                     </li>
                  </ul>
                  <p><a href="host-tables.html#GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__BABHDBHI" title="DB2与Oracle预编译器语法">表7-3</a>中显示了DB2数组插入/获取语法的示例以及它们与相应的Oracle预编译器语法的比较：</p>
                  <div class="tblformal" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__BABHDBHI">
                     <p class="titleintable">表7-3 DB2阵列语法与Oracle预编译器语法</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DB2阵列语法与Oracle预编译器语法" width="100%" border="1" summary="DB2 vs. Oracle Precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="47%" id="d45327e1768">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="53%" id="d45327e1771">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d45327e1776" headers="d45327e1768 "><pre class="oac_no_warn" dir="ltr">EXEC SQL
  INSERT INTO DSN8810.ACT 
  (ACTNO, ACTKWD, ACTDESC) 
  VALUES (:HVA1, :HVA2, :HVA3)
  FOR :NUM_ROWS ROWS  
END-EXEC.</pre></td>
                              <td align="left" valign="top" width="53%" headers="d45327e1776 d45327e1771 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR :NUM_ROWS
  INSERT INTO DSN8810.ACT
  (ACTNO, ACTKWD, ACTDESC)
  VALUES (:HVA1, :HVA2, :HVA3)
END-EXEC.</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d45327e1783" headers="d45327e1768 "><pre class="oac_no_warn" dir="ltr">EXEC SQL
  FETCH NEXT ROWSET FROM C1 
  FOR 20 ROWS 
  INTO :HVA_EMPNO, :HVA_LASTNAME, 
       :HVA_SALARY 
END-EXEC.</pre></td>
                              <td align="left" valign="top" width="53%" headers="d45327e1783 d45327e1771 "><pre class="oac_no_warn" dir="ltr">EXEC SQL
   FOR :TWENTY
   FETCH c1 
   INTO :HVA_EMPNO, :HVA_LASTNAME,
        :HVA_SALARY
END-EXEC.</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>在DB2语法中，应在检索行数据集之前首先声明行集定位游标。要使游标能够获取行集，必须在DECLARE CURSOR语句中使用“WITH ROWSET POSITIONING”子句，这在Oracle预编译器语法中不是必需且相关的，如下表所示。</p>
                  <div class="tblformal" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-CDF826A9-ED9A-42CC-B663-0D93C9E0785A">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="table for difference between DB2 and Oracle precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="43%" id="d45327e1799">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="57%" id="d45327e1802">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d45327e1807" headers="d45327e1799 "><pre class="oac_no_warn" dir="ltr">EXEC SQL
 DECLARE C1 CURSOR
  WITH ROWSET POSITIONING FOR
  SELECT EMPNO, LASTNAME, SALARY
      FROM DSN8810.EMP
END-EXEC.</pre></td>
                              <td align="left" valign="top" width="57%" headers="d45327e1807 d45327e1802 "><pre class="oac_no_warn" dir="ltr">EXEC SQL
   DECLARE C1 CURSOR FOR
   SELECT EMPNO, LASTNAME, SALARY
        FROM DSN8810.EMP
END-EXEC.</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>可以使用预编译器选项“db2_array”启用此附加数组语法支持，其默认选项为“no”。DB2数组语法支持不能与Oracle预编译器语法一起使用;一次只支持一种语法，Oracle预编译器或DB2语法。</p>
                  <div class="example" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-96AE1816-7E6D-4073-9BAE-66935C645B56">
                     <p class="titleinexample">示例7-1使用DB2数组语法插入和获取行</p>
                     <p>此程序使用DB2数组插入语法将INSCNT行插入EMP表，然后使用DB2数组提取语法提取插入的行。</p><pre class="oac_no_warn" dir="ltr">      *****************************************************************
      * db2arrdemo:                                                   *
      *****************************************************************
 
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  db2arrdemo.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
 
      * EMBEDDED COBOL (file "DB2ARRDEMO.PCO")  
 
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
       01  EMPINDATA.
           02  EMPIN OCCURS 25 TIMES.
              03  EMPNO PIC  9(4) COMP.
              03  ENAME PIC  X(10).
              03  JOB PIC  X(9).
              03  MGR PIC 9(4).
              03  HIREDATE PIC  X(9).
              03  SAL PIC  X(6).
              03  COMM PIC  X(6).
              03  DEPTNO PIC  9(2).
 
       01  EMPOUTDATA.
           02  EMPOUT OCCURS 5 TIMES.
              03  EMPNO1 PIC  9(4) COMP.
              03  ENAME1 PIC  X(10).
              03  JOB1 PIC  X(9).
              03  MGR1 PIC 9(4).
              03  HIREDATE1 PIC  X(9).
              03  SAL1 PIC  X(6).
              03  COMM1 PIC  X(6).
              03  DEPTNO1 PIC  9(2).
 
           EXEC SQL END DECLARE SECTION END-EXEC.
 
       01  INSCNT PIC  9(3) COMP VALUE 25.
       01  FETCHCNT PIC  9(3) COMP VALUE 5.
       01  CNT PIC  9(4).
       01  CNT2 PIC  9(2).
 
       01  STRINGFIELDS.
           02 STR PIC X(18) VARYING.
 
           EXEC SQL INCLUDE SQLCA END-EXEC.
 
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC.
 
           PERFORM LOGON.
 
      * Fill the array elements to insert.
   PERFORM FILL-DATA VARYING CNT FROM 1 BY 1 
           UNTIL CNT &gt; INSCNT.
 
      * Inserting data using DB2 array insert syntax.
   DISPLAY "Inserting data using DB2 array insert syntax".
   EXEC SQL INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE,
            SAL, COMM, DEPTNO) VALUES (:EMPIN)
    FOR :INSCNT ROWS
   END-EXEC.
 
   EXEC SQL SELECT COUNT(*) INTO :CNT FROM EMP
            WHERE ENAME LIKE 'EMP_%'
   END-EXEC.
   DISPLAY "Number of rows successfully inserted into EMP "
           "table:", CNT.
 
   DISPLAY " ".
      * Declares scrollable cursor to fetch data.
           EXEC SQL DECLARE C1 SCROLL CURSOR FOR
                    SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL,
    COMM, DEPTNO 
    FROM EMP
            WHERE ENAME LIKE 'EMP_%'
    ORDER BY EMPNO
   END-EXEC.
 
           EXEC SQL OPEN C1 END-EXEC.
 
   DISPLAY "Fetching data using DB2 array fetch syntax ". 
         PERFORM FETCH-TAB.
       ENDFETCH-TAB.
 
   EXEC SQL CLOSE C1 END-EXEC.
 
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
 
       LOGON.
           MOVE "scott" TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE "tiger" TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
 
      * FILLS ARRAY TO INSERT INTO EMP TABLE
       FILL-DATA.
           MOVE CNT TO EMPNO(CNT).
 
   MOVE " " TO STR.
   STRING "EMP_", CNT INTO STR
   END-STRING.
   MOVE STR TO ENAME(CNT).
 
   MOVE " " TO STR.
   STRING "JOB_", CNT INTO STR
   END-STRING.
   MOVE STR TO JOB(CNT).
 
   MOVE 100 TO MGR(CNT).
 
   IF CNT &gt; 30 THEN
       COMPUTE CNT2 = 30
   ELSE 
       MOVE CNT TO CNT2
   END-IF
 
   MOVE " " TO STR.
   STRING CNT2, "-JAN-06" INTO STR
   END-STRING.
   MOVE STR TO HIREDATE(CNT).
 
   MOVE " " TO STR.
   STRING CNT2, "000" INTO STR
   END-STRING.
   MOVE STR TO SAL(CNT).
 
   MOVE 1000 TO COMM(CNT).
 
   MOVE 10 TO DEPTNO(CNT).
 
      * FETCHES DATA FROM EMP TABLE
       FETCH-TAB.
           EXEC SQL WHENEVER NOT FOUND GOTO ENDFETCH-TAB END-EXEC.
   DISPLAY "Fetch using FETCH FIRST ROWSET". 
           EXEC SQL FETCH FIRST ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY " ".
   DISPLAY "Fetch using FETCH NEXT ROWSET". 
           EXEC SQL FETCH NEXT ROWSET FROM C1 FOR 5 ROWS 
            INTO :EMPOUT END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY " ".
   DISPLAY "Fetch using FETCH CURRENT ROWSET". 
           EXEC SQL FETCH CURRENT ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY " ".
   DISPLAY "Fetch using FETCH LAST ROWSET". 
           EXEC SQL FETCH LAST ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY " ".
   DISPLAY "Fetch using FETCH ROWSET STARTING AT ABSOLUTE". 
   COMPUTE CNT = 4 * FETCHCNT.
           EXEC SQL FETCH ROWSET STARTING AT ABSOLUTE :CNT FROM C1
            FOR 5 ROWS INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY " ".
   DISPLAY "Fetch using FETCH ROWSET STARTING AT RELATIVE". 
           EXEC SQL FETCH ROWSET STARTING AT RELATIVE -3 FROM C1
            FOR :FETCHCNT ROWS INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY " ".
   DISPLAY "Fetch using FETCH PRIOR ROWSET ". 
           EXEC SQL FETCH PRIOR ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
      * Prints fetched data
       PRINTDATA.
   PERFORM VARYING CNT FROM 1 BY 1 UNTIL CNT &gt; FETCHCNT
             DISPLAY "Empno=", EMPNO1(CNT), ", Ename=", ENAME1(CNT),
             ", Job=", JOB1(CNT), ", Mgr=", MGR1(CNT),
                     ", Hiredate=", HIREDATE1(CNT)
             DISPLAY "Sal=", SAL1(CNT), ", Comm=", COMM1(CNT),
             ", Deptno=", DEPTNO1(CNT)
           END-PERFORM.
 
      * HANDLES SQL ERROR CONDITIONS
       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY " ".
           DISPLAY "ORACLE ERROR DETECTED:".
           DISPLAY " ".
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPCB492"></a><a id="LNPCB491"></a><div class="props_rev_3"><a id="GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19" name="GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19"></a><h3 id="LNPCB-GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19" class="sect3"><span class="enumeration_section">7.15</span>使用隐式缓冲插入</h3>
               <div>
                  <p>为了提高性能，Pro * Cobol应用程序开发人员可以在其嵌入式SQL语句中引用主机数组。这提供了一种通过单次往返数据库来执行SQL语句数组的方法。尽管阵列执行提供了显着的性能改进，但一些开发人员选择不使用此功能，因为它不是ANSI标准。例如，使用IBM的预编译器无法预编译在Oracle中利用数组执行编写的应用程序。</p>
                  <p>一种解决方法是使用缓冲的INSERT语句，这使您可以在保留ANSI标准嵌入式SQL语法的同时获得性能优势。</p>
                  <p>命令行选项“max_row_insert”控制在执行INSERT语句之前要缓冲的行数。默认情况下，它为零，并且禁用该功能。要启用此功能，请指定任何大于零的数字。</p>
                  <p>如果启用了插入缓冲，则预编译器运行时将标记相应的光标并：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>分配或重新分配额外的内存以保存绑定值（仅首先执行）。</p>
                     </li>
                     <li>
                        <p>将绑定值从程序主机变量复制到内部运行时绑定结构。</p>
                     </li>
                     <li>
                        <p>增加行缓冲计数。</p>
                     </li>
                     <li>
                        <p>如果MAX_INSERT_ROWS已被缓冲，则刷新缓冲的INSERT语句。</p>
                     </li>
                     <li>
                        <p>如果尚未命中MAX_INSERT_ROWS，则在将值复制到内部绑定缓冲区而不刷新后返回。</p>
                     </li>
                  </ul>
                  <p>如果要执行新的嵌入式SQL语句，则会导致刷新缓冲的插入语句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>冲洗缓冲区。</p>
                     </li>
                     <li>
                        <p>继续提示刷新的调用</p>
                     </li>
                  </ul>
                  <p>通过标准预编译器错误机制（例如Pro * Cobol中的SQLCODE或SQLSTATE）通知应用程序错误。</p>
                  <p>“implicit_svpt”选项控制是否在新批处理插入的开始之前采用隐式保存点。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果是，则在开始新批次行之前获取保存点。如果插入时发生错误，则执行隐式“回滚到保存点”。</p>
                     </li>
                     <li>
                        <p>如果不是，则不会采用隐式保存点。如果缓冲插入时发生错误，则会将其报告回应用程序，但不会执行回滚。缓冲区插入异步报告错误。在应用程序中执行INSERT语句时，不会报告插入行的错误。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当执行除INSERT之外的第一个语句时，稍后将报告插入行的某些错误。这可能包括DELETE，UPDATE，INSERT（进入不同的表），COMMIT和ROLLBACK。任何关闭缓冲插入语句的语句都可以报告错误。在这种情况下，不会执行报告错误的语句。您需要首先处理错误并重新执行报告缓冲插入错误的语句。否则，您可以回滚事务并重新执行它。</p>
                              <p>例如，考虑使用COMMIT语句来关闭缓冲的插入循环。COMMIT可以报告错误，因为来自先前插入的重复键。在这种情况下，不执行提交。您应该首先处理错误，然后重新执行COMMIT。否则，您可以回滚事务并重新执行它。</p>
                           </li>
                           <li>
                              <p>插件本身会报告一些错误，并且可能反映先前插入的行的错误。在这种情况下，不会执行进一步的插入。您需要处理先前插入的行的错误并继续插入当前插入，这是一个漫长的过程。相反，您可以回滚并重新执行该事务。</p>
                              <p>例如，考虑内部缓冲区的限制为10行，应用程序在循环中插入15行。假设第8行有错误。第11行插入发生时报告错误，并且不再执行插入操作。</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>以下是缓冲插入期间可能遇到的一些错误：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>ORA-00001：索引中的重复键</p>
                     </li>
                     <li>
                        <p>ORA-01400：在插入期间缺少必需（非空）列或Null</p>
                     </li>
                     <li>
                        <p>ORA-01401：插入的值对于列太大</p>
                     </li>
                     <li>
                        <p>ORA-01438：大于指定精度的值允许此列</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19__GUID-A28BF4EE-FE2C-4B62-A5FB-2A6B21CA1845">
                     <p class="titleinexample">例7-2将缓冲行插入表中</p>
                     <p>该程序将LOOPCNT行数插入EMP表。在循环计数器= 5时，此程序尝试插入无效的empno。如果没有max_row_insert选项，程序将插入除无效行之外的所有行。当max_row_insert选项设置为LOOPCNT时，仅插入前四行。</p>
                     <p>使用max_row_insert选项，当删除错误语句时，程序执行与数组插入程序相同的方式。</p><pre class="oac_no_warn" dir="ltr"> *****************************************************************
      * bufinsdemo:                                                   *
      *                                                               *
      * This program inserts LOOPCNT number of rows into EMP table.   *
      * At loop counter=5, this program attempts to insert an invalid *
      * empno. Without max_row_insert option, this program inserts    *
      * all rows except this invalid row. When max_row_insert option  *
      * is set to LOOPCNT, only the first 4 rows are inserted.        *
      *                                                               *
      * With max_row_insert option, when this errorneous statement    *
      * is removed, the performance of this program is similar to     *
      * having an array insert in this program.                       *
      *****************************************************************
 
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  bufinsdemo.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
 
      * EMBEDDED COBOL (file "BUFINSDEMO.PCO")  
 
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
 
       01  EMPIN.
           02  EMPNO PIC  9(6) COMP.
           02  ENAME PIC  X(10).
           02 JOB PIC  X(9).
           02  MGR PIC 9(4).
           02  HIREDATE PIC  X(9).
           02  SAL PIC  X(6).
           02  COMM PIC  X(6).
           02  DEPTNO PIC  9(2).
 
       01  EMPOUT.
           02  EMPNO1 PIC  9(4) COMP.
           02  ENAME1 PIC  X(10).
           02  JOB1 PIC  X(9).
           02  MGR1 PIC 9(4).
           02  HIREDATE1 PIC  X(9).
           02  SAL1 PIC  X(6).
           02  COMM1 PIC  X(6).
           02  DEPTNO1 PIC  9(2).
 
           EXEC SQL END DECLARE SECTION END-EXEC.
 
       01  LOOPCNT PIC  9(4) COMP VALUE 100.
       01  CNT PIC  9(4).
       01  CNT2 PIC  9(2).
 
       01  STRINGFIELDS.
           02 STR PIC X(18) VARYING.
 
           EXEC SQL INCLUDE SQLCA END-EXEC.
 
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC.
 
           PERFORM LOGON.
 
      * When max_row_insert option is set to LOOPCNT and when the errorneous
      * statement is removed, all the rows will be inserted into the database
      * in one stretch and hence maximum performance gain will be achieved.
   DISPLAY "Inserting ", LOOPCNT, " rows into EMP table".
   PERFORM INS-TAB VARYING CNT FROM 1 BY 1 
           UNTIL CNT &gt; LOOPCNT.
 
   EXEc SQL COMMIT END-EXEC.
 
   EXEC SQL SELECT COUNT(*) INTO :CNT FROM EMP
            WHERE ENAME LIKE 'EMP_%'
   END-EXEC.
   DISPLAY "Number of rows successfully inserted into EMP "
           "table:", CNT.
 
   DISPLAY " ".
           EXEC SQL DECLARE C1 CURSOR FOR
                    SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL,
    COMM, DEPTNO 
    FROM EMP
            WHERE ENAME LIKE 'EMP_%'
    ORDER BY EMPNO
   END-EXEC.
 
           EXEC SQL OPEN C1 END-EXEC.
 
   DISPLAY "Fetching inserted rows from EMP table". 
      	   PERFORM FETCH-TAB.
       ENDFETCH-TAB.
 
   EXEC SQL CLOSE C1 END-EXEC.
 
   EXEC SQL DELETE FROM EMP WHERE EMPNO &lt; 1000 END-EXEC.
 
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.
 
       LOGON.
           MOVE "scott" TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE "tiger" TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
 
      * INSERTS DATA INTO EMP TABLE
       INS-TAB.
   IF CNT = 5 THEN
     MOVE 10000 TO EMPNO
   ELSE
             MOVE CNT TO EMPNO
   END-IF
 
   MOVE " " TO STR.
   STRING "EMP_", CNT INTO STR
   END-STRING.
   MOVE STR TO ENAME.
 
   MOVE " " TO STR.
   STRING "JOB_", CNT INTO STR
   END-STRING.
   MOVE STR TO JOB.
 
   MOVE 100 TO MGR.
 
   IF CNT &gt; 30 THEN
       COMPUTE CNT2 = 30
   ELSE 
       MOVE CNT TO CNT2
   END-IF
 
   MOVE " " TO STR.
   STRING CNT2, "-JAN-06" INTO STR
   END-STRING.
   MOVE STR TO HIREDATE.
 
   MOVE " " TO STR.
   STRING CNT2, "000" INTO STR
   END-STRING.
   MOVE STR TO SAL.
 
   MOVE 1000 TO COMM.
 
   MOVE 10 TO DEPTNO.
 
   EXEC SQL INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE,
            SAL, COMM, DEPTNO) VALUES (:EMPIN)
   END-EXEC.
 
      * FETCHES DATA FROM EMP TABLE
       FETCH-TAB.
           EXEC SQL WHENEVER NOT FOUND GOTO ENDFETCH-TAB END-EXEC.
           EXEC SQL FETCH C1 INTO :EMPOUT END-EXEC.
           DISPLAY "Empno=", EMPNO1, ", Ename=", ENAME1,
 ", Job=", JOB1, ", Mgr=", MGR1,
                   ", Hiredate=", HIREDATE1.
           DISPLAY "Sal=", SAL1, ", Comm=", COMM1, ", Deptno=", DEPTNO1.
 GO TO FETCH-TAB.
 
      * HANDLES SQL ERROR CONDITIONS
       SQL-ERROR.
           DISPLAY "ORACLE ERROR DETECTED:".
           DISPLAY SQLERRMC.</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>